<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width,             img: priestImg,
            animations: animationsPriest,
            frameW: 44,
            frameH: 64,
            size: 100,al-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>RPG Battle Game</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Jacquard+24&family=Jersey+10&display=swap");

      body {
        margin: 0;
        padding: 0;
        background: black;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        font-family: "Press Start 2P", monospace;
      }
      canvas {
        display: block;
        image-rendering: pixelated;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const designWidth = 360;
      const designHeight = 640;
      const screenCenterX = designWidth / 2; // Centro exacto de pantalla: 180px

      // Constantes de layout para áreas fijas
      const HEADER_HEIGHT = 60;
      const FOOTER_HEIGHT = 120;
      const FOOTER_Y = 520;
      const GAME_AREA_Y = HEADER_HEIGHT;
      const GAME_AREA_HEIGHT = FOOTER_Y - HEADER_HEIGHT; // 460px de área de juego

      const dpr = window.devicePixelRatio || 1;
      canvas.width = designWidth * dpr;
      canvas.height = designHeight * dpr;
      ctx.scale(dpr, dpr);
      canvas.style.width = designWidth + "px";
      canvas.style.height = designHeight + "px";

      // Load images
      const backgroundImg = new Image();
      backgroundImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ChatGPT%20Image%2010%20ago%202025%2C%2001_31_21-11GclhftpsCG06vNEd4ri4gVBVUY8o.png?aymA";

      // Background para nivel 2
      const backgroundLevel2Img = new Image();
      backgroundLevel2Img.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/red_dunes-elmz1XktqRUANSNvvj8jYAoxXZsMkt.png?t9TH";

      // Background para nivel 3
      const backgroundLevel3Img = new Image();
      backgroundLevel3Img.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/dark_swamp-eMmE7CgLp4Bx3xpLSgXlriVLfXN325.png?opu2";

      // Background para pantallas de información de nivel
      const levelInfoBackgroundImg = new Image();
      levelInfoBackgroundImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/dark_swamp_window-lrkt7WbouEZqCWjp3IlD9mptsv2aab.png?A8mv";

      // Background para pantalla de inicio
      const mainMenuImg = new Image();
      mainMenuImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/fondo_start-8ed4QcpKSo1dG5ASd0fGjy1p66Cwll.png?Ouaf";

      // Background dinámico que cambia según el nivel
      let currentBackgroundImg = backgroundImg; // Empezar con The Crypt (nivel 1)
      const mageImg = new Image();
      mageImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/mage-TnWuIwL8nfQgfspUHLdQb117UZpBR3.png?ddSR";
      const priestImg = new Image();
      priestImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/priest-DZKVrCXOeqMuQCe0Rid7DctIkoe4m0.png?XbMV";
      const warlockImg = new Image();
      warlockImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/warlock-ufYIrOZWd5mtgudqtQ8Yd34rteekHt.png?6IzB";

      // Enemy sprites - Demon Bat (Level 1)
      const demonBatIdleImg = new Image();
      demonBatIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/IDLE-V90NoEl8WQxdfu93X92hoipQtHfW7y.png?O0Ak";
      const demonBatDeathImg = new Image();
      demonBatDeathImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/DEATH-r9w4VgFSi93NjgHhRKFPjbBK3x4XYS.png?VLXN";
      const demonBatAttackImg = new Image();
      demonBatAttackImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ATTACK-ZCinJufJA25jik8Qm2R3DSZEdfIHez.png?iCFX";

      // Enemy sprites - Worm (Level 2)
      const wormIdleImg = new Image();
      wormIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/worm_idle-vJDVrN0IWXKWwxGqO3oaeE5VfdeiHx.png?rwdu";
      const wormDeathImg = new Image();
      wormDeathImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/worm_dead-fjt1PKqQPfa4Ql1iEJn92utXSHg48b.png?8dpt";
      const wormAttackImg = new Image();
      wormAttackImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/worm_attack-Lh6J61U6HqA0OHAbOC558yTFytcB58.png?yXF1";

      // Boss Minotaur sprites (Level 2 Boss) - Todas las animaciones en un solo sprite sheet
      const minotaurAllStatesImg = new Image();
      minotaurAllStatesImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/minotaur-sheet-Bv1KHH5UMJznTKr0gBV7kf6WUmOwZr.png?ZYdW";

      // Enemy sprites - Crab Bomb (Red Dunes special enemy)
      const crabBombIdleImg = new Image();
      crabBombIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ExplodingCrab%20Idle%2080x80-0xtADn8zveaJ99wQ8iQ0n4ilSjdiE9.png?UHf2";
      const crabBombDeathImg = new Image();
      crabBombDeathImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ExplodingCrab%20Death%2080x80-zDqZ4Ap4lWpensLHh3Lc2duYTtJCbG.png?1H5H";
      const crabBombExplodeImg = new Image();
      crabBombExplodeImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ExplodingCrab%20Explosion%2080x80-s3lRsNv4geuEqgjeWnasKtj6ibp1Iq.png?2GI8";

      // Enemy sprites - Mushroom (Dark Swamp normal enemy)
      const mushroomIdleImg = new Image();
      mushroomIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Mushroom-Idle-EbLaNtWreU7hEFwLThlVXyUUJUJbai.png?F111";
      const mushroomDeathImg = new Image();
      mushroomDeathImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Mushroom-Die-7HLapaD04zcX4shcBLZ3Wou2eClQCS.png?woNV";

      // Enemy sprites - Dreadwing (Dark Swamp flying enemy)
      const dreadwingIdleImg = new Image();
      dreadwingIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/swamp1_idle-ptG3GPSMeKcPxFdkhF4wXppEuKuIa8.png?XaXC";
      const dreadwingDeathImg = new Image();
      dreadwingDeathImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/swamp1_die-DP89ewxMkNaTGlxgh0HvP1gMsBdALz.png?AIEw";

      // Boss Swamp Gorgon sprites (Level 3 Boss) - Sprites individuales
      const swampGorgonIdleImg = new Image();
      swampGorgonIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Idle-2lKYMS7BBvm0cmpt5PyeU5VHN6g9Wj.png?gXER";

      const swampGorgonAttackImg = new Image();
      swampGorgonAttackImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Attack_2-nIg5G4WQX6MvAqgvOZEvC7jqkPlirE.png?t6rx";

      const swampGorgonSpecialAttackImg = new Image();
      swampGorgonSpecialAttackImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Attack_1-ORaqcWCCsweJHmdryjOSJqMYt9F9v2.png?XGn6";

      const swampGorgonDeathImg = new Image();
      swampGorgonDeathImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Dead-iRXzEKgppuyOurS2Ss4otFen8wiy1N.png?xC4K";

      // Boss Bat sprites (Level 1 Boss)
      const bossBatIdleImg = new Image();
      bossBatIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/IDLE_BOSS_1-N75RUTJp8bkxCSPZuvUWDye1KogjOS.png?C7Ns";
      const bossBatDeathImg = new Image();
      bossBatDeathImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/DEATH_BOSS_1-gjjAV8gTr6DBjZQ94xcwKAM8y63w2h.png?2Akf";
      const bossBatAttackImg = new Image();
      bossBatAttackImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ATTACK_BOSS_1-FArHbCZ2DrOKLJj2YyFvpSztZ5Ryq9.png?SSuQ";

      // Boss special ability effect
      const bloodSplatImg = new Image();
      bloodSplatImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Blood%20Splat-0zg8BGvPxZDBDQds5ZQiTgB7o5ebiC.png?59te";

      // Mantener sprites antiguos para compatibilidad temporal
      const enemyImg = new Image();
      enemyImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/beast_gigasChad-jHhAfiqtBGKuiIHRZJ0MkWs0W5uFQ5.png?9LBT";
      const goblinIdleImg = new Image();
      goblinIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/IDLE-V90NoEl8WQxdfu93X92hoipQtHfW7y.png?O0Ak";
      const goblinDieImg = new Image();
      goblinDieImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/DEATH-r9w4VgFSi93NjgHhRKFPjbBK3x4XYS.png?VLXN";

      // Sprites de efectos de habilidades
      const effectsImg = new Image();
      effectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Red%20Effect%20Bullet%20Impact%20Explosion%2032x32-NnvGEsfH13xUZuEqmJAXk2oelYwGoV.png?b5e9";

      // Sprites de efectos púrpura para warlock
      const purpleEffectsImg = new Image();
      purpleEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Purple%20Effect%20Bullet%20Impact%20Explosion%2032x32-tBftQaSwItblEIfJStK8fGzQZEaFvQ.png?7m6v";

      // Sprite de efectos de curación
      const healingEffectsImg = new Image();
      healingEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Regen-IsFeOv1fkkRBrdZ1wZqoyhE5DrXPmz.png?22AH";

      // Sprite de efectos de rayo para Smite
      const lightningEffectsImg = new Image();
      lightningEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Lightning-JDFXQsYo47LoZYiuRiYJRnGOxeYgZc.png?8HcK";

      // Sprite de efectos de Dark Bolt para Inmolation
      const darkBoltEffectsImg = new Image();
      darkBoltEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Dark-Bolt-XsHZlOlUknjRLKGCm3oDIfLlJimYCf.png?Lpbv";

      // Sprite de efectos de Blood Splat para Boss Bat (habilidad principal - un solo aliado)
      const bloodSplatEffectsImg = new Image();
      bloodSplatEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/sprite-sheet2-fpBxr82a3zc37rRAF6S573qRmIXtGU.png?ANvP";

      // Sprite de efectos de Blood Storm para Boss Bat (habilidad especial - todos los aliados)
      const bloodStormEffectsImg = new Image();
      bloodStormEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/sprite-sheet-F3tkTJhh68R3ZU2T2GrvwFXwEamfaf.png?pJmM";

      // Sprites mejorados para habilidades del Priest
      const priestSmiteEffectsImg = new Image();
      priestSmiteEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/smite-Bjk86Soi2Gf9vFJBLWIvzPGFBp44Hf.png?WXvo";

      const priestHolyWaveEffectsImg = new Image();
      priestHolyWaveEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/heal-3Xw84tzIf6iA8iM9A7ATJFLffNucdb.png?VXbc";

      const priestRegrowthEffectsImg = new Image();
      priestRegrowthEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/regrowth-jwXtVqqCJVlVmtGbVon46zD1y7zmbJ.png?YYsp";

      // Minotaur effects sprites
      const minotaurSmashEffectsImg = new Image();
      minotaurSmashEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/minotaur_normal-3TLpHMzhlYcUnC1CBuUC2d2VRA3DpS.png?n1Bm";

      const minotaurLifeStealEffectsImg = new Image();
      minotaurLifeStealEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/minotaur_special-zBxxGSBFlpUHDEVfULo1Qk6KuB00K6.png?uuJE";

      // Nuevos efectos mejorados
      const combustionEffectsImg = new Image();
      combustionEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/combustion-0ifHizZSGTiojCA9n7UpSkfkqn6qM5.png?18TW";

      const cthuluMainEffectsImg = new Image();
      cthuluMainEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/poison_main-vaefYRxX0tC5YTqWpWFboyItMAK9sC.png?tqGw";

      const cthuluSpecialEffectsImg = new Image();
      cthuluSpecialEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/poison_special-6DGH6sKHmuBlpk3clAxyhJ1fDcCcpy.png?tmXd";

      // Debuff/Buff Icons
      // Debuffs - Iconos individuales mejorados
      const healingDebuffImg = new Image();
      healingDebuffImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/healing-YGKWqqGrTxhH9nhj77jIaH3ezS2vvi.png?oHcR";

      const protectionDebuffImg = new Image();
      protectionDebuffImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/protec-X9cTS5hoFr9md7Ltog9G5yC5SKScv4.png?zi1r";

      const combustionDebuffImg = new Image();
      combustionDebuffImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/combustion-POS1UpYARnaioLsfaKNCqSob1xs0gl.png?8CXB";

      const bersekerDebuffImg = new Image();
      bersekerDebuffImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/berseker-Pxtuppp6McZnp7KQKIrlZMwIYgNxi4.png?mdnk";

      const poisonDebuffImg = new Image();
      poisonDebuffImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/poison-y1X2h1bNJlxnP7MA15GtrUyaYio8dQ.png?joqy";

      // Configuración de niveles - CORREGIDO PARA DARK SWAMP LEVEL 3
      const levelConfig = {
        1: {
          name: "The Crypt",
          background:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ChatGPT%20Image%2010%20ago%202025%2C%2001_31_21-11GclhftpsCG06vNEd4ri4gVBVUY8o.png?aymA",
          enemies: {
            normal: {
              name: "Demon Bat",
              hp: 80, // Según especificaciones
              sprites: {
                idle: demonBatIdleImg,
                death: demonBatDeathImg,
                attack: demonBatAttackImg,
              },
              frameWidth: 81,
              frameHeight: 71,
              idleFrames: 4,
              deathFrames: 6,
              attackFrames: 8,
              chargeSpeed: 30, // 6/10 velocidad según especificaciones
              chargeSpeedRating: 6, // 6/10 velocidad según especificaciones
              size: 80,
              isFlying: true, // Volador según especificaciones
              mainAbility: "basic_attack", // Habilidad básica que hace daño bajo/intermedio a héroe aleatorio
            },
            boss: {
              name: "Noctebane", // Boss renombrado según especificaciones
              hp: 200, // Según especificaciones
              sprites: {
                idle: bossBatIdleImg,
                death: bossBatDeathImg,
                attack: bossBatAttackImg,
              },
              frameWidth: 81,
              frameHeight: 71,
              idleFrames: 4,
              deathFrames: 6,
              attackFrames: 8,
              chargeSpeed: 30, // 6/10 velocidad según especificaciones
              chargeSpeedRating: 6, // 6/10 velocidad según especificaciones
              size: 120,
              specialAttackCounter: 3, // 3 esferas para habilidad especial
              mainAbility: "blood_splat", // Blood Splat: daño normal a héroe aleatorio
              specialAbility: "blood_storm", // Blood Storm: daña a todos los héroes
              isFlying: true, // Volador según especificaciones
            },
          },
        },
        3: {
          name: "Dark Swamp",
          background:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/dark_swamp-eMmE7CgLp4Bx3xpLSgXlriVLfXN325.png?opu2",
          enemies: {
            normal: {
              name: "Mushroom",
              hp: 100, // ✅ Correcto según especificaciones
              sprites: {
                idle: mushroomIdleImg,
                death: mushroomDeathImg,
                attack: mushroomIdleImg, // Usar idle para attack por ahora
              },
              frameWidth: 80, // 560px / 7 frames = 80px por frame
              frameHeight: 64,
              idleFrames: 7, // 7 frames en row para IDLE
              deathFrames: 15, // 15 frames en row para DIE
              attackFrames: 7, // Mismo que idle
              chargeSpeed: 30, // Corregido para 6/10 velocidad
              chargeSpeedRating: 6, // Corregido: 6/10 velocidad según especificaciones
              size: 120, // Aumentado de 100 a 120
              isFlying: false, // Terrestre
              mainAbility: "poison_attack", // Ataque con veneno
            },
            flying: {
              name: "Dreadwing",
              hp: 90, // Corregido: era 80, ahora 90 según especificaciones
              sprites: {
                idle: dreadwingIdleImg,
                death: dreadwingDeathImg,
                attack: dreadwingIdleImg, // Usar idle para attack por ahora
              },
              frameWidth: 64,
              frameHeight: 64,
              idleFrames: 8,
              deathFrames: 17,
              attackFrames: 8, // Mismo que idle
              chargeSpeed: 25, // Corregido para 5/10 velocidad
              chargeSpeedRating: 5, // Corregido: 5/10 velocidad según especificaciones
              size: 90,
              isFlying: true, // Volador
              mainAbility: "double_strike", // Ataque doble
            },
            boss: {
              name: "Gorgon",
              hp: 400, // Corregido: era 350, ahora 400 según especificaciones
              sprites: {
                idle: swampGorgonIdleImg,
                death: swampGorgonDeathImg,
                attack: swampGorgonAttackImg,
                specialAttack: swampGorgonSpecialAttackImg,
              },
              frameWidth: 128, // 128x128 cada frame
              frameHeight: 128,
              idleFrames: 7, // 7 frames para IDLE
              deathFrames: 3, // 3 frames para DIE
              attackFrames: 7, // 7 frames para NORMAL_ATTACK
              specialAttackFrames: 16, // 16 frames para SPECIAL_ATTACK
              chargeSpeed: 30, // Corregido para 6/10 velocidad
              chargeSpeedRating: 6, // Corregido: 6/10 velocidad según especificaciones
              size: 180, // Tamaño reducido para mejor proporción
              specialAttackCounter: 3,
              mainAbility: "poison_strike", // Corregido: nombre según especificaciones
              specialAbility: "toxic_horror", // Mantener la misma habilidad especial
              isFlying: false, // Terrestre
            },
          },
        },
        2: {
          name: "Red Dunes",
          background:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/red_dunes-elmz1XktqRUANSNvvj8jYAoxXZsMkt.png?t9TH",
          enemies: {
            normal: {
              name: "Fire Worm",
              hp: 80, // Según especificaciones
              sprites: {
                idle: wormIdleImg,
                death: wormDeathImg,
                attack: wormAttackImg,
              },
              frameWidth: 90,
              frameHeight: 90,
              idleFrames: 9,
              deathFrames: 8,
              attackFrames: 16,
              chargeSpeed: 30, // 6/10 velocidad según especificaciones
              chargeSpeedRating: 6, // 6/10 velocidad según especificaciones
              size: 130,
              isFlying: false, // Terrestre
              mainAbility: "basic_attack", // Ataque básico intermedio
            },
            special: {
              name: "Crab Bomb",
              hp: 150, // Según especificaciones
              sprites: {
                idle: crabBombIdleImg,
                death: crabBombDeathImg,
                attack: crabBombIdleImg, // Usar idle como fallback
                explode: crabBombExplodeImg, // Sprite especial para explosión
              },
              frameWidth: 80, // 80x80 según especificaciones
              frameHeight: 80,
              idleFrames: 13, // 1040px / 80px = 13 frames
              deathFrames: 6, // 480px / 80px = 6 frames
              explodeFrames: 23, // 1840px / 80px = 23 frames
              chargeSpeed: 25, // 5/10 velocidad según especificaciones
              chargeSpeedRating: 5, // 5/10 velocidad según especificaciones
              size: 120,
              isFlying: false, // Terrestre
              mainAbility: "explode", // Habilidad especial de explosión
              specialAttackCounter: 5, // 5 esferas como especificado
              noBasicAttack: true, // No tiene habilidad básica
            },
            boss: {
              name: "Minotaur",
              hp: 300, // Según especificaciones
              sprites: {
                idle: minotaurAllStatesImg,
                death: minotaurAllStatesImg,
                attack: minotaurAllStatesImg,
              },
              frameWidth: 288,
              frameHeight: 160,
              idleFrames: 16, // Primera fila: IDLE 16 frames
              deathFrames: 16, // No hay animación de muerte, usar idle/attack para transición
              attackFrames: 16, // Segunda fila: ATTACK 16 frames
              chargeSpeed: 25, // Empieza en 5/10 velocidad según especificaciones
              chargeSpeedRating: 5, // Empieza en 5/10 y va subiendo
              size: 320,
              specialAttackCounter: 3, // Contador para ataque especial
              mainAbility: "smash", // Nombre correcto según especificaciones
              specialAbility: "life_steal", // Nombre correcto según especificaciones
              isFlying: false, // Terrestre
            },
          },
        },
        // Aquí se añadirán más niveles en el futuro
      };

      // UI Elements - Solo los elementos que se usan
      const panelBrownImg = new Image();
      panelBrownImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/panel_brown-49f4SM1AoKwCYlEq9piZiXmfxdEC0G.png?ZpjN";

      const buttonLongBeigeImg = new Image();
      buttonLongBeigeImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/buttonLong_beige-AkYz3mfJrwayHOsnKfj3J2cFcEajGT.png?vtgY";

      // Animations - actualizadas con nuevas habilidades
      const animationsMage = {
        selected: { row: 0, frames: 6, duration: 0.6 },
        idle: { row: 1, frames: 6, duration: 0.6 },
        fireblast: { row: 2, frames: 7, duration: 1 },
        combustion: { row: 4, frames: 6, duration: 1 }, // Usar la misma fila que inferno
        inferno: { row: 4, frames: 6, duration: 1 },
      };
      const animationsPriest = {
        selected: { row: 0, frames: 6, duration: 0.6 },
        idle: { row: 1, frames: 6, duration: 0.6 },
        holywave: { row: 2, frames: 7, duration: 1 },
        smite: { row: 3, frames: 6, duration: 1 },
        regrowth: { row: 4, frames: 6, duration: 1 },
      };
      const animationsWarlock = {
        selected: { row: 0, frames: 6, duration: 0.6 },
        idle: { row: 1, frames: 6, duration: 0.6 },
        darkslash: { row: 2, frames: 7, duration: 1 },
        agony: { row: 3, frames: 6, duration: 0.5 }, // Instantáneo
        inmolation: { row: 4, frames: 7, duration: 1 },
      };

      let score = 0;
      let wave = 0;
      let heroes = [];
      let enemies = [];
      let state = "main_menu";
      let selectedHero = null;
      let selectedAction = null;
      let turnPhase = "player";
      let currentEnemyIndex = 0;
      let slashStreak = 0;
      let currentTime = 0;
      let hitNumbers = []; // Array para almacenar los números de golpe flotantes
      let visualEffects = []; // Array para efectos visuales especiales
      let levelCompletionModal = { show: false, level: 0, boss: "", timer: 0 }; // Modal de finalización de nivel
      let currentLevel = 1; // Nivel actual del juego (1, 2, 3)

      // Información de los niveles
      const levelInfo = {
        1: {
          name: "The Forgotten Crypt",
          lore: "The mages ventured into the ancient crypt in search of the lost arcane artifacts. Dark creatures await in the shadows...",
          boss: "Shadow Bat Lord",
          background: "#1a0d0a", // Color de fondo marrón oscuro para la cripta
        },
        2: {
          name: "The Red Dunes",
          lore: "Beyond the crypt lies a cursed desert where the crimson sands conceal deadly predators beneath their surface...",
          boss: "Minotaur Guardian",
          background: "#3d2012", // Color de fondo marrón rojizo para el desierto
        },
        3: {
          name: "The Dark Swamp",
          lore: "In the deepest marshlands, ancient evils stir. The final challenge awaits those brave enough to face the swamp's master...",
          boss: "Swamp Gorgon",
          background: "#0d2818", // Color de fondo verde oscuro para el pantano
        },
      };

      function init() {
        heroes = [
          {
            clazz: "mage",
            hp: 100,
            maxhp: 100,
            def: 3, // Poca defensa
            charge: 0, // Start empty
            maxcharge: 100,
            chargeSpeedRating: 4, // Velocidad media-baja (1-10 scale)
            posx: 80, // Posición original
            posy: 415, // Movido 20px arriba (era 450)
            anim: "idle",
            frame: 0,
            animTime: 0,
            acted: false,
            buffs: [],
            debuffs: [], // Array para iconos de debuffs/buffs
            targets: [],
            action: null,
            img: mageImg,
            animations: animationsMage,
            frameW: 100, // Nuevo tamaño de frame
            frameH: 100, // Nuevo tamaño de frame
            size: 90,
          },
          {
            clazz: "warlock",
            hp: 100,
            maxhp: 100,
            def: 15, // Buena defensa
            charge: 0, // Start empty
            maxcharge: 100,
            chargeSpeedRating: 6, // Velocidad media-alta (tanque equilibrado)
            posx: 180, // Posición original
            posy: 380, // Movido 20px abajo para mejor alineación visual
            anim: "idle",
            frame: 0,
            animTime: 0,
            acted: false,
            buffs: [],
            debuffs: [], // Array para iconos de debuffs/buffs
            targets: [],
            action: null,
            img: warlockImg,
            animations: animationsWarlock,
            frameW: 100, // Nuevo tamaño de frame
            frameH: 100, // Nuevo tamaño de frame
            size: 90,
          },
          {
            clazz: "priest",
            hp: 100,
            maxhp: 100,
            def: 3, // Poca defensa
            charge: 0, // Start empty
            maxcharge: 100,
            chargeSpeedRating: 5, // Velocidad media (soporte equilibrado)
            posx: 280, // Posición original
            posy: 415, // Movido 20px arriba (era 450)
            anim: "idle",
            frame: 0,
            animTime: 0,
            acted: false,
            buffs: [],
            debuffs: [], // Array para iconos de debuffs/buffs
            targets: [],
            action: null,
            img: priestImg,
            animations: animationsPriest,
            frameW: 100, // Nuevo tamaño de frame
            frameH: 100, // Nuevo tamaño de frame
            size: 90,
          },
        ];
        enemies = [];
        score = 0;
        wave = 0;
        currentLevel = 1;
        state = "level_info"; // Empezar mostrando info del nivel 1
        turnPhase = "player";
        slashStreak = 0;
        currentBackgroundImg = backgroundImg; // The Crypt es nivel 1
        levelCompletionModal = { show: false, level: 0, boss: "", timer: 0 };
        // No llamar startWave() aquí - se llamará cuando se pulse "Enter" en level_info
      }

      function startGame() {
        console.log("Starting game...");
        // Inicializar el juego
        init();
        // El estado ya se establece como "level_info" en init()
      }

      function startWave() {
        console.log("Starting wave", wave + 1);

        // Verificar si empezamos un nuevo nivel (cada 3 waves)
        const previousLevel = Math.floor((wave - 1) / 3) + 1;
        const nextLevel = Math.floor(wave / 3) + 1;
        currentLevel = nextLevel;

        // Actualizar background según el nivel actual
        if (currentLevel === 1) {
          currentBackgroundImg = backgroundImg; // The Crypt
        } else if (currentLevel === 2) {
          currentBackgroundImg = backgroundLevel2Img; // Red Dunes
        } else if (currentLevel === 3) {
          currentBackgroundImg = backgroundLevel3Img; // Dark Swamp
        } else {
          currentBackgroundImg = backgroundImg; // Default para niveles posteriores
        }

        // Solo revivir héroes cuando se cambia de nivel completo
        if (nextLevel > previousLevel && wave % 3 === 1) {
          console.log(
            `Starting new level ${nextLevel}! Reviving all heroes with full health.`
          );
          heroes.forEach((hero) => {
            hero.hp = hero.maxhp;
            validateHP(hero);
            hero.charge = 0; // Resetear carga también
            hero.anim = "idle"; // Asegurar que estén en animación idle
            hero.frame = 0;
            // Limpiar buffs al empezar nuevo nivel
            hero.buffs = [];
          });
        } else {
          console.log(
            `Continuing level ${currentLevel}, wave ${
              ((wave - 1) % 3) + 1
            }/3 - heroes maintain their current state (dead heroes stay dead)`
          );
        }

        let enemyPositions = [];
        const currentLevelConfig =
          levelConfig[Math.floor(wave / 3) + 1] || levelConfig[1]; // Fallback al nivel 1 (The Crypt)
        const normalHP = currentLevelConfig.enemies.normal.hp;
        const flyingHP = currentLevelConfig.enemies.flying
          ? currentLevelConfig.enemies.flying.hp
          : normalHP;
        const specialHP = currentLevelConfig.enemies.special
          ? currentLevelConfig.enemies.special.hp
          : normalHP;
        const bossHP = currentLevelConfig.enemies.boss.hp;

        // Determinar el nivel actual para configurar waves específicas
        const actualLevel = Math.floor(wave / 3) + 1;

        if (wave % 3 === 0) {
          // Wave 1/3 para cada nivel
          if (actualLevel === 1) {
            // The Crypt Wave 1: 2 Demon Bat
            enemies = [
              createEnemy(120, 200, normalHP, "normal"), // Demon Bat izquierda
              createEnemy(240, 200, normalHP, "normal"), // Demon Bat derecha
            ];
          } else if (actualLevel === 2) {
            // Red Dunes Wave 1: 1 Fire Worm + 1 Crab Bomb
            enemies = [
              createEnemy(120, 200, normalHP, "normal"), // Fire Worm
              createEnemy(240, 200, specialHP, "special"), // Crab Bomb
            ];
          } else if (actualLevel === 3) {
            // Dark Swamp Wave 1: 1 Mushroom + 1 Dreadwing
            enemies = [
              createEnemy(120, 200, normalHP, "normal"), // Mushroom
              createEnemy(240, 200, flyingHP, "flying"), // Dreadwing
            ];
          } else {
            // Otros niveles mantienen la configuración original (2 enemigos normales)
            enemies = [
              createEnemy(100, 200, normalHP, "normal"),
              createEnemy(260, 200, normalHP, "normal"),
            ];
          }
        } else if (wave % 3 === 1) {
          // Wave 2/3 para cada nivel
          if (actualLevel === 1) {
            // The Crypt Wave 2: 3 Demon Bat
            enemies = [
              createEnemy(80, 200, normalHP, "normal"), // Demon Bat izquierda
              createEnemy(180, 200, normalHP, "normal"), // Demon Bat centro
              createEnemy(280, 200, normalHP, "normal"), // Demon Bat derecha
            ];
          } else if (actualLevel === 2) {
            // Red Dunes Wave 2: 1 Fire Worm + 1 Crab Bomb + 1 Fire Worm
            enemies = [
              createEnemy(80, 200, normalHP, "normal"), // Fire Worm izquierda
              createEnemy(180, 200, specialHP, "special"), // Crab Bomb centro
              createEnemy(280, 200, normalHP, "normal"), // Fire Worm derecha
            ];
          } else if (actualLevel === 3) {
            // Dark Swamp Wave 2: 1 Dreadwing + 1 Mushroom + 1 Dreadwing
            enemies = [
              createEnemy(80, 200, flyingHP, "flying"), // Dreadwing izquierda
              createEnemy(180, 200, normalHP, "normal"), // Mushroom centro
              createEnemy(280, 200, flyingHP, "flying"), // Dreadwing derecha
            ];
          } else {
            // Otros niveles mantienen la configuración original (3 enemigos normales)
            enemies = [
              createEnemy(80, 200, normalHP, "normal"),
              createEnemy(180, 200, normalHP, "normal"),
              createEnemy(280, 200, normalHP, "normal"),
            ];
          }
        } else {
          // Wave 3/3: boss para todos los niveles - centrado exacto en pantalla
          enemies = [createEnemy(screenCenterX, 200, bossHP, "boss")]; // Centro exacto: 180px
        }
        wave++;
        console.log("Wave", wave, "started with", enemies.length, "enemies");
        heroes.forEach((h) => (h.acted = false));
      }

      function createEnemy(x, y, hp, type) {
        const currentLevel = Math.floor(wave / 3) + 1;
        const currentLevelConfig = levelConfig[currentLevel] || levelConfig[1]; // Fallback al nivel 1

        let enemyConfig;
        if (type === "boss") {
          enemyConfig = currentLevelConfig.enemies.boss;
        } else if (type === "flying") {
          // Para Dark Swamp, usar el enemigo volador (Dreadwing)
          enemyConfig =
            currentLevelConfig.enemies.flying ||
            currentLevelConfig.enemies.normal;
        } else if (type === "special") {
          // Para Red Dunes, usar el enemigo especial (Crab Bomb)
          enemyConfig =
            currentLevelConfig.enemies.special ||
            currentLevelConfig.enemies.normal;
        } else {
          // Tipo normal o por defecto
          enemyConfig = currentLevelConfig.enemies.normal;
        }

        // Determinar posición Y según si es volador o terrestre
        let adjustedY = y;
        if (enemyConfig.isFlying) {
          adjustedY = y - 10; // Voladores más arriba
        } else {
          adjustedY = y + 20; // Terrestres más abajo
        }

        return {
          hp,
          maxhp: hp,
          charge: 0,
          maxcharge: 100,
          posx: x,
          posy: adjustedY,
          type,
          animTime: 0,
          def: type === "boss" ? 10 : 5,
          size: enemyConfig.size || (type === "boss" ? 140 : 110), // Usar tamaño específico o fallback
          anim: "idle",
          frame: 0,
          animStartTime: 0,
          isDying: false,
          deathAnimComplete: false,
          debuffs: [], // Array para iconos de debuffs/buffs
          name: enemyConfig.name,
          sprites: enemyConfig.sprites,
          frameWidth: enemyConfig.frameWidth,
          frameHeight: enemyConfig.frameHeight,
          idleFrames: enemyConfig.idleFrames,
          deathFrames: enemyConfig.deathFrames,
          attackFrames: enemyConfig.attackFrames,
          explodeFrames: enemyConfig.explodeFrames, // Para Crab Bomb
          chargeSpeed: enemyConfig.chargeSpeed,
          isFlying: enemyConfig.isFlying, // Añadir propiedad isFlying al enemigo
          mainAbility: enemyConfig.mainAbility, // Habilidad principal del enemigo
          noBasicAttack: enemyConfig.noBasicAttack, // Para Crab Bomb que no tiene ataque básico
          // Propiedades específicas del boss y Crab Bomb
          specialAttackCounter:
            type === "boss" || type === "special"
              ? enemyConfig.specialAttackCounter
              : null,
          specialAbility: type === "boss" ? enemyConfig.specialAbility : null,
          attacksUntilSpecial:
            type === "boss" ? enemyConfig.specialAttackCounter : null,
          sphereCharges: type === "special" ? 0 : null, // Para sistema de esferas del Crab Bomb
          maxSphereCharges:
            type === "special" ? enemyConfig.specialAttackCounter : null,
        };

        // Validar que HP y maxHP sean números válidos para evitar NaN
        if (isNaN(enemy.hp) || enemy.hp === undefined) {
          enemy.hp = hp;
        }
        if (isNaN(enemy.maxhp) || enemy.maxhp === undefined) {
          enemy.maxhp = hp;
        }

        return enemy;
      }

      // Función para validar y corregir valores de HP
      function validateHP(target) {
        const wasAlive = target.hp > 0; // Recordar si estaba vivo antes

        if (isNaN(target.hp) || target.hp === undefined || target.hp === null) {
          target.hp = target.maxhp || 1;
        }
        if (
          isNaN(target.maxhp) ||
          target.maxhp === undefined ||
          target.maxhp === null
        ) {
          target.maxhp = target.hp || 1;
        }
        target.hp = Math.max(0, target.hp);
        target.maxhp = Math.max(1, target.maxhp);

        // Si el héroe acaba de morir (tenía hp > 0 y ahora hp <= 0), limpiar efectos
        if (wasAlive && target.hp <= 0 && target.clazz) {
          // Solo para héroes (tienen clazz)
          clearAllEffectsOnDeath(target);
        }
      }

      // Función para calcular si un golpe es crítico
      function calculateCritical(baseDamage, customCritChance = 15) {
        const criticalChance = customCritChance / 100; // Convertir porcentaje a decimal
        const isCritical = Math.random() < criticalChance;
        const finalDamage = isCritical
          ? Math.floor(baseDamage * 1.5)
          : baseDamage;

        return {
          damage: finalDamage,
          isCritical: isCritical,
        };
      }

      // Función para calcular valores aleatorios en un rango
      function calculateRandomValue(baseValue, variationPercent = 20) {
        const variation = Math.floor(baseValue * (variationPercent / 100));
        const minValue = baseValue - variation;
        const maxValue = baseValue + variation;
        return minValue + Math.floor(Math.random() * (maxValue - minValue + 1));
      }

      // Función para convertir el rating de velocidad de carga (1-10) a velocidad real
      function getChargeSpeedFromRating(rating) {
        // Rating 1 = velocidad 5 (más lento)
        // Rating 10 = velocidad 50 (más rápido)
        // Escala lineal: velocidad = rating * 5
        return Math.max(1, Math.min(50, rating * 5));
      }

      // Función para aplicar bonificador de velocidad de carga
      function applyChargeSpeedBonus(character, multiplier) {
        if (character.chargeSpeedRating) {
          // Para el nuevo sistema, aumentar el rating pero mantener límites
          character.chargeSpeedRating = Math.min(
            10,
            character.chargeSpeedRating * multiplier
          );
        } else {
          // Compatibilidad con el sistema legacy
          character.chargeSpeed = (character.chargeSpeed || 20) * multiplier;
        }
      }

      // Función para obtener la velocidad de carga actual (para debugging)
      function getCurrentChargeSpeed(character) {
        if (character.chargeSpeedRating) {
          return getChargeSpeedFromRating(character.chargeSpeedRating);
        } else {
          return character.chargeSpeed || 20;
        }
      }

      const classActions = {
        mage: {
          fireblast: {
            name: "Fireblast",
            reqCharge: 33.33, // 1 carga (33.33% de 100%)
            type: "single_enemy",
            damage: 35,
            anim: "fireblast",
          },
          combustion: {
            name: "Combustion",
            reqCharge: 66.66, // 2 cargas (66.66% de 100%)
            type: "self",
            critBonus: 80, // Gran porcentaje de crítico para el próximo ataque
            anim: "combustion",
          },
          inferno: {
            name: "Inferno",
            reqCharge: 100, // 3 cargas (100%)
            type: "all_enemy",
            damage: 500, // Menos que fireblast pero a todos
            anim: "inferno",
          },
        },
        priest: {
          holywave: {
            name: "Holy Wave",
            reqCharge: 33.33, // 1 carga
            type: "single_ally",
            heal: 45,
            anim: "holywave",
          },
          smite: {
            name: "Smite",
            reqCharge: 66.66, // 2 cargas
            type: "single_enemy",
            damage: 20, // Poco daño
            anim: "smite",
          },
          regrowth: {
            name: "Regrowth",
            reqCharge: 100, // 3 cargas
            type: "all_ally",
            heal: 8, // Base para rango 7-9
            ticks: 10, // 10 segundos de duración
            anim: "regrowth",
          },
        },
        warlock: {
          darkslash: {
            name: "Dark Slash",
            reqCharge: 33.33, // 1 carga
            type: "single_enemy",
            damage: 25,
            anim: "darkslash",
          },
          agony: {
            name: "Agony",
            reqCharge: 66.66, // 2 cargas
            type: "all_ally",
            damageReduction: 20, // 20% reducción de daño
            duration: 20, // 20 segundos
            anim: "agony",
          },
          inmolation: {
            name: "Inmolation",
            reqCharge: 100, // 3 cargas
            type: "all_enemy",
            damage: 45, // Mucho daño
            selfDamage: 60, // 60% de su vida
            anim: "inmolation",
          },
        },
      };

      function checkGameOver() {
        if (heroes.every((h) => h.hp <= 0)) {
          alert("Game Over! Score: " + score);
          resetGame();
          return true;
        }
        return false;
      }

      function checkWaveCleared() {
        if (enemies.every((e) => e.hp <= 0)) {
          // Verificar si todos los enemigos han completado su animación de muerte
          const allDeathAnimationsComplete = enemies.every(
            (e) => e.hp > 0 || e.deathAnimComplete
          );

          if (allDeathAnimationsComplete) {
            console.log("Wave cleared! Starting next wave...");

            // Bonificación por enemigos eliminados
            enemies.forEach((e) => {
              score += e.type === "boss" ? 10 : 1;
            });

            // Bonificación extra por wave completada
            const waveBonus = wave * 50; // 50 puntos por wave, escalando
            score += waveBonus;
            console.log(`Wave ${wave} completed! Bonus: ${waveBonus} points`);

            // Verificar si hemos completado un nivel (wave 3, 6, 9...)
            if (wave % 3 === 0) {
              const completedLevel = Math.floor(wave / 3);
              const levelData = levelInfo[completedLevel];

              if (completedLevel === 3) {
                // Juego completado
                levelCompletionModal = {
                  show: true,
                  level: completedLevel,
                  boss: levelData.boss,
                  timer: 180, // 3 segundos (60 FPS * 3)
                  gameCompleted: true,
                };
              } else {
                // Nivel completado, mostrar modal y luego pasar al siguiente nivel
                levelCompletionModal = {
                  show: true,
                  level: completedLevel,
                  boss: levelData.boss,
                  timer: 180, // 3 segundos (60 FPS * 3)
                  gameCompleted: false,
                };
              }
              state = "level_completion";
            } else {
              // Continuar con la siguiente wave del mismo nivel
              startWave();
            }
            return true;
          }
        }
        return false;
      }

      // NOTA: advanceTurn() removida - ya no se usa sistema de turnos

      // Función para cancelar automáticamente la selección de objetivo si el héroe muere
      function checkAndCancelDeadHeroAction() {
        if (selectedHero && selectedHero.hp <= 0) {
          // Si el héroe seleccionado está muerto y estamos en modo de selección de objetivo
          if (
            state === "select_target_enemy" ||
            state === "select_target_ally"
          ) {
            console.log(
              `${selectedHero.clazz} died during target selection. Canceling action: ${selectedAction}`
            );

            // Resetear todas las variables de selección
            selectedHero = null;
            selectedAction = null;
            state = "select_hero";

            console.log("Action canceled. Returning to hero selection.");
          }
        }
      }

      function executeAction(hero, action, targets) {
        const actionData = classActions[hero.clazz][action];

        // Check if we have enough charge before executing
        let requiredCharge = actionData.reqCharge;

        if (hero.charge < requiredCharge) {
          console.log(
            "Not enough charge for action:",
            action,
            "Required:",
            requiredCharge,
            "Current:",
            hero.charge
          );
          return false;
        }

        // Always reset charge to 0 when using any ability
        hero.charge = 0;

        hero.anim = actionData.anim;
        hero.frame = 0;
        hero.animTime = 0;
        // Limpiar targets anteriores antes de asignar nuevos
        hero.targets = [];
        hero.targets = Array.isArray(targets) ? targets : [targets];
        hero.action = action;
        state = "animate";

        console.log(
          "Executing action:",
          action,
          "for hero:",
          hero.clazz,
          "with targets:",
          hero.targets.length,
          "charge reset to 0"
        );
        return true;
      }

      function applyEffect(hero, action, targets) {
        // Validar que tenemos todos los datos necesarios
        if (
          !action ||
          !hero.clazz ||
          !classActions[hero.clazz] ||
          !classActions[hero.clazz][action]
        ) {
          console.error("ERROR: Datos inválidos para applyEffect", {
            hero: hero.clazz,
            action: action,
            hasClassActions: !!classActions[hero.clazz],
            hasAction: !!(
              classActions[hero.clazz] && classActions[hero.clazz][action]
            ),
          });
          return;
        }

        const actionData = classActions[hero.clazz][action];
        console.log(
          "Applying effect:",
          action,
          "from hero:",
          hero.clazz,
          "to targets:",
          targets.length,
          "action type:",
          actionData.type
        );

        // Validación adicional para prevenir contaminación de targets
        if (actionData.type.includes("enemy") && targets.some((t) => t.clazz)) {
          console.error(
            "ERROR: Acción de enemigo aplicada a héroes!",
            action,
            targets
          );
          return;
        }
        if (actionData.type.includes("ally") && targets.some((t) => !t.clazz)) {
          console.error(
            "ERROR: Acción de aliado aplicada a enemigos!",
            action,
            targets
          );
          return;
        }

        // Nuevas mecánicas específicas por habilidad
        if (action === "combustion") {
          // Combustion: buff de críticos para el próximo ataque
          hero.buffs.push({
            type: "combustion",
            critBonus: actionData.critBonus,
            usesRemaining: 1, // Solo para el próximo ataque
          });
          // Agregar icono de combustion debuff
          addDebuff(hero, "combustion", 1);
          console.log(
            "Combustion buff applied to",
            hero.clazz,
            "- next attack will have high critical chance"
          );
          // Agregar efecto visual de combustion en el propio mago
          addCombustionEffect(hero.posx, hero.posy);
        } else if (action === "agony") {
          // Agony: reducción de daño del 20% a todos los aliados
          targets.forEach((target) => {
            if (target.hp > 0) {
              target.buffs.push({
                type: "agony",
                endTime: currentTime + actionData.duration,
                damageReduction: actionData.damageReduction,
              });
              // Agregar icono de protection debuff
              addDebuff(target, "protection", 1);
              console.log("Agony buff applied to", target.clazz);
              addProtectionEffect([target]);
            }
          });
        } else if (action === "inmolation") {
          // Inmolation: daño a todos los enemigos + auto-daño al warlock
          targets.forEach((target) => {
            if (target.hp > 0) {
              let damage = actionData.damage;
              const criticalResult = calculateCritical(damage);
              const finalDamage = criticalResult.damage;
              const isCritical = criticalResult.isCritical;
              const effectiveDamage = Math.max(1, finalDamage - target.def);

              target.anim = "hurt";
              target.frame = 0;
              target.animStartTime = currentTime;
              target.hp = Math.max(0, target.hp - effectiveDamage);
              validateHP(target);

              // Sumar puntos por daño hecho a enemigos
              score += effectiveDamage;

              if (target.hp <= 0) {
                target.isDying = true;
                target.anim = "die";
                target.frame = 0;
                target.animStartTime = currentTime;
              }

              showHitNumber(
                target.posx,
                target.posy - 20,
                effectiveDamage,
                false,
                isCritical
              );
              clearEffectsByTypeAndPosition(
                "inmolation",
                target.posx,
                target.posy
              );
              addInmolationEffect(target.posx, target.posy);
            }
          });

          // Auto-daño al warlock (60% de su vida)
          const selfDamage = Math.floor(
            hero.maxhp * (actionData.selfDamage / 100)
          );
          hero.hp = Math.max(0, hero.hp - selfDamage); // Puede autodestruirse
          validateHP(hero);
          showHitNumber(hero.posx, hero.posy - 20, selfDamage, false, false);
          console.log("Inmolation self-damage:", selfDamage, "to", hero.clazz);
        } else if (action === "regrowth") {
          // Regrowth: curación por ticks a todos los aliados
          targets.forEach((target) => {
            if (target.hp > 0) {
              target.buffs.push({
                type: "regrowth",
                endTime: currentTime + actionData.ticks,
                nextTick: currentTime + 2, // Primer tick en 2 segundos
                heal: actionData.heal,
                tickInterval: 2, // Tick cada 2 segundos
              });
              // Agregar icono de healing debuff
              addDebuff(target, "healing", 1);
              playHealingAnim(target, "regrowth");
              console.log("Regrowth applied to", target.clazz);
            }
          });
        } else if (actionData.type.includes("enemy")) {
          // Habilidades de daño normales
          targets.forEach((target) => {
            if (target.hp > 0) {
              // Aplicar variación aleatoria al daño base
              let damage = calculateRandomValue(actionData.damage, 20); // ±20% de variación

              // Aplicar buff de combustion si existe
              let criticalChance = 15; // Base 15%
              const combustionBuff = hero.buffs.find(
                (b) => b.type === "combustion"
              );
              if (combustionBuff) {
                criticalChance += combustionBuff.critBonus;
                // Consumir el buff después de usarlo
                combustionBuff.usesRemaining--;
                if (combustionBuff.usesRemaining <= 0) {
                  // Marcar para eliminación
                  combustionBuff.toRemove = true;
                }
              }

              const criticalResult = calculateCritical(damage, criticalChance);
              const finalDamage = criticalResult.damage;
              const isCritical = criticalResult.isCritical;
              const effectiveDamage = Math.max(1, finalDamage - target.def);

              target.anim = "hurt";
              target.frame = 0;
              target.animStartTime = currentTime;
              target.hp = Math.max(0, target.hp - effectiveDamage);
              validateHP(target);

              // Sumar puntos por daño hecho a enemigos
              score += effectiveDamage;

              if (target.hp <= 0) {
                target.isDying = true;
                target.anim = "die";
                target.frame = 0;
                target.animStartTime = currentTime;
              }

              showHitNumber(
                target.posx,
                target.posy - 20,
                effectiveDamage,
                false,
                isCritical
              );

              // Efectos visuales específicos por habilidad
              if (action === "fireblast") {
                clearEffectsByTypeAndPosition(
                  "fireblast",
                  target.posx,
                  target.posy
                );
                addFireblastEffect(target.posx, target.posy);
              } else if (action === "inferno") {
                clearEffectsByTypeAndPosition(
                  "conflagration",
                  target.posx,
                  target.posy
                );
                addConflagrationEffect(target.posx, target.posy);
              } else if (action === "darkslash") {
                clearEffectsByTypeAndPosition(
                  "slash",
                  target.posx,
                  target.posy
                );
                addSlashEffect(target.posx, target.posy);
              } else if (action === "smite") {
                clearEffectsByTypeAndPosition(
                  "smite",
                  target.posx,
                  target.posy
                );
                addSmiteEffect(target.posx, target.posy);
              }
            }
          });
        } else if (
          actionData.type.includes("ally") ||
          actionData.type === "self"
        ) {
          // Habilidades de curación normales
          targets.forEach((target) => {
            // Verificar si el objetivo puede recibir curación
            const hasHealingDebuff =
              target.debuffs &&
              target.debuffs.some((d) => d.type === "healing");

            if (actionData.heal && !hasHealingDebuff) {
              // Verificar si el objetivo está vivo AL MOMENTO de aplicar el efecto
              // (esto permite que la curación falle si el objetivo muere durante la animación)
              if (target.hp > 0) {
                // Aplicar variación aleatoria a la curación
                const healAmount = calculateRandomValue(actionData.heal, 20); // ±20% de variación
                target.hp = Math.min(target.maxhp, target.hp + healAmount);
                validateHP(target);

                // Determinar tipo de curación para el efecto visual correcto
                const healType = action === "holywave" ? "holywave" : "healing";
                playHealingAnim(target, healType);

                showHitNumber(target.posx, target.posy - 20, healAmount, true);
                console.log(
                  "Healing",
                  healAmount,
                  "to",
                  target.clazz || "target"
                );
              } else if (target.hp <= 0) {
                // Revivir al héroe muerto con la cantidad de curación
                const healAmount = calculateRandomValue(actionData.heal, 20); // ±20% de variación
                target.hp = Math.min(target.maxhp, healAmount);
                validateHP(target);

                // Determinar tipo de curación para el efecto visual correcto
                const healType = action === "holywave" ? "holywave" : "healing";
                playHealingAnim(target, healType);

                showHitNumber(target.posx, target.posy - 20, healAmount, true);
                console.log(
                  "Reviving and healing",
                  healAmount,
                  "to",
                  target.clazz || "target"
                );
              }
            } else if (hasHealingDebuff) {
              console.log(
                `${target.clazz} cannot be healed due to healing debuff.`
              );
            }
          });
        }

        checkWaveCleared();
        checkGameOver();

        // Limpiar buffs de combustion consumidos
        hero.buffs = hero.buffs.filter((b) => {
          if (b.toRemove && b.type === "combustion") {
            // Remover también el debuff visual
            removeDebuff(hero, "combustion");
            console.log(
              "Combustion buff consumed and removed from",
              hero.clazz
            );
            return false;
          }
          return true;
        });

        // Resetear selección después de aplicar efectos
        selectedHero = null;
        selectedAction = null;
      }

      function playHealingAnim(target, healType = "healing") {
        // En lugar de cambiar la animación del héroe, crear un efecto visual separado
        console.log(
          "Creando efecto visual de curación para",
          target.clazz,
          "tipo:",
          healType
        );

        if (healType === "holywave") {
          addHolyWaveEffect(target.posx, target.posy);
        } else if (healType === "regrowth") {
          addRegrowthEffect(target.posx, target.posy);
        } else {
          addHealingEffect(target.posx, target.posy);
        }
      }

      function showHitNumber(
        x,
        y,
        value,
        isHealing = false,
        isCritical = false
      ) {
        hitNumbers.push({
          x: x,
          y: y,
          value: value,
          isHealing: isHealing,
          isCritical: isCritical,
          opacity: 1.0,
          startTime: currentTime,
          duration: 1.5, // duración en segundos
        });
      }

      function clearEffectsByTypeAndPosition(effectType, x, y) {
        // Eliminar solo los efectos del tipo especificado en la posición específica (mismo enemigo)
        const initialCount = visualEffects.length;
        for (let i = visualEffects.length - 1; i >= 0; i--) {
          const effect = visualEffects[i];
          if (
            effect.type === effectType &&
            Math.abs(effect.x - x) < 10 &&
            Math.abs(effect.y - y) < 10
          ) {
            visualEffects.splice(i, 1);
          }
        }
        const removedCount = initialCount - visualEffects.length;
        if (removedCount > 0) {
          console.log(
            `Eliminados ${removedCount} efectos de tipo ${effectType} en posición ${x},${y}`
          );
        }
      }

      function addFireblastEffect(x, y) {
        visualEffects.push({
          type: "fireblast",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.4, // Duración original
          frame: 0,
          frameCount: 4,
          frameWidth: 32,
          frameHeight: 32,
          size: 64, // Tamaño más grande
          repeat: 0, // Contador de repeticiones
          maxRepeats: 2, // Se repetirá 2 veces (total 3 reproducciones)
          endTime: currentTime + 0.4 * 3, // Tiempo absoluto de finalización (3 repeticiones)
        });
      }

      function addConflagrationEffect(x, y) {
        visualEffects.push({
          type: "conflagration",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.4, // Duración original
          frame: 0,
          frameCount: 4,
          frameWidth: 32,
          frameHeight: 32,
          size: 64, // Tamaño más grande
          repeat: 0, // Contador de repeticiones
          maxRepeats: 2, // Se repetirá 2 veces (total 3 reproducciones)
          endTime: currentTime + 0.4 * 3, // Tiempo absoluto de finalización (3 repeticiones)
        });
      }

      function addSlashEffect(x, y) {
        console.log("Añadiendo efecto slash en posición", x, y);
        visualEffects.push({
          type: "slash",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.4, // Duración original
          frame: 0,
          frameCount: 4, // Frames 17, 18, 19, 20
          frameWidth: 32,
          frameHeight: 32,
          size: 64, // Tamaño más grande
          repeat: 0, // Contador de repeticiones
          maxRepeats: 2, // Se repetirá 2 veces (total 3 reproducciones)
          endTime: currentTime + 0.4 * 3, // Tiempo absoluto de finalización (3 repeticiones)
        });
      }

      function addHealingEffect(x, y) {
        console.log("Añadiendo efecto visual de curación en posición", x, y);
        visualEffects.push({
          type: "healing",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.0, // Duración más larga para aprovechar todos los frames
          frame: 0,
          frameCount: 7, // 7 frames totales (5 en primera fila + 2 en segunda)
          frameWidth: 96, // Nuevo tamaño de frame
          frameHeight: 96, // Nuevo tamaño de frame
          size: 120, // Tamaño renderizado más grande para mejor visibilidad
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 1.0,
        });
      }

      function addHolyWaveEffect(x, y) {
        console.log("Añadiendo efecto visual de Holy Wave en posición", x, y);
        visualEffects.push({
          type: "holy_wave",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.8, // Duración reducida para animación más fluida (era 1.6)
          frame: 0,
          frameCount: 11, // 11 frames en total (3 filas: 5+5+1)
          frameWidth: 128, // 640px / 5 frames por fila
          frameHeight: 128, // 384px / 3 filas
          size: 130, // Tamaño más grande para mejor visibilidad
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 0.8,
        });
      }

      function addRegrowthEffect(x, y) {
        console.log("Añadiendo efecto visual de Regrowth en posición", x, y);
        visualEffects.push({
          type: "regrowth_new",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.9, // Duración reducida para animación más fluida (era 1.8)
          frame: 0,
          frameCount: 12, // 12 frames en total (3 filas: 5+5+2)
          frameWidth: 128, // 640px / 5 frames por fila
          frameHeight: 128, // 384px / 3 filas
          size: 125, // Tamaño apropiado para regeneración
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 0.9,
        });
      }

      function addCombustionEffect(x, y) {
        console.log("Añadiendo efecto visual de combustion en posición", x, y);
        visualEffects.push({
          type: "combustion",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.8, // Duración reducida para animación más rápida (era 1.3s)
          frame: 0,
          frameCount: 26, // 26 frames en total
          frameWidth: 96, // 96x96 cada frame
          frameHeight: 96,
          size: 120, // Tamaño apropiado para el nuevo sprite
          repeat: 0,
          maxRepeats: 0, // Solo una reproducción
          endTime: currentTime + 0.8, // Tiempo absoluto de finalización actualizado
        });
      }

      function addSmiteEffect(x, y) {
        console.log("Añadiendo efecto visual de smite en posición", x, y);
        visualEffects.push({
          type: "smite",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.75, // Duración reducida para animación más fluida (era 1.5)
          frame: 0,
          frameCount: 10, // 10 frames en total (2 filas de 5 cada una)
          frameWidth: 128, // 640px / 5 frames por fila (asumiendo 640px total)
          frameHeight: 128, // 256px / 2 filas (asumiendo 256px total)
          size: 120, // Tamaño más grande para mejor impacto visual
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 0.75,
        });
      }

      function addInmolationEffect(x, y) {
        console.log("Añadiendo efecto visual de inmolation en posición", x, y);
        visualEffects.push({
          type: "inmolation",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.1, // Duración para 11 frames
          frame: 0,
          frameCount: 11, // 11 frames de dark bolt
          frameWidth: 64,
          frameHeight: 88,
          size: 90, // Tamaño apropiado para el efecto de dark bolt
          repeat: 0,
          maxRepeats: 1, // Se repite una vez (total 2 reproducciones)
          endTime: currentTime + 1.1 * 2, // Tiempo absoluto de finalización
        });
      }

      function addBloodSplatEffect(x, y) {
        console.log("Añadiendo efecto visual de Blood Splat en posición", x, y);
        visualEffects.push({
          type: "blood_splat",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.5, // Duración aumentada para 10 frames
          frame: 0,
          frameCount: 10, // 10 frames en total (2 filas de 5 cada una)
          frameWidth: 128, // 640px / 5 frames por fila
          frameHeight: 128, // 256px / 2 filas
          size: 140, // Tamaño más grande para mejor impacto visual
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 1.5,
        });
      }

      function addBloodStormEffect(x, y) {
        console.log("Añadiendo efecto visual de Blood Storm en posición", x, y);
        visualEffects.push({
          type: "blood_storm",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.2, // Duración para 9 frames
          frame: 0,
          frameCount: 9, // 9 frames en total (2 filas: 5+4)
          frameWidth: 192, // 960px / 5 frames por fila
          frameHeight: 128, // 256px / 2 filas
          size: 150, // Tamaño más grande para AoE
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 1.2,
        });
      }

      function addMinotaurSmashEffect(x, y) {
        console.log(
          "Añadiendo efecto visual de Minotaur Smash en posición",
          x,
          y
        );
        visualEffects.push({
          type: "minotaur_smash",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.8, // Duración reducida para animación más fluida (era 1.6)
          frame: 0,
          frameCount: 8, // 8 frames en total (4 filas, 2 columnas)
          frameWidth: 128, // 256px / 2 columnas
          frameHeight: 160, // 640px / 4 filas
          size: 160, // Tamaño grande para impacto
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 0.8,
        });
      }

      function addMinotaurLifeStealEffect(x, y) {
        console.log(
          "Añadiendo efecto visual de Minotaur Life Steal en posición",
          x,
          y
        );
        visualEffects.push({
          type: "minotaur_life_steal",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.8, // Duración reducida para animación más fluida (era 1.6)
          frame: 0,
          frameCount: 8, // 8 frames en total (4 filas, 2 columnas)
          frameWidth: 128, // 256px / 2 columnas
          frameHeight: 128, // 512px / 4 filas
          size: 150, // Tamaño apropiado para AoE
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 0.8,
        });
      }

      function addLavaEffect(x, y) {
        visualEffects.push({
          type: "lava",
          x: x,
          y: y + 30, // Debajo del enemigo
          startTime: currentTime,
          duration: 0.5, // 1/2 segundo
          particles: [],
        });
      }

      function addProtectionEffect(heroes) {
        heroes.forEach((hero) => {
          if (hero.hp > 0) {
            visualEffects.push({
              type: "protection",
              x: hero.posx,
              y: hero.posy,
              startTime: currentTime,
              duration: 1.0, // 1 segundo
              radius: 0,
            });
          }
        });
      }

      function addPoisonEffect(x, y) {
        console.log("Añadiendo efecto visual de veneno en posición", x, y);
        visualEffects.push({
          type: "poison",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 2.0, // 2 segundos para mejor visibilidad
          radius: 0,
          particles: [],
        });
      }

      function addCosmicHorrorEffect(x, y) {
        console.log(
          "Añadiendo efecto visual de Cosmic Horror en posición",
          x,
          y
        );
        visualEffects.push({
          type: "cosmic_horror",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.5, // 1.5 segundos de duración
          radius: 0,
          particles: [],
          intensity: 1.0,
        });
      }

      function addTentacleStrikeEffect(x, y) {
        console.log(
          "Añadiendo efecto visual de Tentacle Strike en posición",
          x,
          y
        );
        visualEffects.push({
          type: "cthulu_main", // Usar nuevo efecto específico
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.0, // Duración reducida para animación más rápida (era 1.55s)
          frame: 0,
          frameCount: 31, // 31 frames en total
          frameWidth: 96, // 96x96 cada frame
          frameHeight: 96,
          size: 120, // Tamaño apropiado
        });
      }

      function addToxicHorrorEffect(x, y) {
        console.log(
          "Añadiendo efecto visual de Toxic Horror para todos los aliados"
        );
        // Crear efecto en cada héroe vivo
        heroes.forEach((hero) => {
          if (hero.hp > 0) {
            visualEffects.push({
              type: "cthulu_special", // Usar nuevo efecto específico
              x: hero.posx,
              y: hero.posy,
              startTime: currentTime,
              duration: 1.2, // Duración reducida para animación más rápida (era 2.0s)
              frame: 0,
              frameCount: 40, // 40 frames en total
              frameWidth: 96, // 96x96 cada frame
              frameHeight: 96,
              size: 120, // Tamaño apropiado
            });
          }
        });
      }

      function addMeteorEffect(x, y) {
        visualEffects.push({
          type: "meteor",
          x: x,
          y: y - 150, // Empezar desde arriba
          targetX: x,
          targetY: y,
          startTime: currentTime,
          duration: 0.8, // 0.8 segundos para caer
          trail: [], // Estela del meteorito
          impacted: false,
        });
      }

      function updateHitNumbers(dt) {
        for (let i = hitNumbers.length - 1; i >= 0; i--) {
          const hitNum = hitNumbers[i];
          const elapsed = currentTime - hitNum.startTime;

          // Mover hacia arriba
          hitNum.y -= 30 * dt;

          // Fade out
          hitNum.opacity = Math.max(0, 1 - elapsed / hitNum.duration);

          // Eliminar cuando termine la animación
          if (elapsed >= hitNum.duration) {
            hitNumbers.splice(i, 1);
          }
        }
      }

      function updateVisualEffects(dt) {
        for (let i = visualEffects.length - 1; i >= 0; i--) {
          const effect = visualEffects[i];
          const elapsed = currentTime - effect.startTime;

          if (effect.type === "fireblast") {
            // Actualizar frame del efecto de fireblast con repeticiones
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Si completó una animación, resetear para repetir
            if (effect.frame >= effect.frameCount) {
              if (effect.repeat < effect.maxRepeats) {
                effect.repeat++;
                effect.startTime = currentTime; // Reiniciar tiempo
                effect.frame = 0;
              }
            }
          } else if (effect.type === "conflagration") {
            // Actualizar frame del efecto de conflagration con repeticiones
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Si completó una animación, resetear para repetir
            if (effect.frame >= effect.frameCount) {
              if (effect.repeat < effect.maxRepeats) {
                effect.repeat++;
                effect.startTime = currentTime; // Reiniciar tiempo
                effect.frame = 0;
              }
            }
          } else if (effect.type === "slash") {
            // Actualizar frame del efecto de slash con repeticiones
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Si completó una animación, resetear para repetir
            if (effect.frame >= effect.frameCount) {
              if (effect.repeat < effect.maxRepeats) {
                effect.repeat++;
                effect.startTime = currentTime; // Reiniciar tiempo
                effect.frame = 0;
              }
            }
          } else if (effect.type === "healing") {
            // Actualizar frame del efecto de curación
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "holy_wave") {
            // Actualizar frame del efecto de Holy Wave
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "regrowth_new") {
            // Actualizar frame del efecto de Regrowth mejorado
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "combustion") {
            // Actualizar frame del efecto de combustion (nueva versión sin repeticiones)
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);
          } else if (effect.type === "cthulu_main") {
            // Actualizar frame del efecto principal de Cthulhu
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);
          } else if (effect.type === "cthulu_special") {
            // Actualizar frame del efecto especial de Cthulhu
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);
          } else if (effect.type === "smite") {
            // Actualizar frame del efecto de smite
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "inmolation") {
            // Actualizar frame del efecto de inmolation con repeticiones
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Si completó una animación, resetear para repetir
            if (effect.frame >= effect.frameCount) {
              if (effect.repeat < effect.maxRepeats) {
                effect.repeat++;
                effect.startTime = currentTime; // Reiniciar tiempo
                effect.frame = 0;
              }
            }
          } else if (effect.type === "blood_splat") {
            // Actualizar frame del efecto de Blood Splat
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "blood_storm") {
            // Actualizar frame del efecto de Blood Storm
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "minotaur_smash") {
            // Actualizar frame del efecto de Minotaur Smash
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "minotaur_life_steal") {
            // Actualizar frame del efecto de Minotaur Life Steal
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "lava") {
            // Generar más partículas de lava (más intenso)
            if (Math.random() < 0.6) {
              // Era 0.3, ahora es 0.6
              effect.particles.push({
                x: effect.x + (Math.random() - 0.5) * 80, // Área más grande
                y: effect.y,
                vy: -40 - Math.random() * 50, // Velocidad más alta
                life: 0.5 + Math.random() * 0.4, // Vida más larga
                maxLife: 0.5 + Math.random() * 0.4,
              });
            }

            // Actualizar partículas
            for (let j = effect.particles.length - 1; j >= 0; j--) {
              const particle = effect.particles[j];
              particle.y += particle.vy * dt;
              particle.life -= dt;
              if (particle.life <= 0) {
                effect.particles.splice(j, 1);
              }
            }
          } else if (effect.type === "protection") {
            // Expandir el escudo
            effect.radius = (elapsed / effect.duration) * 50;
          } else if (effect.type === "poison") {
            // Expandir el efecto de veneno y generar partículas tóxicas
            effect.radius = (elapsed / effect.duration) * 40;

            // Generar partículas de veneno
            if (Math.random() < 0.4) {
              effect.particles.push({
                x: effect.x + (Math.random() - 0.5) * 60,
                y: effect.y + (Math.random() - 0.5) * 60,
                vy: -20 - Math.random() * 30,
                life: 0.8 + Math.random() * 0.6,
                maxLife: 0.8 + Math.random() * 0.6,
              });
            }

            // Actualizar partículas de veneno
            for (let j = effect.particles.length - 1; j >= 0; j--) {
              const particle = effect.particles[j];
              particle.y += particle.vy * dt;
              particle.life -= dt;
              if (particle.life <= 0) {
                effect.particles.splice(j, 1);
              }
            }
          } else if (effect.type === "cosmic_horror") {
            // Efecto de Horror Cósmico - ondas expansivas y distorsión
            effect.radius = (elapsed / effect.duration) * 80;
            effect.intensity = 1 - elapsed / effect.duration;

            // Generar partículas de energía cósmica
            if (Math.random() < 0.6) {
              effect.particles.push({
                x: effect.x + (Math.random() - 0.5) * 100,
                y: effect.y + (Math.random() - 0.5) * 100,
                vy: -30 - Math.random() * 40,
                vx: (Math.random() - 0.5) * 60,
                life: 1.0 + Math.random() * 0.5,
                maxLife: 1.0 + Math.random() * 0.5,
              });
            }

            // Actualizar partículas cósmicas
            for (let j = effect.particles.length - 1; j >= 0; j--) {
              const particle = effect.particles[j];
              particle.x += particle.vx * dt;
              particle.y += particle.vy * dt;
              particle.life -= dt;
              if (particle.life <= 0) {
                effect.particles.splice(j, 1);
              }
            }
          } else if (effect.type === "tentacle_strike") {
            // Efecto de Golpe de Tentáculo - tentáculos serpenteantes
            effect.radius = (elapsed / effect.duration) * 60;

            // Generar partículas de tentáculos
            if (Math.random() < 0.5) {
              effect.particles.push({
                x: effect.x + (Math.random() - 0.5) * 80,
                y: effect.y + (Math.random() - 0.5) * 80,
                vy: -25 - Math.random() * 35,
                vx: (Math.random() - 0.5) * 50,
                life: 0.8 + Math.random() * 0.4,
                maxLife: 0.8 + Math.random() * 0.4,
              });
            }

            // Actualizar partículas de tentáculos
            for (let j = effect.particles.length - 1; j >= 0; j--) {
              const particle = effect.particles[j];
              particle.x += particle.vx * dt;
              particle.y += particle.vy * dt;
              particle.life -= dt;
              if (particle.life <= 0) {
                effect.particles.splice(j, 1);
              }
            }
          } else if (effect.type === "meteor") {
            // Animación del meteorito cayendo
            const progress = Math.min(elapsed / effect.duration, 1);
            const easeProgress = 1 - Math.pow(1 - progress, 3); // Easing para aceleración

            effect.x = effect.targetX;
            effect.y = effect.targetY - 150 + 150 * easeProgress;

            // Agregar punto a la estela
            effect.trail.push({ x: effect.x, y: effect.y, life: 0.3 });

            // Actualizar estela
            for (let j = effect.trail.length - 1; j >= 0; j--) {
              effect.trail[j].life -= dt;
              if (effect.trail[j].life <= 0) {
                effect.trail.splice(j, 1);
              }
            }

            // Impacto al llegar al suelo
            if (progress >= 1 && !effect.impacted) {
              effect.impacted = true;
              // Crear efecto de explosión
              for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                effect.trail.push({
                  x: effect.targetX + Math.cos(angle) * 20,
                  y: effect.targetY + Math.sin(angle) * 20,
                  life: 0.5,
                });
              }
            }
          }

          // Eliminar efecto cuando termine (considerando repeticiones)
          if (
            effect.type === "fireblast" ||
            effect.type === "conflagration" ||
            effect.type === "slash" ||
            effect.type === "combustion" ||
            effect.type === "inmolation" ||
            effect.type === "blood_splat" ||
            effect.type === "blood_storm" ||
            effect.type === "minotaur_smash" ||
            effect.type === "minotaur_life_steal"
          ) {
            // Para efectos con repeticiones, eliminar cuando se haya superado el tiempo absoluto de finalización
            if (currentTime >= effect.endTime) {
              visualEffects.splice(i, 1);
            }
          } else if (elapsed >= effect.duration) {
            // Para otros efectos (healing, holy_wave, regrowth_new, smite, lava, protection, meteor), eliminar normalmente
            visualEffects.splice(i, 1);
          }
        }
      }

      function renderHitNumbers() {
        ctx.save();
        ctx.textAlign = "center";

        hitNumbers.forEach((hitNum) => {
          ctx.globalAlpha = hitNum.opacity;

          // Configurar estilo según el tipo de hit
          if (hitNum.isCritical) {
            ctx.font = "bold 22px monospace"; // Reducido de 28px a 22px
            ctx.fillStyle = "#FFD700"; // Amarillo dorado para críticos
            ctx.lineWidth = 4;
          } else if (hitNum.isHealing) {
            ctx.font = "bold 20px monospace";
            ctx.fillStyle = "#00ff00"; // Verde para curación
            ctx.lineWidth = 3;
          } else {
            ctx.font = "bold 20px monospace";
            ctx.fillStyle = "#ff0000"; // Rojo para daño normal
            ctx.lineWidth = 3;
          }

          // Sombra para mejor visibilidad
          ctx.strokeStyle = "#000000";

          let text;
          if (hitNum.isCritical) {
            text = `CRIT! -${hitNum.value}`;
          } else if (hitNum.isHealing) {
            text = `+${hitNum.value}`;
          } else {
            text = `-${hitNum.value}`;
          }

          ctx.strokeText(text, hitNum.x, hitNum.y);
          ctx.fillText(text, hitNum.x, hitNum.y);
        });

        ctx.restore();
      }

      function renderVisualEffects() {
        ctx.save();

        visualEffects.forEach((effect) => {
          const elapsed = currentTime - effect.startTime;
          const progress = elapsed / effect.duration;

          if (effect.type === "fireblast") {
            // Renderizar efecto de fireblast usando sprites - más grande
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = (7 + effect.frame) * effect.frameWidth; // Frames 8,9,10,11 (posiciones 7,8,9,10)
              const sy = 15 * effect.frameHeight; // Fila 15 (empezando desde 0)

              const renderSize = effect.size || 64;
              ctx.drawImage(
                effectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "conflagration") {
            // Renderizar efecto de conflagration usando sprites - más grande
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = (6 + effect.frame) * effect.frameWidth; // Frames 6,7,8,9 (posiciones 6,7,8,9)
              const sy = 0 * effect.frameHeight; // Fila 0 (empezando desde 0)

              const renderSize = effect.size || 64;
              ctx.drawImage(
                effectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "slash") {
            // Renderizar efecto de slash usando sprites púrpura - más grande
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = (17 + effect.frame) * effect.frameWidth; // Frames 17,18,19,20 (posiciones 17,18,19,20)
              const sy = 11 * effect.frameHeight; // Fila 11 (empezando desde 0)

              const renderSize = effect.size || 64;
              ctx.drawImage(
                purpleEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "healing") {
            // Renderizar efecto de curación usando el nuevo sprite específico
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame: 5 frames en primera fila, 2 en segunda
              let sx, sy;
              if (effect.frame < 5) {
                // Primera fila (frames 0-4)
                sx = effect.frame * effect.frameWidth;
                sy = 0;
              } else {
                // Segunda fila (frames 5-6)
                sx = (effect.frame - 5) * effect.frameWidth;
                sy = effect.frameHeight;
              }

              const renderSize = effect.size || 120; // Tamaño por defecto más grande
              ctx.drawImage(
                healingEffectsImg, // Usar el nuevo sprite de curación
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "combustion") {
            // Renderizar efecto de combustion usando el nuevo sprite mejorado
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = effect.frame * effect.frameWidth; // 26 frames en una sola fila
              const sy = 0; // Solo una fila

              const renderSize = effect.size || 120;
              ctx.drawImage(
                combustionEffectsImg, // Usar la nueva imagen
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "smite") {
            // Renderizar efecto de smite usando el nuevo sprite mejorado
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame: 5 frames en primera fila, 5 en segunda
              let sx, sy;
              if (effect.frame < 5) {
                // Primera fila (frames 0-4)
                sx = effect.frame * effect.frameWidth;
                sy = 0;
              } else {
                // Segunda fila (frames 5-9)
                sx = (effect.frame - 5) * effect.frameWidth;
                sy = effect.frameHeight;
              }

              const renderSize = effect.size || 120;
              ctx.drawImage(
                priestSmiteEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "holy_wave") {
            // Renderizar efecto de Holy Wave
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame: 5 frames en primera fila, 5 en segunda, 1 en tercera
              let sx, sy;
              if (effect.frame < 5) {
                // Primera fila (frames 0-4)
                sx = effect.frame * effect.frameWidth;
                sy = 0;
              } else if (effect.frame < 10) {
                // Segunda fila (frames 5-9)
                sx = (effect.frame - 5) * effect.frameWidth;
                sy = effect.frameHeight;
              } else {
                // Tercera fila (frame 10)
                sx = (effect.frame - 10) * effect.frameWidth;
                sy = effect.frameHeight * 2;
              }

              const renderSize = effect.size || 130;
              ctx.drawImage(
                priestHolyWaveEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "regrowth_new") {
            // Renderizar efecto de Regrowth mejorado
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame: 5 frames en primera fila, 5 en segunda, 2 en tercera
              let sx, sy;
              if (effect.frame < 5) {
                // Primera fila (frames 0-4)
                sx = effect.frame * effect.frameWidth;
                sy = 0;
              } else if (effect.frame < 10) {
                // Segunda fila (frames 5-9)
                sx = (effect.frame - 5) * effect.frameWidth;
                sy = effect.frameHeight;
              } else {
                // Tercera fila (frames 10-11)
                sx = (effect.frame - 10) * effect.frameWidth;
                sy = effect.frameHeight * 2;
              }

              const renderSize = effect.size || 125;
              ctx.drawImage(
                priestRegrowthEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "inmolation") {
            // Renderizar efecto de inmolation usando sprite de dark bolt
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = effect.frame * effect.frameWidth; // Frames 0-10
              const sy = 0; // Solo una fila

              const renderSize = effect.size || 90;
              ctx.drawImage(
                darkBoltEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "lava") {
            // Renderizar partículas de lava
            effect.particles.forEach((particle) => {
              const alpha = particle.life / particle.maxLife;
              ctx.globalAlpha = alpha;

              // Gradiente de colores más intenso: rojo-naranja-amarillo-blanco
              const colors = [
                "#ff0000",
                "#ff2200",
                "#ff4500",
                "#ff6600",
                "#ffa500",
                "#ffcc00",
                "#ffff00",
                "#ffffff",
              ];
              const colorIndex = Math.floor((1 - alpha) * (colors.length - 1));
              ctx.fillStyle = colors[colorIndex];

              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 4, 0, Math.PI * 2); // Partículas más grandes
              ctx.fill();

              // Brillo adicional
              ctx.globalAlpha = alpha * 0.5;
              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 6, 0, Math.PI * 2);
              ctx.fill();
            });

            // Base de lava burbujeante más intensa
            ctx.globalAlpha = 1 - progress;
            ctx.fillStyle = "#ff2200";
            for (let i = 0; i < 8; i++) {
              // Más burbujas
              const bubbleX = effect.x + (Math.random() - 0.5) * 70; // Área más grande
              const bubbleY = effect.y + Math.random() * 15;
              const bubbleSize = 3 + Math.random() * 6; // Burbujas más grandes
              ctx.beginPath();
              ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
              ctx.fill();
            }

            // Resplandor de base
            ctx.globalAlpha = (1 - progress) * 0.3;
            ctx.fillStyle = "#ff4500";
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, 30, 0, Math.PI * 2);
            ctx.fill();
          } else if (effect.type === "protection") {
            // Renderizar escudo de protección
            ctx.globalAlpha = Math.max(0, 1 - progress);
            ctx.strokeStyle = "#8A2BE2"; // Púrpura neón
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.stroke();

            // Brillo interior
            ctx.globalAlpha = Math.max(0, (1 - progress) * 0.3);
            ctx.fillStyle = "#9370DB"; // Púrpura más claro para el interior
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.fill();
          } else if (effect.type === "poison") {
            // Renderizar partículas de veneno
            effect.particles.forEach((particle) => {
              const alpha = particle.life / particle.maxLife;
              ctx.globalAlpha = alpha;

              // Colores tóxicos: verde ácido
              const colors = ["#00ff00", "#32cd32", "#adff2f", "#7fff00"];
              const colorIndex = Math.floor((1 - alpha) * (colors.length - 1));
              ctx.fillStyle = colors[colorIndex];

              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
              ctx.fill();

              // Brillo tóxico
              ctx.globalAlpha = alpha * 0.6;
              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 5, 0, Math.PI * 2);
              ctx.fill();
            });

            // Base de veneno burbujeante
            ctx.globalAlpha = Math.max(0, 1 - progress);
            ctx.strokeStyle = "#00ff00"; // Verde tóxico
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.stroke();

            // Resplandor interior venenoso
            ctx.globalAlpha = Math.max(0, (1 - progress) * 0.4);
            ctx.fillStyle = "#32cd32"; // Verde lima para el interior
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.fill();
          } else if (effect.type === "cosmic_horror") {
            // Renderizar efecto de Horror Cósmico
            const progress = (currentTime - effect.startTime) / effect.duration;

            // Renderizar partículas de energía cósmica
            effect.particles.forEach((particle) => {
              const alpha = particle.life / particle.maxLife;
              ctx.globalAlpha = alpha;

              // Colores cósmicos: púrpura oscuro y azul profundo
              const colors = ["#4B0082", "#8A2BE2", "#9400D3", "#6A0DAD"];
              const colorIndex = Math.floor((1 - alpha) * (colors.length - 1));
              ctx.fillStyle = colors[colorIndex];

              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 4, 0, Math.PI * 2);
              ctx.fill();

              // Resplandor cósmico
              ctx.globalAlpha = alpha * 0.5;
              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 7, 0, Math.PI * 2);
              ctx.fill();
            });

            // Ondas expansivas de horror cósmico
            ctx.globalAlpha = effect.intensity * 0.6;
            ctx.strokeStyle = "#4B0082"; // Púrpura profundo
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.stroke();

            // Distorsión central
            ctx.globalAlpha = effect.intensity * 0.3;
            ctx.fillStyle = "#9400D3"; // Violeta oscuro
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius * 0.5, 0, Math.PI * 2);
            ctx.fill();
          } else if (effect.type === "tentacle_strike") {
            // Renderizar efecto de Golpe de Tentáculo
            const progress = (currentTime - effect.startTime) / effect.duration;

            // Renderizar partículas de tentáculos
            effect.particles.forEach((particle) => {
              const alpha = particle.life / particle.maxLife;
              ctx.globalAlpha = alpha;

              // Colores de tentáculos: verde oscuro y marrón
              const colors = ["#2F4F2F", "#556B2F", "#6B8E23", "#8FBC8F"];
              const colorIndex = Math.floor((1 - alpha) * (colors.length - 1));
              ctx.fillStyle = colors[colorIndex];

              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
              ctx.fill();

              // Brillo de tentáculo
              ctx.globalAlpha = alpha * 0.4;
              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 6, 0, Math.PI * 2);
              ctx.fill();
            });

            // Base de tentáculos serpenteantes
            ctx.globalAlpha = Math.max(0, 1 - progress);
            ctx.strokeStyle = "#2F4F2F"; // Verde oscuro
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.stroke();

            // Centro de impacto
            ctx.globalAlpha = Math.max(0, (1 - progress) * 0.5);
            ctx.fillStyle = "#556B2F"; // Verde oliva
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius * 0.6, 0, Math.PI * 2);
            ctx.fill();
          } else if (effect.type === "meteor") {
            // Renderizar estela del meteorito
            effect.trail.forEach((point, index) => {
              const alpha = point.life / 0.5;
              ctx.globalAlpha = alpha;
              const size = 2 + alpha * 3;

              // Colores de fuego para la estela
              const colors = ["#ff0000", "#ff4500", "#ffa500", "#ffff00"];
              const colorIndex = Math.floor((1 - alpha) * (colors.length - 1));
              ctx.fillStyle = colors[colorIndex];

              ctx.beginPath();
              ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
              ctx.fill();
            });

            // Renderizar el meteorito en sí
            if (!effect.impacted) {
              ctx.globalAlpha = 1;

              // Núcleo del meteorito
              ctx.fillStyle = "#ffaa00";
              ctx.beginPath();
              ctx.arc(effect.x, effect.y, 8, 0, Math.PI * 2);
              ctx.fill();

              // Brillo exterior
              ctx.fillStyle = "#ff4500";
              ctx.beginPath();
              ctx.arc(effect.x, effect.y, 12, 0, Math.PI * 2);
              ctx.fill();

              // Resplandor
              ctx.globalAlpha = 0.6;
              ctx.fillStyle = "#ff0000";
              ctx.beginPath();
              ctx.arc(effect.x, effect.y, 16, 0, Math.PI * 2);
              ctx.fill();
            }
          } else if (effect.type === "blood_splat") {
            // Renderizar efecto de blood splat usando el nuevo sprite sheet (10 frames en 2 filas)
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame: 5 frames en primera fila, 5 en segunda
              let sx, sy;
              if (effect.frame < 5) {
                // Primera fila (frames 0-4)
                sx = effect.frame * effect.frameWidth;
                sy = 0;
              } else {
                // Segunda fila (frames 5-9)
                sx = (effect.frame - 5) * effect.frameWidth;
                sy = effect.frameHeight;
              }

              const renderSize = effect.size || 140;
              ctx.drawImage(
                bloodSplatEffectsImg, // Usar el nuevo sprite sheet
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "blood_storm") {
            // Renderizar efecto de blood storm (AoE a todos los aliados)
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame: 5 frames en primera fila, 4 en segunda
              let sx, sy;
              if (effect.frame < 5) {
                // Primera fila (frames 0-4)
                sx = effect.frame * effect.frameWidth;
                sy = 0;
              } else {
                // Segunda fila (frames 5-8)
                sx = (effect.frame - 5) * effect.frameWidth;
                sy = effect.frameHeight;
              }

              const renderSize = effect.size || 150;
              ctx.drawImage(
                bloodStormEffectsImg, // Usar el sprite original para AoE
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "minotaur_smash") {
            // Renderizar efecto de Minotaur Smash
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame en grid 4x2 (4 filas, 2 columnas)
              const col = effect.frame % 2; // Columna (0 o 1)
              const row = Math.floor(effect.frame / 2); // Fila (0-3)
              const sx = col * effect.frameWidth;
              const sy = row * effect.frameHeight;

              const renderSize = effect.size || 160;
              ctx.drawImage(
                minotaurSmashEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "minotaur_life_steal") {
            // Renderizar efecto de Minotaur Life Steal
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame en grid 4x2 (4 filas, 2 columnas)
              const col = effect.frame % 2; // Columna (0 o 1)
              const row = Math.floor(effect.frame / 2); // Fila (0-3)
              const sx = col * effect.frameWidth;
              const sy = row * effect.frameHeight;

              const renderSize = effect.size || 150;
              ctx.drawImage(
                minotaurLifeStealEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "cthulu_main") {
            // Renderizar efecto principal de Cthulhu (Tentacle Strike)
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = effect.frame * effect.frameWidth; // 31 frames en una sola fila
              const sy = 0; // Solo una fila

              const renderSize = effect.size || 120;
              ctx.drawImage(
                cthuluMainEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "cthulu_special") {
            // Renderizar efecto especial de Cthulhu (Toxic Horror)
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = effect.frame * effect.frameWidth; // 40 frames en una sola fila
              const sy = 0; // Solo una fila

              const renderSize = effect.size || 120;
              ctx.drawImage(
                cthuluSpecialEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          }
        });

        ctx.restore();
      }

      function getDistance(a, b) {
        const dx = a.posx - b.posx;
        const dy = a.posy - b.posy;
        return Math.sqrt(dx * dx + dy * dy);
      }

      function getClosestHero(enemy, heroes) {
        const aliveHeroes = heroes.filter((h) => h.hp > 0);
        if (aliveHeroes.length === 0) return null;

        let closest = aliveHeroes[0];
        let minDistance = getDistance(enemy, closest);

        for (let i = 1; i < aliveHeroes.length; i++) {
          const distance = getDistance(enemy, aliveHeroes[i]);
          if (distance < minDistance) {
            minDistance = distance;
            closest = aliveHeroes[i];
          }
        }

        return closest;
      }

      function getRandomHero(heroes) {
        const aliveHeroes = heroes.filter((h) => h.hp > 0);
        if (aliveHeroes.length === 0) return null;

        const randomIndex = Math.floor(Math.random() * aliveHeroes.length);
        return aliveHeroes[randomIndex];
      }

      // Funciones para manejo de debuffs/buffs
      function addDebuff(target, type, stacks = 1) {
        // Buscar si ya existe este debuff
        const existingDebuff = target.debuffs.find((d) => d.type === type);

        if (existingDebuff) {
          // Si ya existe, aumentar stacks (máximo según el tipo)
          switch (type) {
            case "berseker":
              existingDebuff.stacks = Math.min(
                existingDebuff.stacks + stacks,
                10
              ); // Máximo 10 stacks (30%)
              break;
            case "poison":
              existingDebuff.stacks += stacks; // Poison es stackeable sin límite
              break;
            default:
              existingDebuff.stacks = stacks; // Para otros debuffs, reemplazar stacks
              break;
          }
        } else {
          // Si no existe, crear nuevo debuff
          const debuffData = {
            type: type,
            stacks: stacks,
            icon: getDebuffIcon(type), // Usar icon en lugar de iconInfo
          };
          target.debuffs.push(debuffData);
        }
      }

      function removeDebuff(target, type) {
        target.debuffs = target.debuffs.filter((d) => d.type !== type);
      }

      // Función para limpiar todos los debuffs y buffs cuando un héroe muere
      function clearAllEffectsOnDeath(hero) {
        if (hero.hp <= 0) {
          console.log(`${hero.clazz} died. Clearing all debuffs and buffs.`);

          // Limpiar todos los debuffs
          hero.debuffs = [];

          // Limpiar todos los buffs
          hero.buffs = [];

          console.log(`All effects cleared for ${hero.clazz}.`);
        }
      }

      function getDebuffIcon(type) {
        switch (type) {
          case "healing":
            return healingDebuffImg;
          case "protection":
            return protectionDebuffImg;
          case "combustion":
            return combustionDebuffImg;
          case "berseker":
            return bersekerDebuffImg;
          case "poison":
            return poisonDebuffImg;
          default:
            return null;
        }
      }

      function renderDebuffs(target, baseX, baseY) {
        if (!target.debuffs || target.debuffs.length === 0) return;

        const iconSize = 17; // Aumentado de 16 a 17px para mejor visibilidad
        const startX = baseX - 40; // Empezar desde la izquierda

        target.debuffs.forEach((debuff, index) => {
          const x = startX + index * (iconSize + 2); // Espaciado de 2px entre iconos
          const y = baseY;

          // Renderizar icono del debuff directamente
          if (debuff.icon) {
            ctx.drawImage(debuff.icon, x, y, iconSize, iconSize);

            // Si tiene stacks > 1, mostrar número pequeño
            if (debuff.stacks > 1) {
              ctx.save();
              ctx.fillStyle = "white";
              ctx.strokeStyle = "black";
              ctx.lineWidth = 1;
              ctx.font = "8px Arial";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";

              const text = debuff.stacks.toString();
              const textX = x + iconSize - 4;
              const textY = y + iconSize - 4;

              ctx.strokeText(text, textX, textY);
              ctx.fillText(text, textX, textY);
              ctx.restore();
            }
          }
        });
      }

      // NOTA: enemyAct() removida - ahora se usa sistema de auto-attack en el loop principal

      let lastTime = 0;
      function loop(time) {
        const delta = (time - lastTime) / 1000;
        lastTime = time;
        currentTime += delta;

        // Solo ejecutar lógica del juego si no estamos en el menú principal o pantallas informativas
        if (state !== "main_menu" && state !== "level_info") {
          // No hay timer automático para el modal - se controla por botón
          if (state === "level_completion" && levelCompletionModal.show) {
            // No ejecutar el resto de la lógica durante el modal
            draw();
            requestAnimationFrame(loop);
            return;
          }
          // Update hit numbers
          updateHitNumbers(delta);

          // Update visual effects
          updateVisualEffects(delta);

          // Check wave cleared continuously
          checkWaveCleared();

          // Update buffs
          heroes.forEach((h) => {
            h.buffs = h.buffs.filter((b) => {
              // Buffs de combustión no se eliminan por tiempo, solo por uso
              if (b.type === "combustion") {
                return true; // Mantener hasta que se consuma
              }

              if (b.endTime <= currentTime) {
                // Remover debuff correspondiente cuando termine el buff
                if (b.type === "regrowth") {
                  removeDebuff(h, "healing");
                } else if (b.type === "agony") {
                  removeDebuff(h, "protection");
                }
                return false;
              }

              if (b.type === "rejuvenation" && b.nextTick <= currentTime) {
                // Verificar si el héroe puede recibir curación
                const hasHealingDebuff =
                  h.debuffs && h.debuffs.some((d) => d.type === "healing");

                if (!hasHealingDebuff && h.hp > 0) {
                  h.hp = Math.min(h.maxhp, h.hp + b.heal);
                  validateHP(h);
                  console.log(
                    "Rejuvenation tick para",
                    h.clazz,
                    "- creando efecto visual de curación"
                  );
                  playHealingAnim(h);
                  showHitNumber(h.posx, h.posy - 20, b.heal, true);
                } else if (hasHealingDebuff) {
                  console.log(
                    `${h.clazz} rejuvenation blocked by healing debuff.`
                  );
                }
                b.nextTick += 1;
              } else if (b.type === "regrowth" && b.nextTick <= currentTime) {
                // Verificar si el héroe puede recibir curación
                const hasHealingDebuff =
                  h.debuffs && h.debuffs.some((d) => d.type === "healing");

                if (!hasHealingDebuff && h.hp > 0) {
                  // Calcular curación aleatoria en el rango 7-9
                  const healAmount = 7 + Math.floor(Math.random() * 3); // 7, 8, o 9
                  h.hp = Math.min(h.maxhp, h.hp + healAmount);
                  validateHP(h);
                  console.log(
                    "Regrowth tick para",
                    h.clazz,
                    "- curación de",
                    healAmount
                  );
                  playHealingAnim(h);
                  showHitNumber(h.posx, h.posy - 20, healAmount, true);
                } else if (hasHealingDebuff) {
                  console.log(`${h.clazz} regrowth blocked by healing debuff.`);
                }
                b.nextTick += b.tickInterval || 2; // Usar tickInterval o 2 segundos por defecto
              } else if (b.type === "poison" && b.nextTick <= currentTime) {
                // Aplicar daño de veneno
                h.hp = Math.max(0, h.hp - b.damage);
                console.log(
                  "Poison tick para",
                  h.clazz,
                  "- daño de veneno:",
                  b.damage
                );
                showHitNumber(h.posx, h.posy - 20, b.damage, false, false);
                // addPoisonEffect(h.posx, h.posy); // Efecto visual cada tick - DESACTIVADO
                b.nextTick += b.tickInterval; // Próximo tick en 3 segundos

                // Verificar si el héroe murió por veneno
                if (h.hp <= 0) {
                  console.log(h.clazz, "died from poison!");
                }
              }
              return true;
            });
          });

          // Update animations
          heroes.forEach((h) => {
            if (h.hp <= 0) return;
            const animData = h.animations[h.anim];
            h.animTime += delta;
            const frameDuration = animData.duration / animData.frames;
            if (h.animTime >= frameDuration) {
              h.animTime -= frameDuration;
              h.frame = (h.frame + 1) % animData.frames;
              if (h.frame === 0 && h.anim !== "idle" && h.anim !== "selected") {
                if (state === "animate") {
                  console.log(
                    "Animation completed! Applying effect for hero:",
                    h.clazz,
                    "action:",
                    h.action,
                    "targets:",
                    h.targets ? h.targets.length : 0,
                    "target types:",
                    h.targets
                      ? h.targets.map((t) => t.clazz || "enemy").join(",")
                      : "none"
                  );

                  // Verificar que tenemos una acción válida antes de aplicar efectos
                  if (h.action && h.targets && h.targets.length > 0) {
                    applyEffect(h, h.action, h.targets);

                    // Limpiar propiedades de acción SOLO para este héroe después de aplicar el efecto
                    console.log(
                      "Limpiando propiedades de acción para",
                      h.clazz
                    );
                    h.targets = [];
                    h.action = null;

                    state = "select_hero"; // Volver inmediatamente a selección sin avanzar turno
                  } else {
                    console.warn(
                      "Hero",
                      h.clazz,
                      "has no valid action or targets to apply. Action:",
                      h.action,
                      "Targets length:",
                      h.targets ? h.targets.length : 0
                    );
                  }
                }
                // Solo cambiar a idle si no hay habilidades pendientes
                if (state !== "animate") {
                  h.anim = "idle";
                }
              }
            }
          });

          // Update enemy charge and check for automatic attacks
          enemies.forEach((e) => {
            if (e.hp > 0 && !e.isDying) {
              // Use the new charge speed rating system, fallback to legacy chargeSpeed for compatibility
              const chargeSpeed = e.chargeSpeedRating
                ? getChargeSpeedFromRating(e.chargeSpeedRating)
                : e.chargeSpeed || 20;
              e.charge = Math.min(e.maxcharge, e.charge + delta * chargeSpeed);

              // Auto attack when fully charged
              if (e.charge >= 100 && e.animTime <= 0) {
                // Lógica especial para Crab Bomb
                if (e.name === "Crab Bomb") {
                  e.charge = 0; // Reset charge

                  // Incrementar esferas de carga
                  e.sphereCharges = (e.sphereCharges || 0) + 1;
                  console.log(
                    `Crab Bomb sphere charge: ${e.sphereCharges}/${e.maxSphereCharges}`
                  );

                  // Si llegó a 5 esferas, explotar
                  if (e.sphereCharges >= e.maxSphereCharges) {
                    console.log("Crab Bomb explodes!");

                    // Cambiar a animación de explosión
                    e.anim = "explode";
                    e.frame = 0;
                    e.animStartTime = currentTime;

                    // Marcar que debe aplicar daño al final de la animación
                    e.explosionDamagePending = true;

                    // No aplicar daño inmediatamente, se aplicará cuando termine la animación
                  }
                  return; // Salir de la función para evitar el ataque normal
                }

                // Determinar el nivel actual para decidir el targeting
                const currentLevel = Math.floor(wave / 3) + 1;

                // En Red Dunes (nivel 2) los enemigos atacan a un aliado aleatorio
                // En otros niveles atacan al más cercano
                const target =
                  currentLevel === 2
                    ? getRandomHero(heroes)
                    : getClosestHero(e, heroes);

                if (target) {
                  let damage = e.type === "boss" ? 45 : 25; // Boss hace 45 de daño base, enemigos normales 25
                  e.charge = 0; // Reset charge
                  e.animTime = 0.5;
                  e.anim = "attack"; // Activar animación de ataque
                  e.frame = 0; // Reiniciar frame
                  e.animStartTime = currentTime; // Tiempo de inicio de la animación

                  // Manejo de ataques de Boss (Boss Bat y Minotaur)
                  let isSpecialAttack = false;
                  let isMainAbility = false;
                  if (e.type === "boss" && e.attacksUntilSpecial !== null) {
                    e.attacksUntilSpecial--;
                    if (e.attacksUntilSpecial <= 0) {
                      isSpecialAttack = true;
                      e.isSpecialAttack = true; // Marcar el enemigo para renderizado
                      e.attacksUntilSpecial = e.specialAttackCounter; // Reset counter

                      // Ajustar daño según el tipo de boss
                      if (e.name === "Boss Bat") {
                        damage = 30 + Math.floor(Math.random() * 11); // Daño entre 30-40 para Blood Storm (AoE)
                      } else if (e.name === "Minotaur") {
                        damage = 30 + Math.floor(Math.random() * 16); // Daño entre 30-45 para Life Steal (AoE)
                      } else if (e.name === "Gorgon") {
                        damage = 80; // Ataque especial de Swamp Gorgon hace 80 de daño fijo
                      }
                    } else {
                      // Ataques principales/normales
                      isMainAbility = true;
                      if (e.name === "Boss Bat") {
                        damage = 20 + Math.floor(Math.random() * 11); // Daño entre 20-30 para Blood Splat (single target)
                      } else if (e.name === "Minotaur") {
                        damage = 40 + Math.floor(Math.random() * 21); // Daño entre 40-60 para Smash (single target)
                      } else if (e.name === "Gorgon") {
                        damage = 35 + Math.floor(Math.random() * 16); // Daño entre 35-50 para ataque básico con veneno
                      }
                    }
                  }

                  setTimeout(() => {
                    if (isSpecialAttack) {
                      if (e.name === "Boss Bat") {
                        // Ataque especial: Blood Storm (daño AoE a todos los héroes)
                        console.log(
                          "Boss Bat uses Blood Storm special attack (AoE)!"
                        );
                        heroes.forEach((hero) => {
                          if (hero.hp > 0) {
                            const currentDef =
                              hero.def +
                              hero.buffs.reduce(
                                (sum, b) =>
                                  b.type === "protection"
                                    ? sum + b.defBonus
                                    : sum,
                                0
                              );

                            const criticalResult = calculateCritical(damage);
                            const finalDamage = criticalResult.damage;
                            let effectiveDamage = Math.max(
                              1,
                              finalDamage - currentDef
                            );

                            // Aplicar reducción de daño por Agony
                            const agonyBuff = hero.buffs.find(
                              (b) => b.type === "agony"
                            );
                            if (agonyBuff && agonyBuff.damageReduction) {
                              effectiveDamage = Math.floor(
                                effectiveDamage *
                                  (1 - agonyBuff.damageReduction / 100)
                              );
                              effectiveDamage = Math.max(1, effectiveDamage); // Mínimo 1 de daño
                            }

                            hero.hp = Math.max(0, hero.hp - effectiveDamage);
                            validateHP(hero);

                            console.log(
                              `${
                                hero.clazz || "Hero"
                              } takes ${effectiveDamage} AoE damage from Blood Storm!`
                            );

                            // Mostrar número de daño para cada héroe afectado
                            showHitNumber(
                              hero.posx,
                              hero.posy - 20,
                              effectiveDamage,
                              false,
                              criticalResult.isCritical
                            );

                            // Agregar efecto visual de Blood Storm para cada héroe
                            addBloodStormEffect(hero.posx, hero.posy);
                          }
                        });
                      } else if (e.name === "Minotaur") {
                        // Ataque especial: Life Steal (AoE que roba vida)
                        console.log("Minotaur uses Life Steal special attack!");
                        let totalDamageDealt = 0;

                        heroes.forEach((hero) => {
                          if (hero.hp > 0) {
                            const currentDef =
                              hero.def +
                              hero.buffs.reduce(
                                (sum, b) =>
                                  b.type === "protection"
                                    ? sum + b.defBonus
                                    : sum,
                                0
                              );

                            const criticalResult = calculateCritical(damage);
                            const finalDamage = criticalResult.damage;
                            let effectiveDamage = Math.max(
                              1,
                              finalDamage - currentDef
                            );

                            // Aplicar reducción de daño por Agony
                            const agonyBuff = hero.buffs.find(
                              (b) => b.type === "agony"
                            );
                            if (agonyBuff && agonyBuff.damageReduction) {
                              effectiveDamage = Math.floor(
                                effectiveDamage *
                                  (1 - agonyBuff.damageReduction / 100)
                              );
                              effectiveDamage = Math.max(1, effectiveDamage); // Mínimo 1 de daño
                            }

                            hero.hp = Math.max(0, hero.hp - effectiveDamage);
                            validateHP(hero);
                            totalDamageDealt += effectiveDamage;

                            console.log(
                              `${
                                hero.clazz || "Hero"
                              } takes ${effectiveDamage} AoE damage from Life Steal!`
                            );

                            // Mostrar número de daño para cada héroe afectado
                            showHitNumber(
                              hero.posx,
                              hero.posy - 20,
                              effectiveDamage,
                              false,
                              criticalResult.isCritical
                            );

                            // Agregar efecto visual de Life Steal para cada héroe
                            addMinotaurLifeStealEffect(hero.posx, hero.posy);
                          }
                        });

                        // El Minotaur roba 5% del daño total realizado
                        const lifeSteal = Math.floor(totalDamageDealt * 0.05);
                        if (lifeSteal > 0 && !isNaN(lifeSteal)) {
                          // Validar que e.hp y e.maxhp sean números válidos
                          e.hp = isNaN(e.hp) ? e.maxhp : e.hp;
                          e.maxhp = isNaN(e.maxhp) ? 400 : e.maxhp;

                          const newHP = e.hp + lifeSteal;
                          e.hp = Math.min(e.maxhp, isNaN(newHP) ? e.hp : newHP);

                          console.log(
                            `Minotaur steals ${lifeSteal} HP from Life Steal attack!`
                          );

                          // Mostrar número de curación para el Minotaur
                          showHitNumber(
                            e.posx,
                            e.posy - 20,
                            lifeSteal,
                            true,
                            false
                          );
                        }

                        // Habilidad especial del Minotaur: aumentar velocidad de carga 5% después de cada ataque
                        applyChargeSpeedBonus(e, 1.05);

                        // Agregar/actualizar debuff berseker
                        addDebuff(e, "berseker", 1);

                        console.log(
                          `Minotaur's charge speed increased to ${getCurrentChargeSpeed(
                            e
                          ).toFixed(2)} (rating: ${
                            e.chargeSpeedRating || "legacy"
                          }) after Life Steal attack!`
                        );
                      } else if (e.name === "Gorgon") {
                        // Ataque especial: Toxic Horror (daño a todos + stack poison)
                        console.log("Gorgon uses Toxic Horror special attack!");
                        const aliveHeroes = heroes.filter((h) => h.hp > 0);

                        // Agregar efecto visual para todos los héroes vivos
                        addToxicHorrorEffect();

                        aliveHeroes.forEach((hero) => {
                          const currentDef =
                            hero.def +
                            hero.buffs.reduce(
                              (sum, b) =>
                                b.type === "protection"
                                  ? sum + b.defBonus
                                  : sum,
                              0
                            );

                          // Toxic Horror hace daño bajo/intermedio a todos (30-45)
                          const toxicDamage =
                            30 + Math.floor(Math.random() * 16);
                          let effectiveDamage = Math.max(
                            1,
                            toxicDamage - currentDef
                          );

                          // Aplicar reducción de daño por Agony
                          const agonyBuff = hero.buffs.find(
                            (b) => b.type === "agony"
                          );
                          if (agonyBuff && agonyBuff.damageReduction) {
                            effectiveDamage = Math.floor(
                              effectiveDamage *
                                (1 - agonyBuff.damageReduction / 100)
                            );
                            effectiveDamage = Math.max(1, effectiveDamage); // Mínimo 1 de daño
                          }

                          hero.hp = Math.max(0, hero.hp - effectiveDamage);
                          validateHP(hero);

                          console.log(
                            `${
                              hero.clazz || "Hero"
                            } takes ${effectiveDamage} damage from Toxic Horror!`
                          );

                          // Mostrar número de daño
                          showHitNumber(
                            hero.posx,
                            hero.posy - 20,
                            effectiveDamage,
                            false,
                            false
                          );

                          // Si el héroe tiene poison, aumentar stacks y reiniciar duración
                          const poisonBuff = hero.buffs.find(
                            (b) => b.type === "poison"
                          );
                          if (poisonBuff) {
                            // Aumentar stack (máximo 5)
                            poisonBuff.stacks = Math.min(
                              5,
                              (poisonBuff.stacks || 1) + 1
                            );
                            // Reiniciar duración del poison a 10 segundos
                            poisonBuff.endTime = currentTime + 10;
                            poisonBuff.nextTick = currentTime + 3;
                            // Recalcular daño base con el nuevo stack: daño base 4-6 + 2 por stack adicional
                            const baseDamage =
                              4 + Math.floor(Math.random() * 3); // 4-6
                            poisonBuff.damage =
                              baseDamage + (poisonBuff.stacks - 1) * 2;
                            console.log(
                              `${hero.clazz} poison stacks increased to ${poisonBuff.stacks}, damage: ${poisonBuff.damage}`
                            );
                          } else {
                            // Si no tenía poison, NO se agrega (según especificaciones)
                            console.log(
                              `${hero.clazz} had no poison, so no stack accumulated`
                            );
                          }
                        });
                      }
                    } else if (isMainAbility) {
                      if (e.name === "Boss Bat") {
                        // Habilidad principal: Blood Splat (a un solo aliado aleatorio)
                        console.log(
                          "Boss Bat uses Blood Splat main ability (single target)!"
                        );
                        const aliveHeroes = heroes.filter((h) => h.hp > 0);
                        if (aliveHeroes.length > 0) {
                          // Seleccionar héroe aleatorio en lugar del más cercano
                          const randomIndex = Math.floor(
                            Math.random() * aliveHeroes.length
                          );
                          const randomTarget = aliveHeroes[randomIndex];

                          const currentDef =
                            randomTarget.def +
                            randomTarget.buffs.reduce(
                              (sum, b) =>
                                b.type === "protection"
                                  ? sum + b.defBonus
                                  : sum,
                              0
                            );

                          const criticalResult = calculateCritical(damage);
                          const finalDamage = criticalResult.damage;
                          let effectiveDamage = Math.max(
                            1,
                            finalDamage - currentDef
                          );

                          // Aplicar reducción de daño por Agony
                          const agonyBuff = randomTarget.buffs.find(
                            (b) => b.type === "agony"
                          );
                          if (agonyBuff && agonyBuff.damageReduction) {
                            effectiveDamage = Math.floor(
                              effectiveDamage *
                                (1 - agonyBuff.damageReduction / 100)
                            );
                            effectiveDamage = Math.max(1, effectiveDamage); // Mínimo 1 de daño
                          }

                          randomTarget.hp = Math.max(
                            0,
                            randomTarget.hp - effectiveDamage
                          );

                          console.log(
                            `${
                              randomTarget.clazz || "Hero"
                            } takes ${effectiveDamage} damage from Blood Splat!`
                          );

                          // Mostrar número de daño
                          showHitNumber(
                            randomTarget.posx,
                            randomTarget.posy - 20,
                            effectiveDamage,
                            false,
                            criticalResult.isCritical
                          );

                          // Agregar efecto visual de Blood Splat
                          addBloodSplatEffect(
                            randomTarget.posx,
                            randomTarget.posy
                          );
                        }
                      } else if (e.name === "Minotaur") {
                        // Habilidad principal: Smash (ataque devastador a un solo héroe)
                        console.log(
                          "Minotaur uses Smash main ability (single target)!"
                        );
                        const aliveHeroes = heroes.filter((h) => h.hp > 0);
                        if (aliveHeroes.length > 0) {
                          // Seleccionar héroe aleatorio
                          const randomIndex = Math.floor(
                            Math.random() * aliveHeroes.length
                          );
                          const randomTarget = aliveHeroes[randomIndex];

                          const currentDef =
                            randomTarget.def +
                            randomTarget.buffs.reduce(
                              (sum, b) =>
                                b.type === "protection"
                                  ? sum + b.defBonus
                                  : sum,
                              0
                            );

                          const criticalResult = calculateCritical(damage);
                          const finalDamage = criticalResult.damage;
                          let effectiveDamage = Math.max(
                            1,
                            finalDamage - currentDef
                          );

                          // Aplicar reducción de daño por Agony
                          const agonyBuff = randomTarget.buffs.find(
                            (b) => b.type === "agony"
                          );
                          if (agonyBuff && agonyBuff.damageReduction) {
                            effectiveDamage = Math.floor(
                              effectiveDamage *
                                (1 - agonyBuff.damageReduction / 100)
                            );
                            effectiveDamage = Math.max(1, effectiveDamage); // Mínimo 1 de daño
                          }

                          randomTarget.hp = Math.max(
                            0,
                            randomTarget.hp - effectiveDamage
                          );

                          console.log(
                            `${
                              randomTarget.clazz || "Hero"
                            } takes ${effectiveDamage} massive damage from Smash!`
                          );

                          // Mostrar número de daño
                          showHitNumber(
                            randomTarget.posx,
                            randomTarget.posy - 20,
                            effectiveDamage,
                            false,
                            criticalResult.isCritical
                          );

                          // Agregar efecto visual de Smash
                          addMinotaurSmashEffect(
                            randomTarget.posx,
                            randomTarget.posy
                          );

                          // Habilidad especial del Minotaur: aumentar velocidad de carga 5% después de cada ataque
                          applyChargeSpeedBonus(e, 1.05);

                          // Agregar/actualizar debuff berseker
                          addDebuff(e, "berseker", 1);

                          console.log(
                            `Minotaur's charge speed increased to ${getCurrentChargeSpeed(
                              e
                            ).toFixed(2)} (rating: ${
                              e.chargeSpeedRating || "legacy"
                            }) after Smash attack!`
                          );
                        }
                      } else if (e.name === "Gorgon") {
                        // Habilidad principal: Poison Strike (daño bajo + veneno)
                        console.log("Gorgon uses Poison Strike main ability!");
                        const aliveHeroes = heroes.filter((h) => h.hp > 0);
                        if (aliveHeroes.length > 0) {
                          // Seleccionar héroe aleatorio
                          const randomIndex = Math.floor(
                            Math.random() * aliveHeroes.length
                          );
                          const randomTarget = aliveHeroes[randomIndex];

                          const currentDef =
                            randomTarget.def +
                            randomTarget.buffs.reduce(
                              (sum, b) =>
                                b.type === "protection" || b.type === "agony"
                                  ? sum + b.defBonus
                                  : sum,
                              0
                            );

                          // Poison Strike hace daño bajo (20-30)
                          const poisonStrikeDamage =
                            20 + Math.floor(Math.random() * 11);
                          const effectiveDamage = Math.max(
                            1,
                            poisonStrikeDamage - currentDef
                          );
                          randomTarget.hp = Math.max(
                            0,
                            randomTarget.hp - effectiveDamage
                          );

                          console.log(
                            `${
                              randomTarget.clazz || "Hero"
                            } takes ${effectiveDamage} damage from Poison Strike!`
                          );

                          // Mostrar número de daño
                          showHitNumber(
                            randomTarget.posx,
                            randomTarget.posy - 20,
                            effectiveDamage,
                            false,
                            false
                          );

                          // Aplicar veneno al objetivo
                          const existingPoison = randomTarget.buffs.find(
                            (b) => b.type === "poison"
                          );
                          if (!existingPoison) {
                            randomTarget.buffs.push({
                              type: "poison",
                              endTime: currentTime + 10, // 10 segundos de duración
                              nextTick: currentTime + 3, // Primer tick en 3 segundos
                              damage: 4 + Math.floor(Math.random() * 3), // Daño entre 4-6
                              tickInterval: 3, // Tick cada 3 segundos
                              stacks: 1,
                            });

                            // Agregar icono de veneno
                            addDebuff(randomTarget, "poison", 1);
                          }

                          // Agregar efecto visual de Poison Strike
                          addTentacleStrikeEffect(
                            randomTarget.posx,
                            randomTarget.posy
                          );

                          console.log(
                            `Gorgon applies poison to ${randomTarget.clazz}!`
                          );
                        }
                      }
                    } else {
                      // Ataque normal a un solo objetivo (el más cercano)
                      if (target.hp > 0) {
                        const currentDef =
                          target.def +
                          target.buffs.reduce(
                            (sum, b) =>
                              b.type === "protection" ? sum + b.defBonus : sum,
                            0
                          );

                        // Calcular crítico para auto-ataque de enemigo
                        const criticalResult = calculateCritical(damage);
                        const finalDamage = criticalResult.damage;
                        const isCritical = criticalResult.isCritical;

                        let effectiveDamage = Math.max(
                          1,
                          finalDamage - currentDef
                        );

                        // Aplicar reducción de daño por Agony
                        const agonyBuff = target.buffs.find(
                          (b) => b.type === "agony"
                        );
                        if (agonyBuff && agonyBuff.damageReduction) {
                          effectiveDamage = Math.floor(
                            effectiveDamage *
                              (1 - agonyBuff.damageReduction / 100)
                          );
                          effectiveDamage = Math.max(1, effectiveDamage); // Mínimo 1 de daño
                        }

                        target.hp = Math.max(0, target.hp - effectiveDamage);

                        // Validar que el HP no sea NaN después del cálculo
                        if (isNaN(target.hp)) {
                          console.error("Enemy HP became NaN, resetting to 0");
                          target.hp = 0;
                        }

                        // Mostrar número de daño del enemigo auto-attack con crítico
                        showHitNumber(
                          target.posx,
                          target.posy - 20,
                          effectiveDamage,
                          false,
                          isCritical
                        );

                        // Implementar habilidades específicas de enemigos del Dark Swamp
                        if (e.name === "Mushroom") {
                          // Mushroom: Ataque básico + aplicar Poison
                          console.log("Mushroom uses poison attack!");

                          // Aplicar veneno al objetivo atacado
                          const existingPoison = target.buffs.find(
                            (b) => b.type === "poison"
                          );
                          if (!existingPoison) {
                            target.buffs.push({
                              type: "poison",
                              endTime: currentTime + 10, // 10 segundos de duración
                              nextTick: currentTime + 3, // Primer tick en 3 segundos
                              damage: 4 + Math.floor(Math.random() * 3), // Daño entre 4-6
                              tickInterval: 3, // Tick cada 3 segundos
                              stacks: 1,
                            });

                            // Agregar icono de veneno
                            addDebuff(target, "poison", 1);
                            console.log(
                              `Mushroom applies poison to ${target.clazz}!`
                            );
                          }
                        } else if (e.name === "Dreadwing") {
                          // Dreadwing: Ataque doble a dos héroes aleatorios (puede repetir)
                          console.log("Dreadwing uses double strike!");

                          const aliveHeroes = heroes.filter((h) => h.hp > 0);
                          if (aliveHeroes.length > 0) {
                            // Segundo ataque a héroe aleatorio
                            const secondTarget =
                              aliveHeroes[
                                Math.floor(Math.random() * aliveHeroes.length)
                              ];

                            const secondTargetDef =
                              secondTarget.def +
                              secondTarget.buffs.reduce(
                                (sum, b) =>
                                  b.type === "protection"
                                    ? sum + b.defBonus
                                    : sum,
                                0
                              );

                            const secondCriticalResult =
                              calculateCritical(damage);
                            let secondEffectiveDamage = Math.max(
                              1,
                              secondCriticalResult.damage - secondTargetDef
                            );

                            // Aplicar reducción de daño por Agony
                            const agonyBuff = secondTarget.buffs.find(
                              (b) => b.type === "agony"
                            );
                            if (agonyBuff && agonyBuff.damageReduction) {
                              secondEffectiveDamage = Math.floor(
                                secondEffectiveDamage *
                                  (1 - agonyBuff.damageReduction / 100)
                              );
                              secondEffectiveDamage = Math.max(
                                1,
                                secondEffectiveDamage
                              ); // Mínimo 1 de daño
                            }

                            secondTarget.hp = Math.max(
                              0,
                              secondTarget.hp - secondEffectiveDamage
                            );

                            showHitNumber(
                              secondTarget.posx,
                              secondTarget.posy - 20,
                              secondEffectiveDamage,
                              false,
                              secondCriticalResult.isCritical
                            );

                            console.log(
                              `Dreadwing's second strike hits ${secondTarget.clazz} for ${secondEffectiveDamage} damage!`
                            );

                            checkGameOver();
                          }
                        } else if (e.name === "Fire Worm") {
                          // Fire Worm: Ataque intermedio básico (ya aplicado en damage base)
                          console.log(
                            "Fire Worm uses basic intermediate attack!"
                          );
                          // No hay lógica adicional, solo el ataque básico intermedio
                        } else if (e.name === "Minotaur") {
                          applyChargeSpeedBonus(e, 1.05);

                          // Agregar/actualizar debuff berseker
                          addDebuff(e, "berseker", 1);

                          console.log(
                            `Minotaur's charge speed increased to ${getCurrentChargeSpeed(
                              e
                            ).toFixed(2)} (rating: ${
                              e.chargeSpeedRating || "legacy"
                            }) after basic attack!`
                          );
                        }

                        // Lógica de veneno para enemigos del Dark Swamp (Mushroom y Gorgon)
                        if (e.name === "Skeleton" || e.name === "Gorgon") {
                          // Agregar debuff de veneno a un héroe aleatorio
                          const aliveHeroes = heroes.filter((h) => h.hp > 0);
                          if (aliveHeroes.length > 0) {
                            const randomIndex = Math.floor(
                              Math.random() * aliveHeroes.length
                            );
                            const poisonTarget = aliveHeroes[randomIndex];

                            // Agregar buff de veneno
                            poisonTarget.buffs.push({
                              type: "poison",
                              endTime: currentTime + 15, // 15 segundos de duración
                              nextTick: currentTime + 3, // Primer tick en 3 segundos
                              damage: 3 + Math.floor(Math.random() * 3), // Daño entre 3-5
                              tickInterval: 3, // Tick cada 3 segundos
                            });

                            // Agregar icono de veneno
                            addDebuff(poisonTarget, "poison", 1);

                            console.log(
                              `${e.name} applies poison to ${poisonTarget.clazz}!`
                            );
                          }
                        }

                        checkGameOver();
                      }
                    }
                  }, 100);
                }
              }
            }

            // Actualizar animaciones de enemigos - usando sprites dinámicos del nivel
            if (e.anim === "hurt") {
              const elapsed = currentTime - e.animStartTime;
              if (elapsed >= 0.3) {
                // Duración del efecto de daño
                e.anim = "idle";
                e.frame = 0; // Reiniciar frame
                e.animStartTime = currentTime;
              }
            } else if (e.anim === "die") {
              const elapsed = currentTime - e.animStartTime;
              const frameDuration = 0.12; // Duración por frame para muerte (más fluido: 0.15 -> 0.12)
              e.frame = Math.floor(elapsed / frameDuration);
              const deathFrames = e.deathFrames || 6; // Usar frames dinámicos o fallback
              if (e.frame >= deathFrames) {
                e.deathAnimComplete = true;
                e.frame = deathFrames - 1; // Mantener en el último frame
              }
            } else if (e.anim === "attack") {
              const elapsed = currentTime - e.animStartTime;
              const frameDuration = 0.08; // Duración por frame para ataque (más fluido: 0.1 -> 0.08)
              e.frame = Math.floor(elapsed / frameDuration);

              // Determinar frames de ataque según el tipo
              let attackFrames = e.attackFrames || 4;
              if (e.name === "Gorgon" && e.isSpecialAttack) {
                attackFrames = e.specialAttackFrames || 16; // Usar frames de ataque especial
              }

              if (e.frame >= attackFrames) {
                e.anim = "idle"; // Volver a idle después del ataque
                e.frame = 0;
                e.animStartTime = currentTime;
                e.isSpecialAttack = false; // Limpiar flag de ataque especial
              }
            } else if (e.anim === "explode") {
              // Animación especial de explosión para Crab Bomb
              const elapsed = currentTime - e.animStartTime;
              const frameDuration = 0.08; // Duración por frame para explosión (más lenta para ser visible)
              e.frame = Math.floor(elapsed / frameDuration);

              const explodeFrames = e.explodeFrames || 23; // 23 frames de explosión
              if (e.frame >= explodeFrames) {
                // La animación de explosión ha terminado, aplicar daño ahora
                if (e.explosionDamagePending) {
                  const explosionDamage = 75 + Math.floor(Math.random() * 6); // 75-80 daño

                  console.log(
                    "Applying explosion damage as animation completes"
                  );

                  heroes.forEach((hero) => {
                    if (hero.hp > 0) {
                      const currentDef =
                        hero.def +
                        hero.buffs.reduce(
                          (sum, b) =>
                            b.type === "protection" ? sum + b.defBonus : sum,
                          0
                        );

                      let effectiveDamage = Math.max(
                        1,
                        explosionDamage - currentDef
                      );

                      // Aplicar reducción de daño por Agony
                      const agonyBuff = hero.buffs.find(
                        (b) => b.type === "agony"
                      );
                      if (agonyBuff && agonyBuff.damageReduction) {
                        effectiveDamage = Math.floor(
                          effectiveDamage *
                            (1 - agonyBuff.damageReduction / 100)
                        );
                        effectiveDamage = Math.max(1, effectiveDamage); // Mínimo 1 de daño
                      }

                      hero.hp = Math.max(0, hero.hp - effectiveDamage);
                      validateHP(hero);

                      showHitNumber(
                        hero.posx,
                        hero.posy - 20,
                        effectiveDamage,
                        false,
                        false
                      );
                      console.log(
                        `${hero.clazz} takes ${effectiveDamage} explosion damage!`
                      );
                    }
                  });

                  // Marcar que el daño ya se aplicó
                  e.explosionDamagePending = false;

                  checkGameOver();
                }

                // Terminar explosión y cambiar a muerte
                e.anim = "die";
                e.frame = 0;
                e.animStartTime = currentTime;
                e.hp = 0;
                e.isDying = true;
                console.log(
                  "Explosion animation completed, switching to death"
                );
              }
            } else if (e.anim === "idle" && e.hp > 0) {
              const elapsed = currentTime - e.animStartTime;
              const frameDuration = 0.18; // Duración por frame para idle (más fluido: 0.25 -> 0.18)
              const idleFrames = e.idleFrames || 4; // Usar frames dinámicos o fallback
              e.frame = Math.floor(elapsed / frameDuration) % idleFrames;
            }

            if (e.animTime > 0) e.animTime -= delta;
          });

          // Update hero charge over time
          heroes.forEach((h) => {
            if (h.hp > 0) {
              // Use the new charge speed rating system
              const chargeSpeed = getChargeSpeedFromRating(
                h.chargeSpeedRating || 5
              );
              h.charge = Math.min(h.maxcharge, h.charge + delta * chargeSpeed);
            }
          });

          // Verificar si el héroe seleccionado ha muerto durante la selección de objetivo
          checkAndCancelDeadHeroAction();
        } // Fin del bloque condicional del juego

        draw();
        requestAnimationFrame(loop);
      }

      function draw() {
        ctx.clearRect(0, 0, designWidth, designHeight);

        // Configurar interpolación de alta calidad para todos los sprites
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";

        // Si estamos en el menú principal, renderizar la pantalla de inicio
        if (state === "main_menu") {
          drawMainMenu();
          return;
        }

        // Si estamos en la pantalla de información de nivel
        if (state === "level_info") {
          drawLevelInfo();
          return;
        }

        // Si estamos en la pantalla de finalización de nivel
        if (state === "level_completion") {
          drawLevelCompletion();
          return;
        }

        // Draw background
        ctx.drawImage(currentBackgroundImg, 0, 0, designWidth, designHeight);

        // IMPORTANTE: Limitar el área de renderizado del juego para que no interfiera con header/footer
        ctx.save();
        ctx.beginPath();
        ctx.rect(0, GAME_AREA_Y, designWidth, GAME_AREA_HEIGHT);
        ctx.clip();

        heroes.forEach((h) => {
          const animData = h.animations[h.anim];
          // El frameOffset ya no es necesario para conflagration ya que usa su propia fila
          let frameOffset = 0;
          const sx = (h.frame + frameOffset) * h.frameW;
          const sy = animData.row * h.frameH;
          const size = h.size || 80;

          // Aplicar efecto de sombra/transparencia si está muerto
          if (h.hp <= 0) {
            ctx.save();
            ctx.globalAlpha = 0.6; // Menos transparente (era 0.4)
            ctx.filter = "brightness(0.3) contrast(0.8)"; // Más oscuro
          }

          ctx.drawImage(
            h.img,
            sx,
            sy,
            h.frameW,
            h.frameH,
            h.posx - size / 2,
            h.posy - size / 2,
            size,
            size
          );

          if (h.hp <= 0) {
            ctx.restore(); // Restaurar efectos
          }

          // HP bar background
          ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
          ctx.fillRect(h.posx - 40, h.posy + 55, 80, 12);

          // HP bar red
          ctx.fillStyle = "red";
          const hpWidth = 80 * (h.hp / h.maxhp);
          ctx.fillRect(h.posx - 40, h.posy + 55, hpWidth, 12);

          // Texto de HP centrado perfectamente en la barra
          ctx.fillStyle = "white";
          ctx.font = "8px 'Press Start 2P'";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          if (h.hp <= 0) {
            ctx.fillText("DEAD", h.posx, h.posy + 55 + 6); // Centrado en Y
          } else {
            ctx.fillText(`${h.hp}`, h.posx, h.posy + 55 + 6); // Centrado en Y
          }
          ctx.textAlign = "left"; // Resetear alineación
          ctx.textBaseline = "alphabetic"; // Resetear baseline

          // Charge bar background - dividido en 3 bloques (solo si está vivo)
          if (h.hp > 0) {
            ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
            ctx.fillRect(h.posx - 40, h.posy + 70, 80, 8);

            // Charge bar yellow - primer bloque (33.33%)
            ctx.fillStyle = "#FFD700";
            const firstBlockWidth = Math.min(26.67, 26.67 * (h.charge / 33.33));
            if (h.charge > 0) {
              ctx.fillRect(h.posx - 40, h.posy + 70, firstBlockWidth, 8);
            }

            // Segundo bloque (siguiente 33.33%)
            if (h.charge > 33.33) {
              const secondBlockWidth = 26.67 * ((h.charge - 33.33) / 33.33);
              ctx.fillRect(h.posx - 13.33, h.posy + 70, secondBlockWidth, 8);
            }

            // Tercer bloque (último 33.34%)
            if (h.charge > 66.66) {
              const thirdBlockWidth = 26.67 * ((h.charge - 66.66) / 33.34);
              ctx.fillRect(h.posx + 13.33, h.posy + 70, thirdBlockWidth, 8);
            }

            // Separadores entre bloques
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2;
            ctx.beginPath();
            // Primer separador (33.33%)
            ctx.moveTo(h.posx - 13.33, h.posy + 70);
            ctx.lineTo(h.posx - 13.33, h.posy + 78);
            // Segundo separador (66.66%)
            ctx.moveTo(h.posx + 13.33, h.posy + 70);
            ctx.lineTo(h.posx + 13.33, h.posy + 78);
            ctx.stroke();

            // Borde de la barra de carga
            ctx.strokeStyle = "black";
            ctx.lineWidth = 1;
            ctx.strokeRect(h.posx - 40, h.posy + 70, 80, 8);
          }

          // Borde de la barra de HP
          ctx.strokeStyle = "black";
          ctx.lineWidth = 1;
          ctx.strokeRect(h.posx - 40, h.posy + 55, 80, 12);

          // Renderizar debuffs debajo de la barra de energía
          if (h.hp > 0) {
            // Solo si está vivo
            renderDebuffs(h, h.posx, h.posy + 80);
          }
        });

        enemies.forEach((e) => {
          if (e.hp <= 0 && e.deathAnimComplete) return; // No dibujar si completó animación de muerte

          const size = e.size || 80;

          // Usar los sprites específicos del enemigo según el nivel
          ctx.save();

          // Activar interpolación suave para mejor calidad
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = "high";

          // Seleccionar sprite y calcular posición según animación
          let spriteImg, sx, sy;

          // Verificar si es Minotaur (usa sprite sheet completo)
          if (e.name === "Minotaur") {
            spriteImg = minotaurAllStatesImg;

            if (e.anim === "die") {
              // Fila 1 (attack) como "death" visual: 16 frames
              sx = e.frame * e.frameWidth;
              sy = 1 * e.frameHeight;
              // Efecto de desvanecimiento gradual al morir
              const deathProgress = e.frame / ((e.deathFrames || 16) - 1);
              ctx.globalAlpha = 1 - deathProgress * 0.7;
              ctx.filter = "grayscale(50%) brightness(0.5)";
            } else if (e.anim === "hurt") {
              // Para hurt, usar idle (fila 0) pero con efectos visuales
              sx = e.frame * e.frameWidth;
              sy = 0 * e.frameHeight;
              ctx.filter = "hue-rotate(0deg) contrast(1.5) brightness(1.2)";
              ctx.globalAlpha = 0.8 + 0.2 * Math.sin(currentTime * 20);
            } else if (e.anim === "attack") {
              // Fila 1 (attack): 16 frames
              sx = e.frame * e.frameWidth;
              sy = 1 * e.frameHeight;
            } else {
              // Fila 0 (idle): 16 frames
              sx = e.frame * e.frameWidth;
              sy = 0 * e.frameHeight;
            }
          } else if (e.name === "Gorgon") {
            // Usar diferentes sprites según la animación
            if (e.anim === "die") {
              spriteImg = swampGorgonDeathImg;
              sx = e.frame * e.frameWidth;
              sy = 0; // Solo una fila en el sprite de muerte
              // Efecto de desvanecimiento gradual al morir
              const deathProgress = e.frame / ((e.deathFrames || 3) - 1);
              ctx.globalAlpha = 1 - deathProgress * 0.7;
              ctx.filter = "grayscale(50%) brightness(0.5)";
            } else if (e.anim === "hurt") {
              spriteImg = swampGorgonIdleImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
              ctx.filter = "hue-rotate(0deg) contrast(1.5) brightness(1.2)";
              ctx.globalAlpha = 0.8 + 0.2 * Math.sin(currentTime * 20);
            } else if (e.anim === "attack") {
              // Verificar si es ataque especial
              if (e.isSpecialAttack) {
                spriteImg = swampGorgonSpecialAttackImg;
              } else {
                spriteImg = swampGorgonAttackImg;
              }
              sx = e.frame * e.frameWidth;
              sy = 0; // Solo una fila en cada sprite de ataque
            } else {
              // Idle animation
              spriteImg = swampGorgonIdleImg;
              sx = e.frame * e.frameWidth;
              sy = 0; // Solo una fila en el sprite idle
            }

            // Mejorar calidad de renderizado para Gorgon
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = "high";
          } else if (e.name === "Crab Bomb") {
            // Usar diferentes sprites según la animación para Crab Bomb
            if (e.anim === "die") {
              spriteImg = crabBombDeathImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
              // Efecto de desvanecimiento gradual al morir
              const deathProgress = e.frame / ((e.deathFrames || 6) - 1);
              ctx.globalAlpha = 1 - deathProgress * 0.7;
              ctx.filter = "grayscale(50%) brightness(0.5)";
            } else if (e.anim === "explode") {
              spriteImg = crabBombExplodeImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
              // Efecto muy brillante y llamativo para la explosión
              ctx.filter = "brightness(1.8) contrast(1.5) saturate(1.3)";
              ctx.globalAlpha = 1.0; // Asegurar que sea completamente visible

              // Agregar un resplandor adicional
              ctx.shadowColor = "orange";
              ctx.shadowBlur = 15;
              ctx.shadowOffsetX = 0;
              ctx.shadowOffsetY = 0;
            } else if (e.anim === "hurt") {
              spriteImg = crabBombIdleImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
              ctx.filter = "hue-rotate(0deg) contrast(1.5) brightness(1.2)";
              ctx.globalAlpha = 0.8 + 0.2 * Math.sin(currentTime * 20);
            } else {
              // idle
              spriteImg = crabBombIdleImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
            }
          } else {
            // Lógica original para otros enemigos (Demon Bat, Worm)
            if (e.anim === "die") {
              spriteImg = e.sprites ? e.sprites.death : goblinDieImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
              // Efecto de desvanecimiento gradual al morir
              const deathProgress = e.frame / ((e.deathFrames || 6) - 1);
              ctx.globalAlpha = 1 - deathProgress * 0.7;
              ctx.filter = "grayscale(50%) brightness(0.5)";
            } else if (e.anim === "hurt") {
              // Para hurt, usar idle pero con efectos visuales
              spriteImg = e.sprites ? e.sprites.idle : goblinIdleImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
              // Efecto de flash rojo cuando recibe daño
              ctx.filter = "hue-rotate(0deg) contrast(1.5) brightness(1.2)";
              ctx.globalAlpha = 0.8 + 0.2 * Math.sin(currentTime * 20); // Parpadeo
            } else if (e.anim === "attack") {
              // Animación de ataque
              spriteImg = e.sprites ? e.sprites.attack : goblinIdleImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
            } else {
              // idle
              spriteImg = e.sprites ? e.sprites.idle : goblinIdleImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
            }
          }

          // Dibujar el sprite del enemigo
          // Para Demon Slime, mantener las proporciones originales del sprite
          let drawWidth = size;
          let drawHeight = size;

          if (e.name === "Minotaur") {
            // Mantener proporciones originales del sprite (288x160)
            const aspectRatio = e.frameWidth / e.frameHeight; // 288/160 = 1.8
            drawWidth = size;
            drawHeight = size / aspectRatio; // Ajustar altura para mantener proporción
          } else if (e.name === "Gorgon") {
            // Mantener proporciones originales del sprite (128x128)
            const aspectRatio = e.frameWidth / e.frameHeight; // 128/128 = 1.0
            drawWidth = size;
            drawHeight = size / aspectRatio; // Ajustar altura para mantener proporción (es cuadrado)
          }

          ctx.drawImage(
            spriteImg,
            sx,
            sy,
            e.frameWidth,
            e.frameHeight,
            e.posx - drawWidth / 2,
            e.posy - drawHeight / 2,
            drawWidth,
            drawHeight
          );

          // Reset de efectos visuales para no afectar otros elementos
          ctx.filter = "none";
          ctx.shadowColor = "transparent";
          ctx.shadowBlur = 0;
          ctx.globalAlpha = 1.0;

          ctx.restore();

          // Solo mostrar HUD si no está muerto o aún no completó la animación
          if (e.hp > 0 || !e.deathAnimComplete) {
            // Calcular offset vertical para la barra de HP según el tipo de enemigo
            let hpBarOffset = size / 2 + 25;
            if (e.name === "Minotaur") {
              // Usar la altura real del sprite renderizado
              const aspectRatio = e.frameWidth / e.frameHeight;
              const actualHeight = size / aspectRatio;
              hpBarOffset = actualHeight / 2 + 25;
            } else if (e.name === "Gorgon") {
              // Para Gorgon, reducir distancia del HUD
              hpBarOffset = size / 2 + 15; // Reducido de +25 a +15 para estar más cerca
            }

            // Título del enemigo - encima de la barra de HP, pegado a la izquierda
            ctx.fillStyle = "#FFFFFF"; // Blanco
            ctx.strokeStyle = "#2A1F0F"; // Borde marrón oscuro
            ctx.lineWidth = 2;
            ctx.font = "bold 9px 'Press Start 2P'"; // Aumentado de 7px a 9px
            ctx.textAlign = "left";
            ctx.textBaseline = "alphabetic";

            const titleX = e.posx - 40; // Pegado a la izquierda del HUD
            const titleY = e.posy - hpBarOffset - 8; // Encima de la barra de HP

            // Dibujar borde del título
            ctx.strokeText(e.name, titleX, titleY);
            // Dibujar texto del título
            ctx.fillText(e.name, titleX, titleY);

            // HP bar background - ahora encima del enemigo
            ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
            ctx.fillRect(e.posx - 40, e.posy - hpBarOffset, 80, 12);

            // HP bar red
            ctx.fillStyle = "red";
            // Validar que e.hp y e.maxhp sean números válidos para evitar NaN
            const validHP = isNaN(e.hp) ? 0 : e.hp;
            const validMaxHP = isNaN(e.maxhp) ? 1 : e.maxhp;
            const hpWidth = 80 * (validHP / validMaxHP);
            ctx.fillRect(e.posx - 40, e.posy - hpBarOffset, hpWidth, 12);

            // Texto de HP centrado perfectamente en la barra
            ctx.fillStyle = "white";
            ctx.font = "8px 'Press Start 2P'";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            // Mostrar HP válido, si es NaN mostrar 0
            ctx.fillText(
              `${isNaN(e.hp) ? 0 : Math.floor(e.hp)}`,
              e.posx,
              e.posy - hpBarOffset + 6
            );
            ctx.textAlign = "left"; // Resetear alineación
            ctx.textBaseline = "alphabetic"; // Resetear baseline

            // Charge bar background (solo si está vivo) - directamente debajo de la HP bar
            if (e.hp > 0) {
              ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
              ctx.fillRect(e.posx - 40, e.posy - hpBarOffset + 12, 80, 8);

              // Charge bar orange - barra continua sin divisiones
              ctx.fillStyle = "#FFA500";
              const chargeWidth = 80 * (e.charge / e.maxcharge);
              ctx.fillRect(
                e.posx - 40,
                e.posy - hpBarOffset + 12,
                chargeWidth,
                8
              );

              // Borde de charge bar
              ctx.strokeStyle = "black";
              ctx.lineWidth = 1;
              ctx.strokeRect(e.posx - 40, e.posy - hpBarOffset + 12, 80, 8);

              // Mostrar contador de ataque especial como número a la derecha de la barra
              if (
                (e.type === "boss" &&
                  e.attacksUntilSpecial !== null &&
                  e.attacksUntilSpecial <= 3) ||
                (e.name === "Crab Bomb" && e.maxSphereCharges)
              ) {
                let counterValue;
                if (e.name === "Crab Bomb") {
                  // Para Crab Bomb, cuenta regresiva: 5,4,3,2,1
                  counterValue = e.maxSphereCharges - (e.sphereCharges || 0);
                } else {
                  // Para bosses, mostrar ataques restantes: 3,2,1
                  counterValue = e.attacksUntilSpecial;
                }

                // Posición del contador: a la derecha de la barra de energía
                const counterX = e.posx + 45; // 40 (mitad de barra) + 5 (margen)
                const counterY = e.posy - hpBarOffset + 16; // Centrado con barra de energía

                // Dibujar número con borde para mejor visibilidad
                ctx.fillStyle = "#FFD700"; // Amarillo dorado
                ctx.strokeStyle = "#000000"; // Borde negro
                ctx.lineWidth = 2;
                ctx.font = "bold 8px 'Press Start 2P'";
                ctx.textAlign = "left";
                ctx.textBaseline = "middle";

                // Dibujar borde
                ctx.strokeText(counterValue.toString(), counterX, counterY);
                // Dibujar número
                ctx.fillText(counterValue.toString(), counterX, counterY);
              }
            }

            // Borde de HP bar
            ctx.strokeStyle = "black";
            ctx.lineWidth = 1;
            ctx.strokeRect(e.posx - 40, e.posy - hpBarOffset, 80, 12);

            // Renderizar debuffs debajo de la barra de carga (solo si está vivo)
            renderDebuffs(e, e.posx, e.posy - hpBarOffset + 22);
          }
        });

        // Renderizar efectos visuales especiales
        renderVisualEffects();

        // Renderizar números de golpe flotantes
        renderHitNumbers();

        // Restaurar el contexto para poder renderizar UI sin restricciones
        ctx.restore();

        // Mostrar indicador de selección de objetivo con ventana modal
        if (state === "select_target_enemy") {
          // Background que ocupa todo el ancho
          const modalWidth = designWidth;
          const modalHeight = 40;
          const modalX = 0;
          const modalY = 75;

          ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
          ctx.fillRect(modalX, modalY, modalWidth, modalHeight);

          // Texto principal - primera letra mayúscula, más pequeño, color menos fuerte
          ctx.fillStyle = "#E0E0E0";
          ctx.font = "10px 'Press Start 2P'";
          ctx.textAlign = "center";
          ctx.fillText(
            "Select enemy",
            designWidth / 2,
            modalY + modalHeight / 2 + 3
          );

          // X de cerrar en la esquina superior derecha del modal
          const closeX = modalX + modalWidth - 15;
          const closeY = modalY + 10;

          ctx.fillStyle = "rgba(255, 0, 0, 0.8)";
          ctx.font = "12px 'Press Start 2P'";
          ctx.textAlign = "center";
          ctx.fillText("X", closeX, closeY);
        } else if (state === "select_target_ally") {
          // Background que ocupa todo el ancho
          const modalWidth = designWidth;
          const modalHeight = 40;
          const modalX = 0;
          const modalY = 75;

          ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
          ctx.fillRect(modalX, modalY, modalWidth, modalHeight);

          // Texto principal - primera letra mayúscula, más pequeño, color menos fuerte
          ctx.fillStyle = "#E0E0E0";
          ctx.font = "10px 'Press Start 2P'";
          ctx.textAlign = "center";
          ctx.fillText(
            "Select ally",
            designWidth / 2,
            modalY + modalHeight / 2 + 3
          );

          // X de cerrar en la esquina superior derecha del modal
          const closeX = modalX + modalWidth - 15;
          const closeY = modalY + 10;

          ctx.fillStyle = "rgba(255, 0, 0, 0.8)";
          ctx.font = "12px 'Press Start 2P'";
          ctx.textAlign = "center";
          ctx.fillText("X", closeX, closeY);
        }
        ctx.textAlign = "left"; // Resetear alineación

        // Indicador visual removido - ya no necesario sin sistema de turnos

        // RENDERIZAR HEADER Y FOOTER AL FINAL para garantizar que siempre estén visibles
        drawHeader();
        drawFooter();
      }

      function drawHeader() {
        // Limpiar completamente el área del header para evitar interferencias
        ctx.clearRect(0, 0, designWidth, HEADER_HEIGHT);

        // Fondo del header - color beige claro
        ctx.fillStyle = "#D3BF8F";
        ctx.fillRect(0, 0, designWidth, HEADER_HEIGHT);

        // Borde inferior del header
        ctx.strokeStyle = "#3D2914";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, HEADER_HEIGHT);
        ctx.lineTo(designWidth, HEADER_HEIGHT);
        ctx.stroke();

        // Score centrado - primera sección (altura: 30px, padding: 7px arriba y abajo)
        ctx.font = "bold 10px 'Press Start 2P'";
        ctx.textAlign = "center";

        // Texto "Points" con estilo amarillo y borde
        const pointsText = " Points";
        const pointsWidth = ctx.measureText(pointsText).width;
        const scoreText = score.toString();
        const scoreWidth = ctx.measureText(scoreText).width;
        const totalWidth = scoreWidth + pointsWidth;

        // Número del score en marrón sin borde
        ctx.fillStyle = "#3D2914";
        ctx.fillText(
          scoreText,
          designWidth / 2 - totalWidth / 2 + scoreWidth / 2,
          22
        );

        // Texto "Points" en amarillo con borde marrón oscuro
        ctx.strokeStyle = "#2A1F0F"; // Marrón oscuro para el borde
        ctx.lineWidth = 3;
        ctx.strokeText(pointsText, designWidth / 2 + scoreWidth / 2, 22);
        ctx.fillStyle = "#FFD700"; // Amarillo dorado
        ctx.fillText(pointsText, designWidth / 2 + scoreWidth / 2, 22);

        // Línea divisora entre score y level/wave - más ancha
        ctx.strokeStyle = "#3D2914"; // Marrón oscuro
        ctx.lineWidth = 4; // Aumentado de 2 a 4
        ctx.beginPath();
        ctx.moveTo(0, HEADER_HEIGHT / 2);
        ctx.lineTo(designWidth, HEADER_HEIGHT / 2);
        ctx.stroke();

        // Calcular nivel y wave
        const currentLevel = Math.floor((wave - 1) / 3) + 1;
        const currentWaveInLevel = ((wave - 1) % 3) + 1;

        // Obtener título de la dungeon desde la configuración de niveles
        const currentLevelConfig = levelConfig[currentLevel] || levelConfig[1]; // Fallback al nivel 1
        const dungeonTitle = currentLevelConfig
          ? currentLevelConfig.name
          : "Demon Cave";

        // Segunda sección - Level, Dungeon Title y Wave con divisores verticales
        ctx.font = "bold 9px 'Press Start 2P'";
        ctx.textAlign = "center";

        // Líneas divisoras verticales - más anchas
        ctx.strokeStyle = "#3D2914";
        ctx.lineWidth = 4; // Aumentado de 2 a 4
        ctx.beginPath();
        // Primera línea divisora (1/3)
        ctx.moveTo(designWidth / 3, HEADER_HEIGHT / 2);
        ctx.lineTo(designWidth / 3, HEADER_HEIGHT);
        // Segunda línea divisora (2/3)
        ctx.moveTo((designWidth * 2) / 3, HEADER_HEIGHT / 2);
        ctx.lineTo((designWidth * 2) / 3, HEADER_HEIGHT);
        ctx.stroke();

        // Level en la primera sección (0 a 1/3)
        const levelTextOnly = "Level ";
        const levelTextWidth = ctx.measureText(levelTextOnly).width;
        const levelNumber = currentLevel.toString();
        const levelNumberWidth = ctx.measureText(levelNumber).width;
        const levelTotalWidth = levelTextWidth + levelNumberWidth;

        // Dibujar borde marrón oscuro para "Level"
        ctx.strokeStyle = "#2A1F0F"; // Marrón oscuro para el borde
        ctx.lineWidth = 3;
        ctx.strokeText(
          levelTextOnly,
          designWidth / 6 - levelTotalWidth / 2 + levelTextWidth / 2,
          52
        );
        // Dibujar texto "Level" en amarillo
        ctx.fillStyle = "#FFD700"; // Amarillo dorado
        ctx.fillText(
          levelTextOnly,
          designWidth / 6 - levelTotalWidth / 2 + levelTextWidth / 2,
          52
        );
        ctx.fillStyle = "#3D2914"; // Número en marrón
        ctx.fillText(levelNumber, designWidth / 6 + levelTextWidth / 2, 52);

        // Título de la dungeon en la sección central (1/3 a 2/3)
        // Dibujar borde marrón oscuro
        ctx.strokeStyle = "#2A1F0F"; // Marrón oscuro para el borde
        ctx.lineWidth = 3;
        ctx.strokeText(dungeonTitle, designWidth / 2, 52);
        // Dibujar texto amarillo
        ctx.fillStyle = "#FFD700"; // Amarillo dorado
        ctx.fillText(dungeonTitle, designWidth / 2, 52);

        // Wave en la tercera sección (2/3 a 1)
        const waveTextOnly = "Wave ";
        const waveTextWidth = ctx.measureText(waveTextOnly).width;
        const waveFirstNumber = currentWaveInLevel.toString();
        const waveFirstWidth = ctx.measureText(waveFirstNumber).width;
        const waveBar = "/";
        const waveBarWidth = ctx.measureText(waveBar).width;
        const waveSecondNumber = "3";
        const waveSecondWidth = ctx.measureText(waveSecondNumber).width;
        const waveTotalWidth =
          waveTextWidth +
          waveFirstWidth +
          2 +
          waveBarWidth +
          2 +
          waveSecondWidth; // +2 píxeles de separación a cada lado de la barra

        const waveStartX = (designWidth * 5) / 6 - waveTotalWidth / 2;

        // Dibujar borde marrón oscuro para "Wave"
        ctx.strokeStyle = "#2A1F0F"; // Marrón oscuro para el borde
        ctx.lineWidth = 3;
        ctx.strokeText(waveTextOnly, waveStartX + waveTextWidth / 2, 52);
        // Dibujar texto "Wave" en amarillo
        ctx.fillStyle = "#FFD700"; // Amarillo dorado
        ctx.fillText(waveTextOnly, waveStartX + waveTextWidth / 2, 52);
        ctx.fillStyle = "#3D2914"; // Primer número en marrón
        ctx.fillText(
          waveFirstNumber,
          waveStartX + waveTextWidth + waveFirstWidth / 2,
          52
        );
        ctx.fillStyle = "#3D2914"; // Barra en marrón
        ctx.strokeStyle = "#3D2914"; // Borde marrón oscuro para la barra
        ctx.lineWidth = 1; // Línea más fina que los números
        ctx.strokeText(
          waveBar,
          waveStartX + waveTextWidth + waveFirstWidth + 1 + waveBarWidth / 2, // +1 píxel de separación del primer número
          52
        );
        ctx.fillText(
          waveBar,
          waveStartX + waveTextWidth + waveFirstWidth + 1 + waveBarWidth / 2, // +1 píxel de separación del primer número
          52
        );
        ctx.fillStyle = "#3D2914"; // Segundo número en marrón igual que el primero
        ctx.fillText(
          waveSecondNumber,
          waveStartX +
            waveTextWidth +
            waveFirstWidth +
            2 + // +1 píxel de separación antes de la barra
            waveBarWidth +
            1 + // +1 píxel de separación después de la barra
            waveSecondWidth / 2,
          52
        );

        ctx.textAlign = "left"; // Resetear alineación
      }

      function drawFooter() {
        // Limpiar completamente el área del footer para evitar interferencias
        ctx.clearRect(0, FOOTER_Y, designWidth, FOOTER_HEIGHT);

        // Fondo del footer - más oscuro y más alto
        ctx.fillStyle = "rgba(30, 20, 10, 0.9)";
        ctx.fillRect(0, FOOTER_Y, designWidth, FOOTER_HEIGHT);

        // Borde superior del footer
        ctx.strokeStyle = "#3D2914";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, FOOTER_Y);
        ctx.lineTo(designWidth, FOOTER_Y);
        ctx.stroke();

        // Dividir en 3 columnas
        const columnWidth = designWidth / 3;
        const heroOrder = ["mage", "warlock", "priest"];

        heroOrder.forEach((heroClass, heroIndex) => {
          const hero = heroes.find((h) => h.clazz === heroClass);
          if (!hero) return;

          const columnX = heroIndex * columnWidth;
          const centerX = columnX + columnWidth / 2;

          // Dibujar panel para cada héroe - usar brown para todos con menos espacio entre cards
          const panelWidth = columnWidth - 5;
          const panelHeight = 110; // Aumentado de 90 a 110
          const panelX = columnX + 2.5;
          const panelY = 525; // Ajustado de 545 a 525

          ctx.drawImage(panelBrownImg, panelX, panelY, panelWidth, panelHeight);

          // Título del héroe - siempre mismo color sin importar si está muerto
          ctx.fillStyle = "#3D2914"; // Siempre marrón oscuro
          ctx.font = "bold 8px 'Press Start 2P'";
          ctx.textAlign = "center";
          ctx.fillText(hero.clazz.toUpperCase(), centerX, 543); // Movido de 541 a 543 (+2px)

          if (hero.hp <= 0) {
            // Mostrar "DEAD" en lugar de botones
            ctx.fillStyle = "red";
            ctx.font = "bold 10px 'Press Start 2P'";
            ctx.textAlign = "center";
            ctx.fillText("DEAD", centerX, 585); // Ajustado de 595 a 585
          } else {
            const actions = Object.keys(classActions[hero.clazz]);

            // Configuración de botones - altura aumentada
            const buttonWidth = panelWidth - 14;
            const buttonHeight = 25; // Aumentado de 23 a 25
            const buttonX = panelX + 7;
            const buttonSpacing = 2; // Aumentado de 1 a 2

            // Botón habilidad principal (1 carga - 33.33%)
            const primaryAction = actions[0];
            const primaryData = classActions[hero.clazz][primaryAction];
            const buttonY1 = 550; // Ajustado de 567 a 550
            const canUsePrimary = hero.charge >= primaryData.reqCharge;

            // Usar botón beige si está activo, panel brown si está inactivo
            const primaryButtonImg = canUsePrimary
              ? buttonLongBeigeImg
              : panelBrownImg;
            ctx.drawImage(
              primaryButtonImg,
              buttonX,
              buttonY1,
              buttonWidth,
              buttonHeight
            );

            // Texto del botón principal - siempre marrón
            ctx.fillStyle = "#3D2914"; // Siempre marrón oscuro
            ctx.font = "bold 7px 'Press Start 2P'"; // Aumentado de 6px a 7px
            ctx.textAlign = "center";
            const primaryText =
              primaryData.name.charAt(0).toUpperCase() +
              primaryData.name.slice(1).toLowerCase();
            ctx.fillText(primaryText, centerX, buttonY1 + 16); // Ajustado para centrar mejor con altura 25

            // Botón habilidad secundaria (2 cargas - 66.66%)
            const secondaryAction = actions[1];
            const secondaryData = classActions[hero.clazz][secondaryAction];
            const buttonY2 = buttonY1 + buttonHeight + buttonSpacing;
            const canUseSecondary = hero.charge >= secondaryData.reqCharge;

            const secondaryButtonImg = canUseSecondary
              ? buttonLongBeigeImg
              : panelBrownImg;
            ctx.drawImage(
              secondaryButtonImg,
              buttonX,
              buttonY2,
              buttonWidth,
              buttonHeight
            );

            // Texto del botón secundario - siempre marrón
            ctx.fillStyle = "#3D2914"; // Siempre marrón oscuro
            ctx.font = "bold 7px 'Press Start 2P'"; // Aumentado de 6px a 7px
            ctx.textAlign = "center";
            const secondaryText =
              secondaryData.name.charAt(0).toUpperCase() +
              secondaryData.name.slice(1).toLowerCase();
            ctx.fillText(secondaryText, centerX, buttonY2 + 16); // Ajustado para centrar mejor con altura 25

            // Botón habilidad terciaria (3 cargas - 100%)
            const tertiaryAction = actions[2];
            const tertiaryData = classActions[hero.clazz][tertiaryAction];
            const buttonY3 = buttonY2 + buttonHeight + buttonSpacing;
            const canUseTertiary = hero.charge >= tertiaryData.reqCharge;

            const tertiaryButtonImg = canUseTertiary
              ? buttonLongBeigeImg
              : panelBrownImg;
            ctx.drawImage(
              tertiaryButtonImg,
              buttonX,
              buttonY3,
              buttonWidth,
              buttonHeight
            );

            // Texto del botón terciario - siempre marrón
            ctx.fillStyle = "#3D2914"; // Siempre marrón oscuro
            ctx.font = "bold 7px 'Press Start 2P'"; // Aumentado de 6px a 7px
            ctx.textAlign = "center";
            const tertiaryText =
              tertiaryData.name.charAt(0).toUpperCase() +
              tertiaryData.name.slice(1).toLowerCase();
            ctx.fillText(tertiaryText, centerX, buttonY3 + 16); // Ajustado para centrar mejor con altura 25
          }
        });

        ctx.textAlign = "left";
      }

      function drawMainMenu() {
        // Dibujar fondo de la pantalla de inicio sin compresión
        ctx.imageSmoothingEnabled = false; // Evitar suavizado/compresión
        ctx.drawImage(mainMenuImg, 0, 0, designWidth, designHeight);
        ctx.imageSmoothingEnabled = true; // Restaurar suavizado para otros elementos

        // Configuración de botones estilo habilidades
        const buttonWidth = 200;
        const buttonHeight = 40;
        const buttonSpacing = 20;
        const startY = 350;
        const buttonX = (designWidth - buttonWidth) / 2;

        // Botones: Start, Guide, Book
        const buttons = ["Start", "Guide", "Book"];

        buttons.forEach((buttonText, index) => {
          const buttonY = startY + index * (buttonHeight + buttonSpacing);

          // Usar estilo de botón similar a las habilidades
          ctx.drawImage(
            buttonLongBeigeImg,
            buttonX,
            buttonY,
            buttonWidth,
            buttonHeight
          );

          // Texto del botón con estilo similar a las habilidades
          ctx.fillStyle = "#3D2914"; // Marrón oscuro como los botones de habilidades
          ctx.font = "bold 19px 'Jersey 10'";
          ctx.textAlign = "center";
          ctx.fillText(buttonText, designWidth / 2, buttonY + 25);
        });

        ctx.textAlign = "left";
      }

      function drawLevelInfo() {
        const levelData = levelInfo[currentLevel];

        // Dibujar fondo de imagen para las pantallas de nivel sin compresión
        ctx.imageSmoothingEnabled = false; // Evitar suavizado/compresión
        ctx.drawImage(levelInfoBackgroundImg, 0, 0, designWidth, designHeight);
        ctx.imageSmoothingEnabled = true; // Restaurar suavizado para otros elementos

        // Oscurecer ligeramente el fondo
        ctx.fillStyle = "rgba(0, 0, 0, 0.15)";
        ctx.fillRect(0, 0, designWidth, designHeight);

        // Marco decorativo
        ctx.strokeStyle = "#D3BF8F";
        ctx.lineWidth = 2;
        ctx.strokeRect(20, 20, designWidth - 40, designHeight - 40);

        // Título del nivel
        ctx.fillStyle = "#D3BF8F";
        ctx.strokeStyle = "#000000"; // Borde negro para mejor contraste
        ctx.lineWidth = 3;
        ctx.font = "bold 36px 'Jersey 10'";
        ctx.letterSpacing = "0.1px";
        ctx.textAlign = "center";

        const levelTitle = `Level ${currentLevel}`;
        ctx.strokeText(levelTitle, designWidth / 2, 120);
        ctx.fillText(levelTitle, designWidth / 2, 120);

        // Nombre del nivel
        ctx.font = "bold 30px 'Jersey 10'";
        ctx.letterSpacing = "0.1px";
        ctx.strokeStyle = "#000000"; // Borde negro para mejor contraste
        ctx.strokeText(levelData.name, designWidth / 2, 160);
        ctx.fillText(levelData.name, designWidth / 2, 160);

        // Lore del nivel (texto envuelto) - usando Jacquard 24
        ctx.font = "18px 'Jacquard 24'";
        ctx.fillStyle = "#FFFFFF";
        ctx.strokeStyle = "#2A1F0F";
        ctx.lineWidth = 1;

        const loreLines = wrapText(levelData.lore, 280);
        const lineHeight = 32;
        const startY = 220;

        loreLines.forEach((line, index) => {
          const y = startY + index * lineHeight;
          ctx.strokeText(line, designWidth / 2, y);
          ctx.fillText(line, designWidth / 2, y);
        });

        // Botón "Explore" estilo habilidades
        const buttonY = 420;
        const buttonWidth = 200;
        const buttonHeight = 40;
        const buttonX = (designWidth - buttonWidth) / 2;

        // Usar estilo de botón similar a las habilidades
        ctx.drawImage(
          buttonLongBeigeImg,
          buttonX,
          buttonY,
          buttonWidth,
          buttonHeight
        );

        // Texto del botón con estilo similar a las habilidades
        ctx.fillStyle = "#3D2914"; // Marrón oscuro como los botones de habilidades
        ctx.font = "bold 19px 'Jersey 10'";
        ctx.textAlign = "center";
        ctx.fillText("Explore", designWidth / 2, buttonY + 25);

        ctx.textAlign = "left";
      }

      function drawLevelCompletion() {
        // Dibujar fondo del juego actual
        ctx.drawImage(currentBackgroundImg, 0, 0, designWidth, designHeight);

        // Overlay oscuro
        ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
        ctx.fillRect(0, 0, designWidth, designHeight);

        // Modal central
        const modalWidth = 300;
        const modalHeight = 290; // Aumentado para acomodar el botón Surrender
        const modalX = (designWidth - modalWidth) / 2;
        const modalY = (designHeight - modalHeight) / 2;

        // Fondo del modal
        ctx.fillStyle = "rgba(20, 20, 20, 0.95)";
        ctx.fillRect(modalX, modalY, modalWidth, modalHeight);

        // Marco del modal con el mismo estilo que las pantallas de nivel
        ctx.strokeStyle = "#D3BF8F";
        ctx.lineWidth = 2;
        ctx.strokeRect(modalX, modalY, modalWidth, modalHeight);

        // Título del modal con el mismo estilo que los títulos de nivel
        ctx.fillStyle = "#D3BF8F";
        ctx.strokeStyle = "#000000"; // Borde negro como los títulos de nivel
        ctx.lineWidth = 3;
        ctx.font = "bold 24px 'Jersey 10'";
        ctx.letterSpacing = "0.1px";
        ctx.textAlign = "center";

        let titleText;
        if (levelCompletionModal.gameCompleted) {
          titleText = "Victory!";
        } else {
          titleText = `${levelCompletionModal.boss} Defeated`;
        }

        ctx.strokeText(titleText, designWidth / 2, modalY + 50);
        ctx.fillText(titleText, designWidth / 2, modalY + 50);

        // Texto de preparación para siguiente nivel
        ctx.font = "18px 'Jacquard 24'";
        ctx.fillStyle = "#FFFFFF";
        ctx.strokeStyle = "#2A1F0F";
        ctx.lineWidth = 1;

        let readyText;
        if (levelCompletionModal.gameCompleted) {
          readyText = "You have conquered all dungeons!";
        } else {
          readyText = "Ready for the next level?";
        }

        const readyLines = wrapText(readyText, modalWidth - 40);
        readyLines.forEach((line, index) => {
          const y = modalY + 90 + index * 24;
          ctx.strokeText(line, designWidth / 2, y);
          ctx.fillText(line, designWidth / 2, y);
        });

        // Botón Continue estilo habilidades
        const continueButtonY = modalY + 150;
        const buttonWidth = 160;
        const buttonHeight = 40;
        const buttonX = (designWidth - buttonWidth) / 2;

        // Usar estilo de botón similar a las habilidades
        ctx.drawImage(
          buttonLongBeigeImg,
          buttonX,
          continueButtonY,
          buttonWidth,
          buttonHeight
        );

        // Texto del botón Continue
        ctx.fillStyle = "#3D2914"; // Marrón oscuro como los botones de habilidades
        ctx.font = "bold 17px 'Jersey 10'";
        ctx.textAlign = "center";

        let continueButtonText;
        if (levelCompletionModal.gameCompleted) {
          continueButtonText = "Main Menu";
        } else {
          continueButtonText = "Continue";
        }

        ctx.fillText(continueButtonText, designWidth / 2, continueButtonY + 25);

        // Botón Surrender (solo si no es el final del juego)
        if (!levelCompletionModal.gameCompleted) {
          const surrenderButtonY = continueButtonY + buttonHeight + 10;

          // Usar el mismo estilo de botón
          ctx.drawImage(
            buttonLongBeigeImg,
            buttonX,
            surrenderButtonY,
            buttonWidth,
            buttonHeight
          );

          // Texto del botón Surrender en rojo
          ctx.fillStyle = "#CC0000"; // Rojo para surrender
          ctx.font = "bold 17px 'Jersey 10'";
          ctx.textAlign = "center";
          ctx.fillText("Surrender", designWidth / 2, surrenderButtonY + 25);
        }

        ctx.textAlign = "left";
      }

      // Función auxiliar para envolver texto
      function wrapText(text, maxWidth) {
        const words = text.split(" ");
        const lines = [];
        let currentLine = "";

        for (let word of words) {
          const testLine = currentLine + (currentLine ? " " : "") + word;
          const metrics = ctx.measureText(testLine);

          if (metrics.width > maxWidth && currentLine) {
            lines.push(currentLine);
            currentLine = word;
          } else {
            currentLine = testLine;
          }
        }

        if (currentLine) {
          lines.push(currentLine);
        }

        return lines;
      }

      canvas.addEventListener("touchstart", handleInput);
      canvas.addEventListener("click", handleInput);

      function handleInput(e) {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        let clientX, clientY;

        if (e.type === "touchstart") {
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
        } else {
          clientX = e.clientX;
          clientY = e.clientY;
        }

        const touchX = (clientX - rect.left) * (designWidth / rect.width);
        const touchY = (clientY - rect.top) * (designHeight / rect.height);

        // Manejar clics en el menú principal
        if (state === "main_menu") {
          // Coordenadas de los nuevos botones estilo habilidades
          const buttonWidth = 200;
          const buttonHeight = 40;
          const buttonSpacing = 20;
          const startY = 350;
          const buttonX = (designWidth - buttonWidth) / 2;

          // Verificar clic en botón Start
          const startButtonY = startY;
          if (
            touchX >= buttonX &&
            touchX <= buttonX + buttonWidth &&
            touchY >= startButtonY &&
            touchY <= startButtonY + buttonHeight
          ) {
            console.log("Start button clicked");
            startGame();
            return;
          }

          // Verificar clic en botón Guide
          const guideButtonY = startY + buttonHeight + buttonSpacing;
          if (
            touchX >= buttonX &&
            touchX <= buttonX + buttonWidth &&
            touchY >= guideButtonY &&
            touchY <= guideButtonY + buttonHeight
          ) {
            console.log("Guide button clicked");
            // TODO: Abrir modal de guía
            return;
          }

          // Verificar clic en botón Book
          const bookButtonY = startY + 2 * (buttonHeight + buttonSpacing);
          if (
            touchX >= buttonX &&
            touchX <= buttonX + buttonWidth &&
            touchY >= bookButtonY &&
            touchY <= bookButtonY + buttonHeight
          ) {
            console.log("Book button clicked");
            // TODO: Abrir modal del libro de monstruos
            return;
          }
        }

        // Manejar clics en la pantalla de información de nivel
        if (state === "level_info") {
          const buttonY = 420;
          const buttonWidth = 200;
          const buttonHeight = 40;
          const buttonX = (designWidth - buttonWidth) / 2;

          // Verificar clic en botón "Enter the Dungeon"
          if (
            touchX >= buttonX &&
            touchX <= buttonX + buttonWidth &&
            touchY >= buttonY &&
            touchY <= buttonY + buttonHeight
          ) {
            console.log("Enter the Dungeon button clicked");
            state = "select_hero";
            startWave(); // Empezar la primera wave del nivel
            return;
          }
        }

        // Manejar clics en el modal de finalización de nivel
        if (state === "level_completion" && levelCompletionModal.show) {
          // Coordenadas del modal y botones
          const modalWidth = 300;
          const modalHeight = 290;
          const modalX = (designWidth - modalWidth) / 2;
          const modalY = (designHeight - modalHeight) / 2;
          const continueButtonY = modalY + 150;
          const buttonWidth = 160;
          const buttonHeight = 40;
          const buttonX = (designWidth - buttonWidth) / 2;

          // Verificar clic en el botón Continue
          if (
            touchX >= buttonX &&
            touchX <= buttonX + buttonWidth &&
            touchY >= continueButtonY &&
            touchY <= continueButtonY + buttonHeight
          ) {
            console.log("Continue button clicked");
            levelCompletionModal.show = false;

            if (levelCompletionModal.gameCompleted) {
              // Juego completado, volver al menú principal
              state = "main_menu";
              resetGame();
            } else {
              // Pasar al siguiente nivel - revivir todos los héroes con vida completa
              console.log(
                `Advancing to level ${
                  currentLevel + 1
                }! Reviving all heroes with full health.`
              );
              heroes.forEach((hero) => {
                hero.hp = hero.maxhp; // Revivir con vida completa
                hero.charge = 0; // Resetear carga
                hero.anim = "idle"; // Asegurar que estén en animación idle
                hero.frame = 0;
                // Limpiar buffs al empezar nuevo nivel
                hero.buffs = [];
                hero.debuffs = [];
              });

              currentLevel++;
              if (currentLevel <= 3) {
                state = "level_info";
              } else {
                // Juego completado (por si acaso)
                state = "main_menu";
                resetGame();
              }
            }
            return;
          }

          // Verificar clic en el botón Surrender (solo si no es el final del juego)
          if (!levelCompletionModal.gameCompleted) {
            const surrenderButtonY = continueButtonY + buttonHeight + 10;
            if (
              touchX >= buttonX &&
              touchX <= buttonX + buttonWidth &&
              touchY >= surrenderButtonY &&
              touchY <= surrenderButtonY + buttonHeight
            ) {
              console.log("Surrender button clicked");
              levelCompletionModal.show = false;

              // TODO: Enviar score al SDK aquí
              // Volver al menú principal (Game Over)
              state = "main_menu";
              resetGame();
              return;
            }
          }

          return; // No procesar otros clics durante el modal
        }

        // Footer buttons
        if (touchY >= 520 && state === "select_hero") {
          // Actualizado de 540 a 520
          const columnWidth = designWidth / 3;
          const heroOrder = ["mage", "warlock", "priest"];

          heroOrder.forEach((heroClass, heroIndex) => {
            const hero = heroes.find((h) => h.clazz === heroClass);
            if (!hero || hero.hp <= 0) return;

            const actions = Object.keys(classActions[hero.clazz]);
            const columnX = heroIndex * columnWidth;

            // Configuración de botones para coincidir con drawFooter
            const panelWidth = columnWidth - 5; // Actualizado
            const panelX = columnX + 2.5; // Actualizado
            const buttonWidth = panelWidth - 14;
            const buttonHeight = 25; // Actualizado de 23 a 25
            const buttonX = panelX + 7;
            const buttonSpacing = 2; // Actualizado de 1 a 2

            // Botón habilidad principal (1 carga)
            const primaryY = 550; // Actualizado de 567 a 550
            if (
              touchX >= buttonX &&
              touchX <= buttonX + buttonWidth &&
              touchY >= primaryY &&
              touchY <= primaryY + buttonHeight
            ) {
              const action = actions[0];
              const actionData = classActions[hero.clazz][action];
              const canUse = hero.charge >= actionData.reqCharge && hero.hp > 0;

              if (canUse) {
                selectedHero = hero;
                selectedAction = action;

                const actionType = actionData.type;
                if (actionType === "single_enemy") {
                  state = "select_target_enemy";
                  hero.anim = "selected";
                  hero.frame = 0;
                  hero.animTime = 0;
                } else if (actionType === "single_ally") {
                  state = "select_target_ally";
                  hero.anim = "selected";
                  hero.frame = 0;
                  hero.animTime = 0;
                } else if (actionType === "all_enemy") {
                  if (
                    executeAction(
                      selectedHero,
                      action,
                      enemies.filter((e) => e.hp > 0)
                    )
                  ) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                } else if (actionType === "all_ally") {
                  if (
                    executeAction(
                      selectedHero,
                      action,
                      heroes.filter((h) => h.hp > 0)
                    )
                  ) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                } else if (actionType === "self") {
                  if (executeAction(selectedHero, action, selectedHero)) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                }
              }
            }

            // Botón habilidad secundaria (2 cargas)
            const secondaryY = primaryY + buttonHeight + buttonSpacing;
            if (
              touchX >= buttonX &&
              touchX <= buttonX + buttonWidth &&
              touchY >= secondaryY &&
              touchY <= secondaryY + buttonHeight
            ) {
              const action = actions[1];
              const actionData = classActions[hero.clazz][action];
              const canUse = hero.charge >= actionData.reqCharge && hero.hp > 0;

              if (canUse) {
                selectedHero = hero;
                selectedAction = action;

                const actionType = actionData.type;
                if (actionType === "single_enemy") {
                  state = "select_target_enemy";
                  hero.anim = "selected";
                  hero.frame = 0;
                  hero.animTime = 0;
                } else if (actionType === "single_ally") {
                  state = "select_target_ally";
                  hero.anim = "selected";
                  hero.frame = 0;
                  hero.animTime = 0;
                } else if (actionType === "all_enemy") {
                  if (
                    executeAction(
                      selectedHero,
                      action,
                      enemies.filter((e) => e.hp > 0)
                    )
                  ) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                } else if (actionType === "all_ally") {
                  if (
                    executeAction(
                      selectedHero,
                      action,
                      heroes.filter((h) => h.hp > 0)
                    )
                  ) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                } else if (actionType === "self") {
                  if (executeAction(selectedHero, action, selectedHero)) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                }
              }
            }

            // Botón habilidad terciaria (3 cargas)
            const tertiaryY = secondaryY + buttonHeight + buttonSpacing;
            if (
              touchX >= buttonX &&
              touchX <= buttonX + buttonWidth &&
              touchY >= tertiaryY &&
              touchY <= tertiaryY + buttonHeight
            ) {
              const action = actions[2];
              const actionData = classActions[hero.clazz][action];
              const canUse = hero.charge >= actionData.reqCharge && hero.hp > 0;

              if (canUse) {
                selectedHero = hero;
                selectedAction = action;

                const actionType = actionData.type;
                if (actionType === "single_enemy") {
                  state = "select_target_enemy";
                  hero.anim = "selected";
                  hero.frame = 0;
                  hero.animTime = 0;
                } else if (actionType === "single_ally") {
                  state = "select_target_ally";
                  hero.anim = "selected";
                  hero.frame = 0;
                  hero.animTime = 0;
                } else if (actionType === "all_enemy") {
                  if (
                    executeAction(
                      selectedHero,
                      action,
                      enemies.filter((e) => e.hp > 0)
                    )
                  ) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                } else if (actionType === "all_ally") {
                  if (
                    executeAction(
                      selectedHero,
                      action,
                      heroes.filter((h) => h.hp > 0)
                    )
                  ) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                } else if (actionType === "self") {
                  if (executeAction(selectedHero, action, selectedHero)) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                }
              }
            }
          });
          return;
        }

        // Botón X de cerrar - nueva posición en la esquina del modal
        if (state === "select_target_enemy" || state === "select_target_ally") {
          const modalWidth = designWidth;
          const modalX = 0;
          const modalY = 75;
          const closeX = modalX + modalWidth - 15;
          const closeY = modalY + 10;

          if (
            touchX >= closeX - 10 &&
            touchX <= closeX + 10 &&
            touchY >= closeY - 10 &&
            touchY <= closeY + 10
          ) {
            state = "select_hero";
            if (selectedHero) {
              selectedHero.anim = "idle"; // Resetear animación a idle
              selectedHero.frame = 0;
              selectedHero.animTime = 0;
            }
            selectedHero = null;
            selectedAction = null;
            return;
          }
        }

        if (state === "select_hero") {
          heroes.forEach((h) => {
            if (
              h.hp > 0 &&
              Math.abs(touchX - h.posx) < 40 &&
              Math.abs(touchY - h.posy) < 40
            ) {
              // No necesitamos cambiar el estado aquí, solo usamos los botones del footer
              console.log("Hero clicked:", h.clazz);
            }
          });
        } else if (state === "select_target_enemy") {
          enemies.forEach((e) => {
            const size = e.size || 80;
            if (
              e.hp > 0 &&
              Math.abs(touchX - e.posx) < size / 2 &&
              Math.abs(touchY - e.posy) < size / 2
            ) {
              if (executeAction(selectedHero, selectedAction, e)) {
                // No resetear selectedHero aquí, se resetea en applyEffect
                state = "animate";
              }
            }
          });
        } else if (state === "select_target_ally") {
          heroes.forEach((h) => {
            if (
              Math.abs(touchX - h.posx) < 40 &&
              Math.abs(touchY - h.posy) < 40
            ) {
              if (executeAction(selectedHero, selectedAction, h)) {
                // No resetear selectedHero aquí, se resetea en applyEffect
                state = "animate";
              }
            }
          });
        }
      }

      function resetGame() {
        state = "main_menu";
        currentLevel = 1;
        wave = 0;
        score = 0;
        levelCompletionModal = { show: false, level: 0, boss: "", timer: 0 };
        selectedHero = null;
        selectedAction = null;
        heroes = [];
        enemies = [];
        hitNumbers = [];
        visualEffects = [];
      }

      Promise.all([
        new Promise((r) => (backgroundImg.onload = r)),
        new Promise((r) => (backgroundLevel2Img.onload = r)),
        new Promise((r) => (mageImg.onload = r)),
        new Promise((r) => (priestImg.onload = r)),
        new Promise((r) => (warlockImg.onload = r)),
        new Promise((r) => (demonBatIdleImg.onload = r)),
        new Promise((r) => (demonBatDeathImg.onload = r)),
        new Promise((r) => (demonBatAttackImg.onload = r)),
        new Promise((r) => (wormIdleImg.onload = r)),
        new Promise((r) => (wormDeathImg.onload = r)),
        new Promise((r) => (wormAttackImg.onload = r)),
        new Promise((r) => (bossBatIdleImg.onload = r)),
        new Promise((r) => (bossBatDeathImg.onload = r)),
        new Promise((r) => (bossBatAttackImg.onload = r)),
        new Promise((r) => (mushroomIdleImg.onload = r)),
        new Promise((r) => (mushroomDeathImg.onload = r)),
        new Promise((r) => (dreadwingIdleImg.onload = r)),
        new Promise((r) => (dreadwingDeathImg.onload = r)),
        new Promise((r) => (swampGorgonIdleImg.onload = r)),
        new Promise((r) => (swampGorgonAttackImg.onload = r)),
        new Promise((r) => (swampGorgonSpecialAttackImg.onload = r)),
        new Promise((r) => (swampGorgonDeathImg.onload = r)),
        new Promise((r) => (bloodSplatImg.onload = r)),
        new Promise((r) => (enemyImg.onload = r)),
        new Promise((r) => (goblinIdleImg.onload = r)),
        new Promise((r) => (goblinDieImg.onload = r)),
        new Promise((r) => (effectsImg.onload = r)),
        new Promise((r) => (purpleEffectsImg.onload = r)),
        new Promise((r) => (healingEffectsImg.onload = r)),
        new Promise((r) => (lightningEffectsImg.onload = r)),
        new Promise((r) => (darkBoltEffectsImg.onload = r)),
        new Promise((r) => (bloodSplatEffectsImg.onload = r)),
        new Promise((r) => (bloodStormEffectsImg.onload = r)),
        new Promise((r) => (priestSmiteEffectsImg.onload = r)),
        new Promise((r) => (priestHolyWaveEffectsImg.onload = r)),
        new Promise((r) => (priestRegrowthEffectsImg.onload = r)),
        new Promise((r) => (minotaurSmashEffectsImg.onload = r)),
        new Promise((r) => (minotaurLifeStealEffectsImg.onload = r)),
        new Promise((r) => (combustionEffectsImg.onload = r)),
        new Promise((r) => (cthuluMainEffectsImg.onload = r)),
        new Promise((r) => (cthuluSpecialEffectsImg.onload = r)),
        new Promise((r) => (healingDebuffImg.onload = r)),
        new Promise((r) => (protectionDebuffImg.onload = r)),
        new Promise((r) => (combustionDebuffImg.onload = r)),
        new Promise((r) => (bersekerDebuffImg.onload = r)),
        new Promise((r) => (poisonDebuffImg.onload = r)),
        new Promise((r) => (panelBrownImg.onload = r)),
        new Promise((r) => (buttonLongBeigeImg.onload = r)),
        new Promise((r) => (mainMenuImg.onload = r)),
      ]).then(() => {
        // Asegurar que empezamos en el menú principal
        state = "main_menu";
        requestAnimationFrame(loop);
      });
    </script>
  </body>
</html>
