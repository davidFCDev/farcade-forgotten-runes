<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width,             img: priestImg,
            animations: animationsPriest,
            frameW: 44,
            frameH: 64,
            size: 100,al-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>RPG Battle Game</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap");

      body {
        margin: 0;
        padding: 0;
        background: black;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        font-family: "Press Start 2P", monospace;
      }
      canvas {
        display: block;
        image-rendering: pixelated;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const designWidth = 360;
      const designHeight = 640;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = designWidth * dpr;
      canvas.height = designHeight * dpr;
      ctx.scale(dpr, dpr);
      canvas.style.width = designWidth + "px";
      canvas.style.height = designHeight + "px";

      // Load images
      const backgroundImg = new Image();
      backgroundImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ChatGPT%20Image%2010%20ago%202025%2C%2001_31_21-11GclhftpsCG06vNEd4ri4gVBVUY8o.png?aymA";

      // Background para nivel 2
      const backgroundLevel2Img = new Image();
      backgroundLevel2Img.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/red_dunes-elmz1XktqRUANSNvvj8jYAoxXZsMkt.png?t9TH";

      // Background dinámico que cambia según el nivel
      let currentBackgroundImg = backgroundLevel2Img; // TEMPORAL: Red Dunes ahora es nivel 1
      const mageImg = new Image();
      mageImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/mage-TnWuIwL8nfQgfspUHLdQb117UZpBR3.png?ddSR";
      const priestImg = new Image();
      priestImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/priest-DZKVrCXOeqMuQCe0Rid7DctIkoe4m0.png?XbMV";
      const warlockImg = new Image();
      warlockImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/warlock-ufYIrOZWd5mtgudqtQ8Yd34rteekHt.png?6IzB";

      // Enemy sprites - Demon Bat (Level 1)
      const demonBatIdleImg = new Image();
      demonBatIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/IDLE-V90NoEl8WQxdfu93X92hoipQtHfW7y.png?O0Ak";
      const demonBatDeathImg = new Image();
      demonBatDeathImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/DEATH-r9w4VgFSi93NjgHhRKFPjbBK3x4XYS.png?VLXN";
      const demonBatAttackImg = new Image();
      demonBatAttackImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ATTACK-ZCinJufJA25jik8Qm2R3DSZEdfIHez.png?iCFX";

      // Enemy sprites - Worm (Level 2)
      const wormIdleImg = new Image();
      wormIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/worm_idle-vJDVrN0IWXKWwxGqO3oaeE5VfdeiHx.png?rwdu";
      const wormDeathImg = new Image();
      wormDeathImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/worm_dead-fjt1PKqQPfa4Ql1iEJn92utXSHg48b.png?8dpt";
      const wormAttackImg = new Image();
      wormAttackImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/worm_attack-Lh6J61U6HqA0OHAbOC558yTFytcB58.png?yXF1";

      // Boss Demon Slime sprites (Level 2 Boss) - Todas las animaciones en un solo sprite sheet
      const demonSlimeAllStatesImg = new Image();
      demonSlimeAllStatesImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/demon_boss-OYjrZFu0tNJkaaJug19JpAyTtf7u0m.png?QqaU";

      // Boss Bat sprites (Level 1 Boss)
      const bossBatIdleImg = new Image();
      bossBatIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/IDLE_BOSS_1-N75RUTJp8bkxCSPZuvUWDye1KogjOS.png?C7Ns";
      const bossBatDeathImg = new Image();
      bossBatDeathImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/DEATH_BOSS_1-gjjAV8gTr6DBjZQ94xcwKAM8y63w2h.png?2Akf";
      const bossBatAttackImg = new Image();
      bossBatAttackImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ATTACK_BOSS_1-FArHbCZ2DrOKLJj2YyFvpSztZ5Ryq9.png?SSuQ";

      // Boss special ability effect
      const bloodSplatImg = new Image();
      bloodSplatImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Blood%20Splat-0zg8BGvPxZDBDQds5ZQiTgB7o5ebiC.png?59te";

      // Mantener sprites antiguos para compatibilidad temporal
      const enemyImg = new Image();
      enemyImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/beast_gigasChad-jHhAfiqtBGKuiIHRZJ0MkWs0W5uFQ5.png?9LBT";
      const goblinIdleImg = new Image();
      goblinIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/IDLE-V90NoEl8WQxdfu93X92hoipQtHfW7y.png?O0Ak";
      const goblinDieImg = new Image();
      goblinDieImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/DEATH-r9w4VgFSi93NjgHhRKFPjbBK3x4XYS.png?VLXN";

      // Sprites de efectos de habilidades
      const effectsImg = new Image();
      effectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Red%20Effect%20Bullet%20Impact%20Explosion%2032x32-NnvGEsfH13xUZuEqmJAXk2oelYwGoV.png?b5e9";

      // Sprites de efectos púrpura para warlock
      const purpleEffectsImg = new Image();
      purpleEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Purple%20Effect%20Bullet%20Impact%20Explosion%2032x32-tBftQaSwItblEIfJStK8fGzQZEaFvQ.png?7m6v";

      // Sprite de efectos de curación
      const healingEffectsImg = new Image();
      healingEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Regen-IsFeOv1fkkRBrdZ1wZqoyhE5DrXPmz.png?22AH";

      // Sprite de efectos de rayo para Smite
      const lightningEffectsImg = new Image();
      lightningEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Lightning-JDFXQsYo47LoZYiuRiYJRnGOxeYgZc.png?8HcK";

      // Sprite de efectos de Dark Bolt para Inmolation
      const darkBoltEffectsImg = new Image();
      darkBoltEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Dark-Bolt-XsHZlOlUknjRLKGCm3oDIfLlJimYCf.png?Lpbv";

      // Sprite de efectos de Blood Splat para Boss Bat (habilidad principal - un solo aliado)
      const bloodSplatEffectsImg = new Image();
      bloodSplatEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/sprite-sheet2-fpBxr82a3zc37rRAF6S573qRmIXtGU.png?ANvP";

      // Sprite de efectos de Blood Storm para Boss Bat (habilidad especial - todos los aliados)
      const bloodStormEffectsImg = new Image();
      bloodStormEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/sprite-sheet-F3tkTJhh68R3ZU2T2GrvwFXwEamfaf.png?pJmM";

      // Sprites mejorados para habilidades del Priest
      const priestSmiteEffectsImg = new Image();
      priestSmiteEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/smite-Bjk86Soi2Gf9vFJBLWIvzPGFBp44Hf.png?WXvo";

      const priestHolyWaveEffectsImg = new Image();
      priestHolyWaveEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/heal-3Xw84tzIf6iA8iM9A7ATJFLffNucdb.png?VXbc";

      const priestRegrowthEffectsImg = new Image();
      priestRegrowthEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/regrowth-jwXtVqqCJVlVmtGbVon46zD1y7zmbJ.png?YYsp";

      // Configuración de niveles - ORDEN TEMPORAL CAMBIADO PARA TESTING
      const levelConfig = {
        1: {
          name: "Red Dunes",
          background:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/red_dunes-elmz1XktqRUANSNvvj8jYAoxXZsMkt.png?t9TH",
          enemies: {
            normal: {
              name: "Worm",
              hp: 100, // Un poco más que Demon Bat
              sprites: {
                idle: wormIdleImg,
                death: wormDeathImg,
                attack: wormAttackImg,
              },
              frameWidth: 90,
              frameHeight: 90,
              idleFrames: 9,
              deathFrames: 8,
              attackFrames: 16,
              chargeSpeed: 22, // Ligeramente más rápido que nivel 1
              size: 110, // Tamaño específico para el Worm
            },
            boss: {
              name: "Demon Slime",
              hp: 280, // Más vida que Boss Bat
              sprites: {
                idle: demonSlimeAllStatesImg, // Usar el sprite sheet completo
                death: demonSlimeAllStatesImg,
                attack: demonSlimeAllStatesImg,
              },
              frameWidth: 150,
              frameHeight: 83,
              idleFrames: 6,
              deathFrames: 22,
              attackFrames: 15,
              chargeSpeed: 26, // 20% más rápido que Worm normal
              size: 180, // Tamaño específico más grande para el Boss Demon Slime
              specialAttackCounter: 3, // Contador para ataque especial
              mainAbility: "slime_attack", // Ataque básico a un héroe aleatorio
              specialAbility: "poison_cloud", // Debuff de veneno a todos los aliados
            },
          },
        },
        2: {
          name: "Demon Cave",
          background:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ChatGPT%20Image%2010%20ago%202025%2C%2001_31_21-11GclhftpsCG06vNEd4ri4gVBVUY8o.png?aymA",
          enemies: {
            normal: {
              name: "Demon Bat",
              hp: 80,
              sprites: {
                idle: demonBatIdleImg,
                death: demonBatDeathImg,
                attack: demonBatAttackImg,
              },
              frameWidth: 81,
              frameHeight: 71,
              idleFrames: 4,
              deathFrames: 6,
              attackFrames: 8,
              chargeSpeed: 20,
              size: 80, // Tamaño específico para Demon Bat
            },
            boss: {
              name: "Boss Bat",
              hp: 200,
              sprites: {
                idle: bossBatIdleImg,
                death: bossBatDeathImg,
                attack: bossBatAttackImg,
              },
              frameWidth: 81,
              frameHeight: 71,
              idleFrames: 4,
              deathFrames: 6,
              attackFrames: 8,
              chargeSpeed: 24, // 20% más rápido
              size: 120, // Tamaño específico para Boss Bat
              specialAttackCounter: 3, // Contador para ataque especial
              mainAbility: "blood_splat", // Habilidad principal (un solo aliado aleatorio)
              specialAbility: "blood_storm", // Habilidad especial (todos los aliados)
            },
          },
        },
        // Aquí se añadirán más niveles en el futuro
      };

      // UI Elements - Solo los elementos que se usan
      const panelBrownImg = new Image();
      panelBrownImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/panel_brown-49f4SM1AoKwCYlEq9piZiXmfxdEC0G.png?ZpjN";

      const buttonLongBeigeImg = new Image();
      buttonLongBeigeImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/buttonLong_beige-AkYz3mfJrwayHOsnKfj3J2cFcEajGT.png?vtgY";

      // Animations - actualizadas con nuevas habilidades
      const animationsMage = {
        selected: { row: 0, frames: 6, duration: 0.6 },
        idle: { row: 1, frames: 6, duration: 0.6 },
        fireblast: { row: 2, frames: 7, duration: 1 },
        combustion: { row: 3, frames: 7, duration: 1 },
        inferno: { row: 4, frames: 6, duration: 1 },
      };
      const animationsPriest = {
        selected: { row: 0, frames: 6, duration: 0.6 },
        idle: { row: 1, frames: 6, duration: 0.6 },
        holywave: { row: 2, frames: 7, duration: 1 },
        smite: { row: 3, frames: 6, duration: 1 },
        regrowth: { row: 4, frames: 6, duration: 1 },
      };
      const animationsWarlock = {
        selected: { row: 0, frames: 6, duration: 0.6 },
        idle: { row: 1, frames: 6, duration: 0.6 },
        darkslash: { row: 2, frames: 7, duration: 1 },
        agony: { row: 3, frames: 6, duration: 0.5 }, // Instantáneo
        inmolation: { row: 4, frames: 7, duration: 1 },
      };

      let score = 0;
      let wave = 0;
      let heroes = [];
      let enemies = [];
      let state = "select_hero";
      let selectedHero = null;
      let selectedAction = null;
      let turnPhase = "player";
      let currentEnemyIndex = 0;
      let slashStreak = 0;
      let currentTime = 0;
      let hitNumbers = []; // Array para almacenar los números de golpe flotantes
      let visualEffects = []; // Array para efectos visuales especiales

      function init() {
        heroes = [
          {
            clazz: "mage",
            hp: 100,
            maxhp: 100,
            def: 3, // Poca defensa
            charge: 0, // Start empty
            maxcharge: 100,
            posx: 80, // Posición original
            posy: 430, // Movido 20px arriba (era 450)
            anim: "idle",
            frame: 0,
            animTime: 0,
            acted: false,
            buffs: [],
            targets: [],
            action: null,
            img: mageImg,
            animations: animationsMage,
            frameW: 100, // Nuevo tamaño de frame
            frameH: 100, // Nuevo tamaño de frame
            size: 100,
          },
          {
            clazz: "warlock",
            hp: 100,
            maxhp: 100,
            def: 15, // Buena defensa
            charge: 0, // Start empty
            maxcharge: 100,
            posx: 180, // Posición original
            posy: 360, // Movido 20px arriba (era 380)
            anim: "idle",
            frame: 0,
            animTime: 0,
            acted: false,
            buffs: [],
            targets: [],
            action: null,
            img: warlockImg,
            animations: animationsWarlock,
            frameW: 100, // Nuevo tamaño de frame
            frameH: 100, // Nuevo tamaño de frame
            size: 100,
          },
          {
            clazz: "priest",
            hp: 100,
            maxhp: 100,
            def: 3, // Poca defensa
            charge: 0, // Start empty
            maxcharge: 100,
            posx: 280, // Posición original
            posy: 430, // Movido 20px arriba (era 450)
            anim: "idle",
            frame: 0,
            animTime: 0,
            acted: false,
            buffs: [],
            targets: [],
            action: null,
            img: priestImg,
            animations: animationsPriest,
            frameW: 100, // Nuevo tamaño de frame
            frameH: 100, // Nuevo tamaño de frame
            size: 100,
          },
        ];
        enemies = [];
        score = 0;
        wave = 0;
        state = "select_hero";
        turnPhase = "player";
        slashStreak = 0;
        currentBackgroundImg = backgroundLevel2Img; // TEMPORAL: Red Dunes ahora es nivel 1
        startWave();
      }

      function startWave() {
        console.log("Starting wave", wave + 1);

        // Verificar si empezamos un nuevo nivel (cada 3 waves)
        const currentLevel = Math.floor((wave - 1) / 3) + 1; // wave-1 porque incrementamos wave al final
        const nextLevel = Math.floor(wave / 3) + 1;

        // Actualizar background según el nivel actual - ORDEN TEMPORAL CAMBIADO
        const currentLevelForBackground = Math.floor(wave / 3) + 1;
        if (currentLevelForBackground === 1) {
          currentBackgroundImg = backgroundLevel2Img; // Red Dunes ahora es nivel 1
        } else if (currentLevelForBackground === 2) {
          currentBackgroundImg = backgroundImg; // Demon Cave ahora es nivel 2
        }
        // Se pueden agregar más niveles aquí en el futuro

        // Solo revivir héroes cuando se cambia de nivel completo (nunca en el mismo nivel)
        // wave 1,2,3 = nivel 1; wave 4,5,6 = nivel 2; etc.
        if (nextLevel > currentLevel && wave % 3 === 1) {
          console.log(
            `Starting new level ${nextLevel}! Reviving all heroes with full health.`
          );
          heroes.forEach((hero) => {
            hero.hp = hero.maxhp;
            hero.charge = 0; // Resetear carga también
            hero.anim = "idle"; // Asegurar que estén en animación idle
            hero.frame = 0;
            // Limpiar buffs al empezar nuevo nivel
            hero.buffs = [];
          });
        } else {
          console.log(
            `Continuing level ${currentLevel}, wave ${
              ((wave - 1) % 3) + 1
            }/3 - heroes maintain their current state (dead heroes stay dead)`
          );
        }

        let enemyPositions = [];
        const currentLevelConfig =
          levelConfig[Math.floor(wave / 3) + 1] || levelConfig[1]; // Fallback al nivel 1
        const normalHP = currentLevelConfig.enemies.normal.hp;
        const bossHP = currentLevelConfig.enemies.boss.hp;

        if (wave % 3 === 0) {
          // 2 enemies
          enemies = [
            createEnemy(100, 200, normalHP, "normal"),
            createEnemy(260, 200, normalHP, "normal"),
          ];
        } else if (wave % 3 === 1) {
          // 3 enemies
          enemies = [
            createEnemy(80, 200, normalHP, "normal"),
            createEnemy(180, 200, normalHP, "normal"),
            createEnemy(280, 200, normalHP, "normal"),
          ];
        } else {
          // boss
          enemies = [createEnemy(180, 200, bossHP, "boss")];
        }
        wave++;
        console.log("Wave", wave, "started with", enemies.length, "enemies");
        heroes.forEach((h) => (h.acted = false));
      }

      function createEnemy(x, y, hp, type) {
        const currentLevel = Math.floor(wave / 3) + 1;
        const currentLevelConfig = levelConfig[currentLevel] || levelConfig[1]; // Fallback al nivel 1
        const enemyConfig =
          type === "boss"
            ? currentLevelConfig.enemies.boss
            : currentLevelConfig.enemies.normal;

        return {
          hp,
          maxhp: hp,
          charge: 0,
          maxcharge: 100,
          posx: x,
          posy: y,
          type,
          animTime: 0,
          def: type === "boss" ? 10 : 5,
          size: enemyConfig.size || (type === "boss" ? 140 : 110), // Usar tamaño específico o fallback
          anim: "idle",
          frame: 0,
          animStartTime: 0,
          isDying: false,
          deathAnimComplete: false,
          name: enemyConfig.name,
          sprites: enemyConfig.sprites,
          frameWidth: enemyConfig.frameWidth,
          frameHeight: enemyConfig.frameHeight,
          idleFrames: enemyConfig.idleFrames,
          deathFrames: enemyConfig.deathFrames,
          attackFrames: enemyConfig.attackFrames,
          chargeSpeed: enemyConfig.chargeSpeed,
          // Propiedades específicas del boss
          specialAttackCounter:
            type === "boss" ? enemyConfig.specialAttackCounter : null,
          specialAbility: type === "boss" ? enemyConfig.specialAbility : null,
          attacksUntilSpecial:
            type === "boss" ? enemyConfig.specialAttackCounter : null,
        };
      }

      // Función para calcular si un golpe es crítico
      function calculateCritical(baseDamage, customCritChance = 15) {
        const criticalChance = customCritChance / 100; // Convertir porcentaje a decimal
        const isCritical = Math.random() < criticalChance;
        const finalDamage = isCritical
          ? Math.floor(baseDamage * 1.5)
          : baseDamage;

        return {
          damage: finalDamage,
          isCritical: isCritical,
        };
      }

      const classActions = {
        mage: {
          fireblast: {
            name: "Fireblast",
            reqCharge: 33.33, // 1 carga (33.33% de 100%)
            type: "single_enemy",
            damage: 35,
            anim: "fireblast",
          },
          combustion: {
            name: "Combustion",
            reqCharge: 66.66, // 2 cargas (66.66% de 100%)
            type: "self",
            critBonus: 50, // Aumenta críticos 50%
            duration: 30, // 30 segundos
            anim: "combustion",
          },
          inferno: {
            name: "Inferno",
            reqCharge: 100, // 3 cargas (100%)
            type: "all_enemy",
            damage: 500, // Menos que fireblast pero a todos
            anim: "inferno",
          },
        },
        priest: {
          holywave: {
            name: "Holy Wave",
            reqCharge: 33.33, // 1 carga
            type: "single_ally",
            heal: 45,
            anim: "holywave",
          },
          smite: {
            name: "Smite",
            reqCharge: 66.66, // 2 cargas
            type: "single_enemy",
            damage: 20, // Poco daño
            anim: "smite",
          },
          regrowth: {
            name: "Regrowth",
            reqCharge: 100, // 3 cargas
            type: "all_ally",
            heal: 8, // Ticks pequeños
            ticks: 3, // 3 segundos
            anim: "regrowth",
          },
        },
        warlock: {
          darkslash: {
            name: "Dark Slash",
            reqCharge: 33.33, // 1 carga
            type: "single_enemy",
            damage: 25,
            anim: "darkslash",
          },
          agony: {
            name: "Agony",
            reqCharge: 66.66, // 2 cargas
            type: "all_ally",
            defBonus: 15, // Buena defensa
            damageReflect: 10, // 10% reflejo
            duration: 20, // 20 segundos
            anim: "agony",
          },
          inmolation: {
            name: "Inmolation",
            reqCharge: 100, // 3 cargas
            type: "all_enemy",
            damage: 45, // Mucho daño
            selfDamage: 60, // 60% de su vida
            anim: "inmolation",
          },
        },
      };

      function checkGameOver() {
        if (heroes.every((h) => h.hp <= 0)) {
          alert("Game Over! Score: " + score);
          resetGame();
          return true;
        }
        return false;
      }

      function checkWaveCleared() {
        if (enemies.every((e) => e.hp <= 0)) {
          // Verificar si todos los enemigos han completado su animación de muerte
          const allDeathAnimationsComplete = enemies.every(
            (e) => e.hp > 0 || e.deathAnimComplete
          );

          if (allDeathAnimationsComplete) {
            console.log("Wave cleared! Starting next wave...");

            // Bonificación por enemigos eliminados
            enemies.forEach((e) => {
              score += e.type === "boss" ? 10 : 1;
            });

            // Bonificación extra por wave completada
            const waveBonus = wave * 50; // 50 puntos por wave, escalando
            score += waveBonus;
            console.log(`Wave ${wave} completed! Bonus: ${waveBonus} points`);

            startWave();
            return true;
          }
        }
        return false;
      }

      // NOTA: advanceTurn() removida - ya no se usa sistema de turnos

      function executeAction(hero, action, targets) {
        const actionData = classActions[hero.clazz][action];

        // Check if we have enough charge before executing
        let requiredCharge = actionData.reqCharge;

        if (hero.charge < requiredCharge) {
          console.log(
            "Not enough charge for action:",
            action,
            "Required:",
            requiredCharge,
            "Current:",
            hero.charge
          );
          return false;
        }

        // Always reset charge to 0 when using any ability
        hero.charge = 0;

        hero.anim = actionData.anim;
        hero.frame = 0;
        hero.animTime = 0;
        // Limpiar targets anteriores antes de asignar nuevos
        hero.targets = [];
        hero.targets = Array.isArray(targets) ? targets : [targets];
        hero.action = action;
        state = "animate";

        console.log(
          "Executing action:",
          action,
          "for hero:",
          hero.clazz,
          "with targets:",
          hero.targets.length,
          "charge reset to 0"
        );
        return true;
      }

      function applyEffect(hero, action, targets) {
        // Validar que tenemos todos los datos necesarios
        if (
          !action ||
          !hero.clazz ||
          !classActions[hero.clazz] ||
          !classActions[hero.clazz][action]
        ) {
          console.error("ERROR: Datos inválidos para applyEffect", {
            hero: hero.clazz,
            action: action,
            hasClassActions: !!classActions[hero.clazz],
            hasAction: !!(
              classActions[hero.clazz] && classActions[hero.clazz][action]
            ),
          });
          return;
        }

        const actionData = classActions[hero.clazz][action];
        console.log(
          "Applying effect:",
          action,
          "from hero:",
          hero.clazz,
          "to targets:",
          targets.length,
          "action type:",
          actionData.type
        );

        // Validación adicional para prevenir contaminación de targets
        if (actionData.type.includes("enemy") && targets.some((t) => t.clazz)) {
          console.error(
            "ERROR: Acción de enemigo aplicada a héroes!",
            action,
            targets
          );
          return;
        }
        if (actionData.type.includes("ally") && targets.some((t) => !t.clazz)) {
          console.error(
            "ERROR: Acción de aliado aplicada a enemigos!",
            action,
            targets
          );
          return;
        }

        // Nuevas mecánicas específicas por habilidad
        if (action === "combustion") {
          // Combustion: buff de críticos al mago
          hero.buffs.push({
            type: "combustion",
            endTime: currentTime + actionData.duration,
            critBonus: actionData.critBonus,
          });
          console.log(
            "Combustion buff applied to",
            hero.clazz,
            "for",
            actionData.duration,
            "seconds"
          );
          // Agregar efecto visual de combustion en el propio mago
          addCombustionEffect(hero.posx, hero.posy);
        } else if (action === "agony") {
          // Agony: protección y reflejo de daño a todos los aliados
          targets.forEach((target) => {
            if (target.hp > 0) {
              target.buffs.push({
                type: "agony",
                endTime: currentTime + actionData.duration,
                defBonus: actionData.defBonus,
                damageReflect: actionData.damageReflect,
              });
              console.log("Agony buff applied to", target.clazz);
              addProtectionEffect([target]);
            }
          });
        } else if (action === "inmolation") {
          // Inmolation: daño a todos los enemigos + auto-daño al warlock
          targets.forEach((target) => {
            if (target.hp > 0) {
              let damage = actionData.damage;
              const criticalResult = calculateCritical(damage);
              const finalDamage = criticalResult.damage;
              const isCritical = criticalResult.isCritical;
              const effectiveDamage = Math.max(1, finalDamage - target.def);

              target.anim = "hurt";
              target.frame = 0;
              target.animStartTime = currentTime;
              target.hp = Math.max(0, target.hp - effectiveDamage);

              // Sumar puntos por daño hecho a enemigos
              score += effectiveDamage;

              if (target.hp <= 0) {
                target.isDying = true;
                target.anim = "die";
                target.frame = 0;
                target.animStartTime = currentTime;
              }

              showHitNumber(
                target.posx,
                target.posy - 20,
                effectiveDamage,
                false,
                isCritical
              );
              clearEffectsByTypeAndPosition(
                "inmolation",
                target.posx,
                target.posy
              );
              addInmolationEffect(target.posx, target.posy);
            }
          });

          // Auto-daño al warlock (60% de su vida)
          const selfDamage = Math.floor(
            hero.maxhp * (actionData.selfDamage / 100)
          );
          hero.hp = Math.max(0, hero.hp - selfDamage); // Puede autodestruirse
          showHitNumber(hero.posx, hero.posy - 20, selfDamage, false, false);
          console.log("Inmolation self-damage:", selfDamage, "to", hero.clazz);
        } else if (action === "regrowth") {
          // Regrowth: curación por ticks a todos los aliados
          targets.forEach((target) => {
            if (target.hp > 0) {
              target.buffs.push({
                type: "regrowth",
                endTime: currentTime + actionData.ticks,
                nextTick: currentTime + 1,
                heal: actionData.heal,
              });
              playHealingAnim(target, "regrowth");
              console.log("Regrowth applied to", target.clazz);
            }
          });
        } else if (actionData.type.includes("enemy")) {
          // Habilidades de daño normales
          targets.forEach((target) => {
            if (target.hp > 0) {
              let damage = actionData.damage;

              // Aplicar buff de combustion si existe
              let criticalChance = 15; // Base 15%
              if (hero.buffs.some((b) => b.type === "combustion")) {
                criticalChance += hero.buffs.find(
                  (b) => b.type === "combustion"
                ).critBonus;
              }

              const criticalResult = calculateCritical(damage, criticalChance);
              const finalDamage = criticalResult.damage;
              const isCritical = criticalResult.isCritical;
              const effectiveDamage = Math.max(1, finalDamage - target.def);

              target.anim = "hurt";
              target.frame = 0;
              target.animStartTime = currentTime;
              target.hp = Math.max(0, target.hp - effectiveDamage);

              // Sumar puntos por daño hecho a enemigos
              score += effectiveDamage;

              if (target.hp <= 0) {
                target.isDying = true;
                target.anim = "die";
                target.frame = 0;
                target.animStartTime = currentTime;
              }

              showHitNumber(
                target.posx,
                target.posy - 20,
                effectiveDamage,
                false,
                isCritical
              );

              // Efectos visuales específicos por habilidad
              if (action === "fireblast") {
                clearEffectsByTypeAndPosition(
                  "fireblast",
                  target.posx,
                  target.posy
                );
                addFireblastEffect(target.posx, target.posy);
              } else if (action === "inferno") {
                clearEffectsByTypeAndPosition(
                  "conflagration",
                  target.posx,
                  target.posy
                );
                addConflagrationEffect(target.posx, target.posy);
              } else if (action === "darkslash") {
                clearEffectsByTypeAndPosition(
                  "slash",
                  target.posx,
                  target.posy
                );
                addSlashEffect(target.posx, target.posy);
              } else if (action === "smite") {
                clearEffectsByTypeAndPosition(
                  "smite",
                  target.posx,
                  target.posy
                );
                addSmiteEffect(target.posx, target.posy);
              }
            }
          });
        } else if (
          actionData.type.includes("ally") ||
          actionData.type === "self"
        ) {
          // Habilidades de curación normales
          targets.forEach((target) => {
            if (target.hp > 0 && actionData.heal) {
              target.hp = Math.min(target.maxhp, target.hp + actionData.heal);

              // Determinar tipo de curación para el efecto visual correcto
              const healType = action === "holywave" ? "holywave" : "healing";
              playHealingAnim(target, healType);

              showHitNumber(
                target.posx,
                target.posy - 20,
                actionData.heal,
                true
              );
              console.log(
                "Healing",
                actionData.heal,
                "to",
                target.clazz || "target"
              );
            }
          });
        }

        checkWaveCleared();
        checkGameOver();

        // Resetear selección después de aplicar efectos
        selectedHero = null;
        selectedAction = null;
      }

      function playHealingAnim(target, healType = "healing") {
        // En lugar de cambiar la animación del héroe, crear un efecto visual separado
        console.log(
          "Creando efecto visual de curación para",
          target.clazz,
          "tipo:",
          healType
        );

        if (healType === "holywave") {
          addHolyWaveEffect(target.posx, target.posy);
        } else if (healType === "regrowth") {
          addRegrowthEffect(target.posx, target.posy);
        } else {
          addHealingEffect(target.posx, target.posy);
        }
      }

      function showHitNumber(
        x,
        y,
        value,
        isHealing = false,
        isCritical = false
      ) {
        hitNumbers.push({
          x: x,
          y: y,
          value: value,
          isHealing: isHealing,
          isCritical: isCritical,
          opacity: 1.0,
          startTime: currentTime,
          duration: 1.5, // duración en segundos
        });
      }

      function clearEffectsByTypeAndPosition(effectType, x, y) {
        // Eliminar solo los efectos del tipo especificado en la posición específica (mismo enemigo)
        const initialCount = visualEffects.length;
        for (let i = visualEffects.length - 1; i >= 0; i--) {
          const effect = visualEffects[i];
          if (
            effect.type === effectType &&
            Math.abs(effect.x - x) < 10 &&
            Math.abs(effect.y - y) < 10
          ) {
            visualEffects.splice(i, 1);
          }
        }
        const removedCount = initialCount - visualEffects.length;
        if (removedCount > 0) {
          console.log(
            `Eliminados ${removedCount} efectos de tipo ${effectType} en posición ${x},${y}`
          );
        }
      }

      function addFireblastEffect(x, y) {
        visualEffects.push({
          type: "fireblast",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.4, // Duración original
          frame: 0,
          frameCount: 4,
          frameWidth: 32,
          frameHeight: 32,
          size: 64, // Tamaño más grande
          repeat: 0, // Contador de repeticiones
          maxRepeats: 2, // Se repetirá 2 veces (total 3 reproducciones)
          endTime: currentTime + 0.4 * 3, // Tiempo absoluto de finalización (3 repeticiones)
        });
      }

      function addConflagrationEffect(x, y) {
        visualEffects.push({
          type: "conflagration",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.4, // Duración original
          frame: 0,
          frameCount: 4,
          frameWidth: 32,
          frameHeight: 32,
          size: 64, // Tamaño más grande
          repeat: 0, // Contador de repeticiones
          maxRepeats: 2, // Se repetirá 2 veces (total 3 reproducciones)
          endTime: currentTime + 0.4 * 3, // Tiempo absoluto de finalización (3 repeticiones)
        });
      }

      function addSlashEffect(x, y) {
        console.log("Añadiendo efecto slash en posición", x, y);
        visualEffects.push({
          type: "slash",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.4, // Duración original
          frame: 0,
          frameCount: 4, // Frames 17, 18, 19, 20
          frameWidth: 32,
          frameHeight: 32,
          size: 64, // Tamaño más grande
          repeat: 0, // Contador de repeticiones
          maxRepeats: 2, // Se repetirá 2 veces (total 3 reproducciones)
          endTime: currentTime + 0.4 * 3, // Tiempo absoluto de finalización (3 repeticiones)
        });
      }

      function addHealingEffect(x, y) {
        console.log("Añadiendo efecto visual de curación en posición", x, y);
        visualEffects.push({
          type: "healing",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.0, // Duración más larga para aprovechar todos los frames
          frame: 0,
          frameCount: 7, // 7 frames totales (5 en primera fila + 2 en segunda)
          frameWidth: 96, // Nuevo tamaño de frame
          frameHeight: 96, // Nuevo tamaño de frame
          size: 120, // Tamaño renderizado más grande para mejor visibilidad
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 1.0,
        });
      }

      function addHolyWaveEffect(x, y) {
        console.log("Añadiendo efecto visual de Holy Wave en posición", x, y);
        visualEffects.push({
          type: "holy_wave",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.8, // Duración reducida para animación más fluida (era 1.6)
          frame: 0,
          frameCount: 11, // 11 frames en total (3 filas: 5+5+1)
          frameWidth: 128, // 640px / 5 frames por fila
          frameHeight: 128, // 384px / 3 filas
          size: 130, // Tamaño más grande para mejor visibilidad
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 0.8,
        });
      }

      function addRegrowthEffect(x, y) {
        console.log("Añadiendo efecto visual de Regrowth en posición", x, y);
        visualEffects.push({
          type: "regrowth_new",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.9, // Duración reducida para animación más fluida (era 1.8)
          frame: 0,
          frameCount: 12, // 12 frames en total (3 filas: 5+5+2)
          frameWidth: 128, // 640px / 5 frames por fila
          frameHeight: 128, // 384px / 3 filas
          size: 125, // Tamaño apropiado para regeneración
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 0.9,
        });
      }

      function addCombustionEffect(x, y) {
        console.log("Añadiendo efecto visual de combustion en posición", x, y);
        visualEffects.push({
          type: "combustion",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.8, // Duración para 4 frames
          frame: 0,
          frameCount: 4, // Frames 11, 12, 13, 14
          frameWidth: 32,
          frameHeight: 32,
          size: 80, // Tamaño apropiado para el mago
          repeat: 0,
          maxRepeats: 1, // Se repite una vez (total 2 reproducciones)
          endTime: currentTime + 0.8 * 2, // Tiempo absoluto de finalización
        });
      }

      function addSmiteEffect(x, y) {
        console.log("Añadiendo efecto visual de smite en posición", x, y);
        visualEffects.push({
          type: "smite",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.75, // Duración reducida para animación más fluida (era 1.5)
          frame: 0,
          frameCount: 10, // 10 frames en total (2 filas de 5 cada una)
          frameWidth: 128, // 640px / 5 frames por fila (asumiendo 640px total)
          frameHeight: 128, // 256px / 2 filas (asumiendo 256px total)
          size: 120, // Tamaño más grande para mejor impacto visual
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 0.75,
        });
      }

      function addInmolationEffect(x, y) {
        console.log("Añadiendo efecto visual de inmolation en posición", x, y);
        visualEffects.push({
          type: "inmolation",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.1, // Duración para 11 frames
          frame: 0,
          frameCount: 11, // 11 frames de dark bolt
          frameWidth: 64,
          frameHeight: 88,
          size: 90, // Tamaño apropiado para el efecto de dark bolt
          repeat: 0,
          maxRepeats: 1, // Se repite una vez (total 2 reproducciones)
          endTime: currentTime + 1.1 * 2, // Tiempo absoluto de finalización
        });
      }

      function addBloodSplatEffect(x, y) {
        console.log("Añadiendo efecto visual de Blood Splat en posición", x, y);
        visualEffects.push({
          type: "blood_splat",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.5, // Duración aumentada para 10 frames
          frame: 0,
          frameCount: 10, // 10 frames en total (2 filas de 5 cada una)
          frameWidth: 128, // 640px / 5 frames por fila
          frameHeight: 128, // 256px / 2 filas
          size: 140, // Tamaño más grande para mejor impacto visual
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 1.5,
        });
      }

      function addBloodStormEffect(x, y) {
        console.log("Añadiendo efecto visual de Blood Storm en posición", x, y);
        visualEffects.push({
          type: "blood_storm",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.2, // Duración para 9 frames
          frame: 0,
          frameCount: 9, // 9 frames en total (2 filas: 5+4)
          frameWidth: 192, // 960px / 5 frames por fila
          frameHeight: 128, // 256px / 2 filas
          size: 150, // Tamaño más grande para AoE
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 1.2,
        });
      }

      function addLavaEffect(x, y) {
        visualEffects.push({
          type: "lava",
          x: x,
          y: y + 30, // Debajo del enemigo
          startTime: currentTime,
          duration: 0.5, // 1/2 segundo
          particles: [],
        });
      }

      function addProtectionEffect(heroes) {
        heroes.forEach((hero) => {
          if (hero.hp > 0) {
            visualEffects.push({
              type: "protection",
              x: hero.posx,
              y: hero.posy,
              startTime: currentTime,
              duration: 1.0, // 1 segundo
              radius: 0,
            });
          }
        });
      }

      function addPoisonEffect(x, y) {
        console.log("Añadiendo efecto visual de veneno en posición", x, y);
        visualEffects.push({
          type: "poison",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 2.0, // 2 segundos para mejor visibilidad
          radius: 0,
          particles: [],
        });
      }

      function addMeteorEffect(x, y) {
        visualEffects.push({
          type: "meteor",
          x: x,
          y: y - 150, // Empezar desde arriba
          targetX: x,
          targetY: y,
          startTime: currentTime,
          duration: 0.8, // 0.8 segundos para caer
          trail: [], // Estela del meteorito
          impacted: false,
        });
      }

      function updateHitNumbers(dt) {
        for (let i = hitNumbers.length - 1; i >= 0; i--) {
          const hitNum = hitNumbers[i];
          const elapsed = currentTime - hitNum.startTime;

          // Mover hacia arriba
          hitNum.y -= 30 * dt;

          // Fade out
          hitNum.opacity = Math.max(0, 1 - elapsed / hitNum.duration);

          // Eliminar cuando termine la animación
          if (elapsed >= hitNum.duration) {
            hitNumbers.splice(i, 1);
          }
        }
      }

      function updateVisualEffects(dt) {
        for (let i = visualEffects.length - 1; i >= 0; i--) {
          const effect = visualEffects[i];
          const elapsed = currentTime - effect.startTime;

          if (effect.type === "fireblast") {
            // Actualizar frame del efecto de fireblast con repeticiones
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Si completó una animación, resetear para repetir
            if (effect.frame >= effect.frameCount) {
              if (effect.repeat < effect.maxRepeats) {
                effect.repeat++;
                effect.startTime = currentTime; // Reiniciar tiempo
                effect.frame = 0;
              }
            }
          } else if (effect.type === "conflagration") {
            // Actualizar frame del efecto de conflagration con repeticiones
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Si completó una animación, resetear para repetir
            if (effect.frame >= effect.frameCount) {
              if (effect.repeat < effect.maxRepeats) {
                effect.repeat++;
                effect.startTime = currentTime; // Reiniciar tiempo
                effect.frame = 0;
              }
            }
          } else if (effect.type === "slash") {
            // Actualizar frame del efecto de slash con repeticiones
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Si completó una animación, resetear para repetir
            if (effect.frame >= effect.frameCount) {
              if (effect.repeat < effect.maxRepeats) {
                effect.repeat++;
                effect.startTime = currentTime; // Reiniciar tiempo
                effect.frame = 0;
              }
            }
          } else if (effect.type === "healing") {
            // Actualizar frame del efecto de curación
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "holy_wave") {
            // Actualizar frame del efecto de Holy Wave
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "regrowth_new") {
            // Actualizar frame del efecto de Regrowth mejorado
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "combustion") {
            // Actualizar frame del efecto de combustion con repeticiones
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Si completó una animación, resetear para repetir
            if (effect.frame >= effect.frameCount) {
              if (effect.repeat < effect.maxRepeats) {
                effect.repeat++;
                effect.startTime = currentTime; // Reiniciar tiempo
                effect.frame = 0;
              }
            }
          } else if (effect.type === "smite") {
            // Actualizar frame del efecto de smite
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "inmolation") {
            // Actualizar frame del efecto de inmolation con repeticiones
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Si completó una animación, resetear para repetir
            if (effect.frame >= effect.frameCount) {
              if (effect.repeat < effect.maxRepeats) {
                effect.repeat++;
                effect.startTime = currentTime; // Reiniciar tiempo
                effect.frame = 0;
              }
            }
          } else if (effect.type === "blood_splat") {
            // Actualizar frame del efecto de Blood Splat
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "blood_storm") {
            // Actualizar frame del efecto de Blood Storm
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "lava") {
            // Generar más partículas de lava (más intenso)
            if (Math.random() < 0.6) {
              // Era 0.3, ahora es 0.6
              effect.particles.push({
                x: effect.x + (Math.random() - 0.5) * 80, // Área más grande
                y: effect.y,
                vy: -40 - Math.random() * 50, // Velocidad más alta
                life: 0.5 + Math.random() * 0.4, // Vida más larga
                maxLife: 0.5 + Math.random() * 0.4,
              });
            }

            // Actualizar partículas
            for (let j = effect.particles.length - 1; j >= 0; j--) {
              const particle = effect.particles[j];
              particle.y += particle.vy * dt;
              particle.life -= dt;
              if (particle.life <= 0) {
                effect.particles.splice(j, 1);
              }
            }
          } else if (effect.type === "protection") {
            // Expandir el escudo
            effect.radius = (elapsed / effect.duration) * 50;
          } else if (effect.type === "poison") {
            // Expandir el efecto de veneno y generar partículas tóxicas
            effect.radius = (elapsed / effect.duration) * 40;

            // Generar partículas de veneno
            if (Math.random() < 0.4) {
              effect.particles.push({
                x: effect.x + (Math.random() - 0.5) * 60,
                y: effect.y + (Math.random() - 0.5) * 60,
                vy: -20 - Math.random() * 30,
                life: 0.8 + Math.random() * 0.6,
                maxLife: 0.8 + Math.random() * 0.6,
              });
            }

            // Actualizar partículas de veneno
            for (let j = effect.particles.length - 1; j >= 0; j--) {
              const particle = effect.particles[j];
              particle.y += particle.vy * dt;
              particle.life -= dt;
              if (particle.life <= 0) {
                effect.particles.splice(j, 1);
              }
            }
          } else if (effect.type === "meteor") {
            // Animación del meteorito cayendo
            const progress = Math.min(elapsed / effect.duration, 1);
            const easeProgress = 1 - Math.pow(1 - progress, 3); // Easing para aceleración

            effect.x = effect.targetX;
            effect.y = effect.targetY - 150 + 150 * easeProgress;

            // Agregar punto a la estela
            effect.trail.push({ x: effect.x, y: effect.y, life: 0.3 });

            // Actualizar estela
            for (let j = effect.trail.length - 1; j >= 0; j--) {
              effect.trail[j].life -= dt;
              if (effect.trail[j].life <= 0) {
                effect.trail.splice(j, 1);
              }
            }

            // Impacto al llegar al suelo
            if (progress >= 1 && !effect.impacted) {
              effect.impacted = true;
              // Crear efecto de explosión
              for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                effect.trail.push({
                  x: effect.targetX + Math.cos(angle) * 20,
                  y: effect.targetY + Math.sin(angle) * 20,
                  life: 0.5,
                });
              }
            }
          }

          // Eliminar efecto cuando termine (considerando repeticiones)
          if (
            effect.type === "fireblast" ||
            effect.type === "conflagration" ||
            effect.type === "slash" ||
            effect.type === "combustion" ||
            effect.type === "inmolation" ||
            effect.type === "blood_splat" ||
            effect.type === "blood_storm"
          ) {
            // Para efectos con repeticiones, eliminar cuando se haya superado el tiempo absoluto de finalización
            if (currentTime >= effect.endTime) {
              visualEffects.splice(i, 1);
            }
          } else if (elapsed >= effect.duration) {
            // Para otros efectos (healing, holy_wave, regrowth_new, smite, lava, protection, meteor), eliminar normalmente
            visualEffects.splice(i, 1);
          }
        }
      }

      function renderHitNumbers() {
        ctx.save();
        ctx.textAlign = "center";

        hitNumbers.forEach((hitNum) => {
          ctx.globalAlpha = hitNum.opacity;

          // Configurar estilo según el tipo de hit
          if (hitNum.isCritical) {
            ctx.font = "bold 28px monospace"; // Más grande para críticos
            ctx.fillStyle = "#FFD700"; // Amarillo dorado para críticos
            ctx.lineWidth = 4;
          } else if (hitNum.isHealing) {
            ctx.font = "bold 20px monospace";
            ctx.fillStyle = "#00ff00"; // Verde para curación
            ctx.lineWidth = 3;
          } else {
            ctx.font = "bold 20px monospace";
            ctx.fillStyle = "#ff0000"; // Rojo para daño normal
            ctx.lineWidth = 3;
          }

          // Sombra para mejor visibilidad
          ctx.strokeStyle = "#000000";

          let text;
          if (hitNum.isCritical) {
            text = `CRIT! -${hitNum.value}`;
          } else if (hitNum.isHealing) {
            text = `+${hitNum.value}`;
          } else {
            text = `-${hitNum.value}`;
          }

          ctx.strokeText(text, hitNum.x, hitNum.y);
          ctx.fillText(text, hitNum.x, hitNum.y);
        });

        ctx.restore();
      }

      function renderVisualEffects() {
        ctx.save();

        visualEffects.forEach((effect) => {
          const elapsed = currentTime - effect.startTime;
          const progress = elapsed / effect.duration;

          if (effect.type === "fireblast") {
            // Renderizar efecto de fireblast usando sprites - más grande
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = (7 + effect.frame) * effect.frameWidth; // Frames 8,9,10,11 (posiciones 7,8,9,10)
              const sy = 15 * effect.frameHeight; // Fila 15 (empezando desde 0)

              const renderSize = effect.size || 64;
              ctx.drawImage(
                effectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "conflagration") {
            // Renderizar efecto de conflagration usando sprites - más grande
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = (6 + effect.frame) * effect.frameWidth; // Frames 6,7,8,9 (posiciones 6,7,8,9)
              const sy = 0 * effect.frameHeight; // Fila 0 (empezando desde 0)

              const renderSize = effect.size || 64;
              ctx.drawImage(
                effectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "slash") {
            // Renderizar efecto de slash usando sprites púrpura - más grande
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = (17 + effect.frame) * effect.frameWidth; // Frames 17,18,19,20 (posiciones 17,18,19,20)
              const sy = 11 * effect.frameHeight; // Fila 11 (empezando desde 0)

              const renderSize = effect.size || 64;
              ctx.drawImage(
                purpleEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "healing") {
            // Renderizar efecto de curación usando el nuevo sprite específico
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame: 5 frames en primera fila, 2 en segunda
              let sx, sy;
              if (effect.frame < 5) {
                // Primera fila (frames 0-4)
                sx = effect.frame * effect.frameWidth;
                sy = 0;
              } else {
                // Segunda fila (frames 5-6)
                sx = (effect.frame - 5) * effect.frameWidth;
                sy = effect.frameHeight;
              }

              const renderSize = effect.size || 120; // Tamaño por defecto más grande
              ctx.drawImage(
                healingEffectsImg, // Usar el nuevo sprite de curación
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "combustion") {
            // Renderizar efecto de combustion usando sprites del mago
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = (11 + effect.frame) * effect.frameWidth; // Frames 11,12,13,14 (posiciones 11,12,13,14)
              const sy = 8 * effect.frameHeight; // Fila 8 (empezando desde 0)

              const renderSize = effect.size || 80;
              ctx.drawImage(
                effectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "smite") {
            // Renderizar efecto de smite usando el nuevo sprite mejorado
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame: 5 frames en primera fila, 5 en segunda
              let sx, sy;
              if (effect.frame < 5) {
                // Primera fila (frames 0-4)
                sx = effect.frame * effect.frameWidth;
                sy = 0;
              } else {
                // Segunda fila (frames 5-9)
                sx = (effect.frame - 5) * effect.frameWidth;
                sy = effect.frameHeight;
              }

              const renderSize = effect.size || 120;
              ctx.drawImage(
                priestSmiteEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "holy_wave") {
            // Renderizar efecto de Holy Wave
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame: 5 frames en primera fila, 5 en segunda, 1 en tercera
              let sx, sy;
              if (effect.frame < 5) {
                // Primera fila (frames 0-4)
                sx = effect.frame * effect.frameWidth;
                sy = 0;
              } else if (effect.frame < 10) {
                // Segunda fila (frames 5-9)
                sx = (effect.frame - 5) * effect.frameWidth;
                sy = effect.frameHeight;
              } else {
                // Tercera fila (frame 10)
                sx = (effect.frame - 10) * effect.frameWidth;
                sy = effect.frameHeight * 2;
              }

              const renderSize = effect.size || 130;
              ctx.drawImage(
                priestHolyWaveEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "regrowth_new") {
            // Renderizar efecto de Regrowth mejorado
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame: 5 frames en primera fila, 5 en segunda, 2 en tercera
              let sx, sy;
              if (effect.frame < 5) {
                // Primera fila (frames 0-4)
                sx = effect.frame * effect.frameWidth;
                sy = 0;
              } else if (effect.frame < 10) {
                // Segunda fila (frames 5-9)
                sx = (effect.frame - 5) * effect.frameWidth;
                sy = effect.frameHeight;
              } else {
                // Tercera fila (frames 10-11)
                sx = (effect.frame - 10) * effect.frameWidth;
                sy = effect.frameHeight * 2;
              }

              const renderSize = effect.size || 125;
              ctx.drawImage(
                priestRegrowthEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "inmolation") {
            // Renderizar efecto de inmolation usando sprite de dark bolt
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = effect.frame * effect.frameWidth; // Frames 0-10
              const sy = 0; // Solo una fila

              const renderSize = effect.size || 90;
              ctx.drawImage(
                darkBoltEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "lava") {
            // Renderizar partículas de lava
            effect.particles.forEach((particle) => {
              const alpha = particle.life / particle.maxLife;
              ctx.globalAlpha = alpha;

              // Gradiente de colores más intenso: rojo-naranja-amarillo-blanco
              const colors = [
                "#ff0000",
                "#ff2200",
                "#ff4500",
                "#ff6600",
                "#ffa500",
                "#ffcc00",
                "#ffff00",
                "#ffffff",
              ];
              const colorIndex = Math.floor((1 - alpha) * (colors.length - 1));
              ctx.fillStyle = colors[colorIndex];

              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 4, 0, Math.PI * 2); // Partículas más grandes
              ctx.fill();

              // Brillo adicional
              ctx.globalAlpha = alpha * 0.5;
              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 6, 0, Math.PI * 2);
              ctx.fill();
            });

            // Base de lava burbujeante más intensa
            ctx.globalAlpha = 1 - progress;
            ctx.fillStyle = "#ff2200";
            for (let i = 0; i < 8; i++) {
              // Más burbujas
              const bubbleX = effect.x + (Math.random() - 0.5) * 70; // Área más grande
              const bubbleY = effect.y + Math.random() * 15;
              const bubbleSize = 3 + Math.random() * 6; // Burbujas más grandes
              ctx.beginPath();
              ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
              ctx.fill();
            }

            // Resplandor de base
            ctx.globalAlpha = (1 - progress) * 0.3;
            ctx.fillStyle = "#ff4500";
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, 30, 0, Math.PI * 2);
            ctx.fill();
          } else if (effect.type === "protection") {
            // Renderizar escudo de protección
            ctx.globalAlpha = Math.max(0, 1 - progress);
            ctx.strokeStyle = "#8A2BE2"; // Púrpura neón
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.stroke();

            // Brillo interior
            ctx.globalAlpha = Math.max(0, (1 - progress) * 0.3);
            ctx.fillStyle = "#9370DB"; // Púrpura más claro para el interior
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.fill();
          } else if (effect.type === "poison") {
            // Renderizar partículas de veneno
            effect.particles.forEach((particle) => {
              const alpha = particle.life / particle.maxLife;
              ctx.globalAlpha = alpha;

              // Colores tóxicos: verde ácido
              const colors = ["#00ff00", "#32cd32", "#adff2f", "#7fff00"];
              const colorIndex = Math.floor((1 - alpha) * (colors.length - 1));
              ctx.fillStyle = colors[colorIndex];

              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
              ctx.fill();

              // Brillo tóxico
              ctx.globalAlpha = alpha * 0.6;
              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 5, 0, Math.PI * 2);
              ctx.fill();
            });

            // Base de veneno burbujeante
            ctx.globalAlpha = Math.max(0, 1 - progress);
            ctx.strokeStyle = "#00ff00"; // Verde tóxico
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.stroke();

            // Resplandor interior venenoso
            ctx.globalAlpha = Math.max(0, (1 - progress) * 0.4);
            ctx.fillStyle = "#32cd32"; // Verde lima para el interior
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.fill();
          } else if (effect.type === "meteor") {
            // Renderizar estela del meteorito
            effect.trail.forEach((point, index) => {
              const alpha = point.life / 0.5;
              ctx.globalAlpha = alpha;
              const size = 2 + alpha * 3;

              // Colores de fuego para la estela
              const colors = ["#ff0000", "#ff4500", "#ffa500", "#ffff00"];
              const colorIndex = Math.floor((1 - alpha) * (colors.length - 1));
              ctx.fillStyle = colors[colorIndex];

              ctx.beginPath();
              ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
              ctx.fill();
            });

            // Renderizar el meteorito en sí
            if (!effect.impacted) {
              ctx.globalAlpha = 1;

              // Núcleo del meteorito
              ctx.fillStyle = "#ffaa00";
              ctx.beginPath();
              ctx.arc(effect.x, effect.y, 8, 0, Math.PI * 2);
              ctx.fill();

              // Brillo exterior
              ctx.fillStyle = "#ff4500";
              ctx.beginPath();
              ctx.arc(effect.x, effect.y, 12, 0, Math.PI * 2);
              ctx.fill();

              // Resplandor
              ctx.globalAlpha = 0.6;
              ctx.fillStyle = "#ff0000";
              ctx.beginPath();
              ctx.arc(effect.x, effect.y, 16, 0, Math.PI * 2);
              ctx.fill();
            }
          } else if (effect.type === "blood_splat") {
            // Renderizar efecto de blood splat usando el nuevo sprite sheet (10 frames en 2 filas)
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame: 5 frames en primera fila, 5 en segunda
              let sx, sy;
              if (effect.frame < 5) {
                // Primera fila (frames 0-4)
                sx = effect.frame * effect.frameWidth;
                sy = 0;
              } else {
                // Segunda fila (frames 5-9)
                sx = (effect.frame - 5) * effect.frameWidth;
                sy = effect.frameHeight;
              }

              const renderSize = effect.size || 140;
              ctx.drawImage(
                bloodSplatEffectsImg, // Usar el nuevo sprite sheet
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "blood_storm") {
            // Renderizar efecto de blood storm (AoE a todos los aliados)
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame: 5 frames en primera fila, 4 en segunda
              let sx, sy;
              if (effect.frame < 5) {
                // Primera fila (frames 0-4)
                sx = effect.frame * effect.frameWidth;
                sy = 0;
              } else {
                // Segunda fila (frames 5-8)
                sx = (effect.frame - 5) * effect.frameWidth;
                sy = effect.frameHeight;
              }

              const renderSize = effect.size || 150;
              ctx.drawImage(
                bloodStormEffectsImg, // Usar el sprite original para AoE
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          }
        });

        ctx.restore();
      }

      function getDistance(a, b) {
        const dx = a.posx - b.posx;
        const dy = a.posy - b.posy;
        return Math.sqrt(dx * dx + dy * dy);
      }

      function getClosestHero(enemy, heroes) {
        const aliveHeroes = heroes.filter((h) => h.hp > 0);
        if (aliveHeroes.length === 0) return null;

        let closest = aliveHeroes[0];
        let minDistance = getDistance(enemy, closest);

        for (let i = 1; i < aliveHeroes.length; i++) {
          const distance = getDistance(enemy, aliveHeroes[i]);
          if (distance < minDistance) {
            minDistance = distance;
            closest = aliveHeroes[i];
          }
        }

        return closest;
      }

      function getRandomHero(heroes) {
        const aliveHeroes = heroes.filter((h) => h.hp > 0);
        if (aliveHeroes.length === 0) return null;

        const randomIndex = Math.floor(Math.random() * aliveHeroes.length);
        return aliveHeroes[randomIndex];
      }

      // NOTA: enemyAct() removida - ahora se usa sistema de auto-attack en el loop principal

      let lastTime = 0;
      function loop(time) {
        const delta = (time - lastTime) / 1000;
        lastTime = time;
        currentTime += delta;

        // Update hit numbers
        updateHitNumbers(delta);

        // Update visual effects
        updateVisualEffects(delta);

        // Check wave cleared continuously
        checkWaveCleared();

        // Update buffs
        heroes.forEach((h) => {
          h.buffs = h.buffs.filter((b) => {
            if (b.endTime <= currentTime) return false;

            if (b.type === "rejuvenation" && b.nextTick <= currentTime) {
              h.hp = Math.min(h.maxhp, h.hp + b.heal);
              console.log(
                "Rejuvenation tick para",
                h.clazz,
                "- creando efecto visual de curación"
              );
              playHealingAnim(h);
              showHitNumber(h.posx, h.posy - 20, b.heal, true);
              b.nextTick += 1;
            } else if (b.type === "regrowth" && b.nextTick <= currentTime) {
              h.hp = Math.min(h.maxhp, h.hp + b.heal);
              console.log(
                "Regrowth tick para",
                h.clazz,
                "- curación de",
                b.heal
              );
              playHealingAnim(h);
              showHitNumber(h.posx, h.posy - 20, b.heal, true);
              b.nextTick += 1;
            } else if (b.type === "poison" && b.nextTick <= currentTime) {
              // Aplicar daño de veneno
              h.hp = Math.max(0, h.hp - b.damage);
              console.log(
                "Poison tick para",
                h.clazz,
                "- daño de veneno:",
                b.damage
              );
              showHitNumber(h.posx, h.posy - 20, b.damage, false, false);
              addPoisonEffect(h.posx, h.posy); // Efecto visual cada tick
              b.nextTick += b.tickInterval; // Próximo tick en 3 segundos

              // Verificar si el héroe murió por veneno
              if (h.hp <= 0) {
                console.log(h.clazz, "died from poison!");
              }
            }
            return true;
          });
        });

        // Update animations
        heroes.forEach((h) => {
          if (h.hp <= 0) return;
          const animData = h.animations[h.anim];
          h.animTime += delta;
          const frameDuration = animData.duration / animData.frames;
          if (h.animTime >= frameDuration) {
            h.animTime -= frameDuration;
            h.frame = (h.frame + 1) % animData.frames;
            if (h.frame === 0 && h.anim !== "idle" && h.anim !== "selected") {
              if (state === "animate") {
                console.log(
                  "Animation completed! Applying effect for hero:",
                  h.clazz,
                  "action:",
                  h.action,
                  "targets:",
                  h.targets ? h.targets.length : 0,
                  "target types:",
                  h.targets
                    ? h.targets.map((t) => t.clazz || "enemy").join(",")
                    : "none"
                );

                // Verificar que tenemos una acción válida antes de aplicar efectos
                if (h.action && h.targets && h.targets.length > 0) {
                  applyEffect(h, h.action, h.targets);

                  // Limpiar propiedades de acción SOLO para este héroe después de aplicar el efecto
                  console.log("Limpiando propiedades de acción para", h.clazz);
                  h.targets = [];
                  h.action = null;

                  state = "select_hero"; // Volver inmediatamente a selección sin avanzar turno
                } else {
                  console.warn(
                    "Hero",
                    h.clazz,
                    "has no valid action or targets to apply. Action:",
                    h.action,
                    "Targets length:",
                    h.targets ? h.targets.length : 0
                  );
                }
              }
              // Solo cambiar a idle si no hay habilidades pendientes
              if (state !== "animate") {
                h.anim = "idle";
              }
            }
          }
        });

        // Update enemy charge and check for automatic attacks
        enemies.forEach((e) => {
          if (e.hp > 0 && !e.isDying) {
            // Charge enemies using their custom charge speed
            const chargeSpeed = e.chargeSpeed || 20; // Fallback a 20 si no hay chargeSpeed definido
            e.charge = Math.min(e.maxcharge, e.charge + delta * chargeSpeed); // Charge over time

            // Auto attack when fully charged
            if (e.charge >= 100 && e.animTime <= 0) {
              // Determinar el nivel actual para decidir el targeting
              const currentLevel = Math.floor(wave / 3) + 1;

              // En Red Dunes (nivel 1) los enemigos atacan a un aliado aleatorio
              // En otros niveles atacan al más cercano
              const target =
                currentLevel === 1
                  ? getRandomHero(heroes)
                  : getClosestHero(e, heroes);

              if (target) {
                let damage = e.type === "boss" ? 45 : 25; // Boss hace 45 de daño base, enemigos normales 25
                e.charge = 0; // Reset charge
                e.animTime = 0.5;
                e.anim = "attack"; // Activar animación de ataque
                e.frame = 0; // Reiniciar frame
                e.animStartTime = currentTime; // Tiempo de inicio de la animación

                // Manejo de ataques de Boss (Boss Bat y Demon Slime)
                let isSpecialAttack = false;
                let isMainAbility = false;
                if (e.type === "boss" && e.attacksUntilSpecial !== null) {
                  e.attacksUntilSpecial--;
                  if (e.attacksUntilSpecial <= 0) {
                    isSpecialAttack = true;
                    e.attacksUntilSpecial = e.specialAttackCounter; // Reset counter

                    // Ajustar daño según el tipo de boss
                    if (e.name === "Boss Bat") {
                      damage = 30 + Math.floor(Math.random() * 11); // Daño entre 30-40 para Blood Storm (AoE)
                    } else if (e.name === "Demon Slime") {
                      damage = 0; // El ataque especial de Demon Slime no hace daño directo, solo aplica veneno
                    }
                  } else {
                    // Ataques principales/normales
                    isMainAbility = true;
                    if (e.name === "Boss Bat") {
                      damage = 20 + Math.floor(Math.random() * 11); // Daño entre 20-30 para Blood Splat (single target)
                    } else if (e.name === "Demon Slime") {
                      damage = 25 + Math.floor(Math.random() * 11); // Daño entre 25-35 para ataque básico del slime
                    }
                  }
                }

                setTimeout(() => {
                  if (isSpecialAttack) {
                    if (e.name === "Boss Bat") {
                      // Ataque especial: Blood Storm (daño AoE a todos los héroes)
                      console.log(
                        "Boss Bat uses Blood Storm special attack (AoE)!"
                      );
                      heroes.forEach((hero) => {
                        if (hero.hp > 0) {
                          const currentDef =
                            hero.def +
                            hero.buffs.reduce(
                              (sum, b) =>
                                b.type === "protection" || b.type === "agony"
                                  ? sum + b.defBonus
                                  : sum,
                              0
                            );

                          const criticalResult = calculateCritical(damage);
                          const finalDamage = criticalResult.damage;
                          const effectiveDamage = Math.max(
                            1,
                            finalDamage - currentDef
                          );
                          hero.hp = Math.max(0, hero.hp - effectiveDamage);

                          console.log(
                            `${
                              hero.clazz || "Hero"
                            } takes ${effectiveDamage} AoE damage from Blood Storm!`
                          );

                          // Mostrar número de daño para cada héroe afectado
                          showHitNumber(
                            hero.posx,
                            hero.posy - 20,
                            effectiveDamage,
                            false,
                            criticalResult.isCritical
                          );

                          // Agregar efecto visual de Blood Storm para cada héroe
                          addBloodStormEffect(hero.posx, hero.posy);
                        }
                      });
                    } else if (e.name === "Demon Slime") {
                      // Ataque especial: Poison Cloud (debuff de veneno a todos los aliados)
                      console.log(
                        "Demon Slime uses Poison Cloud special attack!"
                      );
                      heroes.forEach((hero) => {
                        if (hero.hp > 0) {
                          // Aplicar debuff de veneno
                          hero.buffs.push({
                            type: "poison",
                            endTime: currentTime + 15, // 15 segundos
                            nextTick: currentTime + 3, // Primer tick en 3 segundos
                            damage: 3 + Math.floor(Math.random() * 3), // Daño entre 3-5 HP
                            tickInterval: 3, // Cada 3 segundos
                          });

                          console.log(
                            `${
                              hero.clazz || "Hero"
                            } is poisoned for 15 seconds!`
                          );

                          // Efecto visual de veneno (por ahora usar el de protection pero en verde)
                          addPoisonEffect(hero.posx, hero.posy);
                        }
                      });
                    }
                  } else if (isMainAbility) {
                    if (e.name === "Boss Bat") {
                      // Habilidad principal: Blood Splat (a un solo aliado aleatorio)
                      console.log(
                        "Boss Bat uses Blood Splat main ability (single target)!"
                      );
                      const aliveHeroes = heroes.filter((h) => h.hp > 0);
                      if (aliveHeroes.length > 0) {
                        // Seleccionar héroe aleatorio en lugar del más cercano
                        const randomIndex = Math.floor(
                          Math.random() * aliveHeroes.length
                        );
                        const randomTarget = aliveHeroes[randomIndex];

                        const currentDef =
                          randomTarget.def +
                          randomTarget.buffs.reduce(
                            (sum, b) =>
                              b.type === "protection" || b.type === "agony"
                                ? sum + b.defBonus
                                : sum,
                            0
                          );

                        const criticalResult = calculateCritical(damage);
                        const finalDamage = criticalResult.damage;
                        const effectiveDamage = Math.max(
                          1,
                          finalDamage - currentDef
                        );
                        randomTarget.hp = Math.max(
                          0,
                          randomTarget.hp - effectiveDamage
                        );

                        console.log(
                          `${
                            randomTarget.clazz || "Hero"
                          } takes ${effectiveDamage} damage from Blood Splat!`
                        );

                        // Mostrar número de daño
                        showHitNumber(
                          randomTarget.posx,
                          randomTarget.posy - 20,
                          effectiveDamage,
                          false,
                          criticalResult.isCritical
                        );

                        // Agregar efecto visual de Blood Splat
                        addBloodSplatEffect(
                          randomTarget.posx,
                          randomTarget.posy
                        );
                      }
                    } else if (e.name === "Demon Slime") {
                      // Ataque básico del Demon Slime: ataque a un héroe aleatorio
                      console.log(
                        "Demon Slime uses basic attack (single random target)!"
                      );
                      const aliveHeroes = heroes.filter((h) => h.hp > 0);
                      if (aliveHeroes.length > 0) {
                        // Seleccionar héroe aleatorio
                        const randomIndex = Math.floor(
                          Math.random() * aliveHeroes.length
                        );
                        const randomTarget = aliveHeroes[randomIndex];

                        const currentDef =
                          randomTarget.def +
                          randomTarget.buffs.reduce(
                            (sum, b) =>
                              b.type === "protection" || b.type === "agony"
                                ? sum + b.defBonus
                                : sum,
                            0
                          );

                        const criticalResult = calculateCritical(damage);
                        const finalDamage = criticalResult.damage;
                        const effectiveDamage = Math.max(
                          1,
                          finalDamage - currentDef
                        );
                        randomTarget.hp = Math.max(
                          0,
                          randomTarget.hp - effectiveDamage
                        );

                        console.log(
                          `${
                            randomTarget.clazz || "Hero"
                          } takes ${effectiveDamage} damage from Slime Attack!`
                        );

                        // Mostrar número de daño
                        showHitNumber(
                          randomTarget.posx,
                          randomTarget.posy - 20,
                          effectiveDamage,
                          false,
                          criticalResult.isCritical
                        );

                        // Por ahora sin efecto visual específico para el slime
                      }
                    }
                  } else {
                    // Ataque normal a un solo objetivo (el más cercano)
                    if (target.hp > 0) {
                      const currentDef =
                        target.def +
                        target.buffs.reduce(
                          (sum, b) =>
                            b.type === "protection" || b.type === "agony"
                              ? sum + b.defBonus
                              : sum,
                          0
                        );

                      // Calcular crítico para auto-ataque de enemigo
                      const criticalResult = calculateCritical(damage);
                      const finalDamage = criticalResult.damage;
                      const isCritical = criticalResult.isCritical;

                      const effectiveDamage = Math.max(
                        1,
                        finalDamage - currentDef
                      );
                      target.hp = Math.max(0, target.hp - effectiveDamage);

                      // Verificar si el héroe tiene buff de agony para reflejo de daño
                      const agonyBuff = target.buffs.find(
                        (b) => b.type === "agony"
                      );
                      if (agonyBuff && agonyBuff.damageReflect) {
                        const reflectedDamage = Math.floor(
                          effectiveDamage * (agonyBuff.damageReflect / 100)
                        );
                        e.hp = Math.max(0, e.hp - reflectedDamage);

                        // Sumar puntos por daño reflejado
                        score += reflectedDamage;

                        showHitNumber(
                          e.posx,
                          e.posy - 20,
                          reflectedDamage,
                          false,
                          false
                        );
                        console.log(
                          "Agony reflection (auto-attack): ",
                          reflectedDamage,
                          "damage to enemy"
                        );

                        if (e.hp <= 0) {
                          e.isDying = true;
                          e.anim = "die";
                          e.frame = 0;
                          e.animStartTime = currentTime;
                        }
                      }

                      // Mostrar número de daño del enemigo auto-attack con crítico
                      showHitNumber(
                        target.posx,
                        target.posy - 20,
                        effectiveDamage,
                        false,
                        isCritical
                      );
                      checkGameOver();
                    }
                  }
                }, 100);
              }
            }
          }

          // Actualizar animaciones de enemigos - usando sprites dinámicos del nivel
          if (e.anim === "hurt") {
            const elapsed = currentTime - e.animStartTime;
            if (elapsed >= 0.3) {
              // Duración del efecto de daño
              e.anim = "idle";
              e.frame = 0; // Reiniciar frame
              e.animStartTime = currentTime;
            }
          } else if (e.anim === "die") {
            const elapsed = currentTime - e.animStartTime;
            const frameDuration = 0.12; // Duración por frame para muerte (más fluido: 0.15 -> 0.12)
            e.frame = Math.floor(elapsed / frameDuration);
            const deathFrames = e.deathFrames || 6; // Usar frames dinámicos o fallback
            if (e.frame >= deathFrames) {
              e.deathAnimComplete = true;
              e.frame = deathFrames - 1; // Mantener en el último frame
            }
          } else if (e.anim === "attack") {
            const elapsed = currentTime - e.animStartTime;
            const frameDuration = 0.08; // Duración por frame para ataque (más fluido: 0.1 -> 0.08)
            e.frame = Math.floor(elapsed / frameDuration);
            // Usar frames específicos del enemigo o fallback
            const attackFrames = e.attackFrames || 4;
            if (e.frame >= attackFrames) {
              e.anim = "idle"; // Volver a idle después del ataque
              e.frame = 0;
              e.animStartTime = currentTime;
            }
          } else if (e.anim === "idle" && e.hp > 0) {
            const elapsed = currentTime - e.animStartTime;
            const frameDuration = 0.18; // Duración por frame para idle (más fluido: 0.25 -> 0.18)
            const idleFrames = e.idleFrames || 4; // Usar frames dinámicos o fallback
            e.frame = Math.floor(elapsed / frameDuration) % idleFrames;
          }

          if (e.animTime > 0) e.animTime -= delta;
        });

        // Update hero charge over time
        heroes.forEach((h) => {
          if (h.hp > 0) {
            // Charge heroes gradually always
            h.charge = Math.min(h.maxcharge, h.charge + delta * 15); // Charge over time
          }
        });

        draw();
        requestAnimationFrame(loop);
      }

      function draw() {
        ctx.clearRect(0, 0, designWidth, designHeight);

        // Configurar interpolación de alta calidad para todos los sprites
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";

        // Draw background
        ctx.drawImage(currentBackgroundImg, 0, 0, designWidth, designHeight);

        // Draw header
        drawHeader();

        heroes.forEach((h) => {
          const animData = h.animations[h.anim];
          // El frameOffset ya no es necesario para conflagration ya que usa su propia fila
          let frameOffset = 0;
          const sx = (h.frame + frameOffset) * h.frameW;
          const sy = animData.row * h.frameH;
          const size = h.size || 80;

          // Aplicar efecto de sombra/transparencia si está muerto
          if (h.hp <= 0) {
            ctx.save();
            ctx.globalAlpha = 0.6; // Menos transparente (era 0.4)
            ctx.filter = "brightness(0.3) contrast(0.8)"; // Más oscuro
          }

          ctx.drawImage(
            h.img,
            sx,
            sy,
            h.frameW,
            h.frameH,
            h.posx - size / 2,
            h.posy - size / 2,
            size,
            size
          );

          if (h.hp <= 0) {
            ctx.restore(); // Restaurar efectos
          }

          // HP bar background
          ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
          ctx.fillRect(h.posx - 40, h.posy + 55, 80, 12);

          // HP bar red
          ctx.fillStyle = "red";
          const hpWidth = 80 * (h.hp / h.maxhp);
          ctx.fillRect(h.posx - 40, h.posy + 55, hpWidth, 12);

          // Texto de HP centrado perfectamente en la barra
          ctx.fillStyle = "white";
          ctx.font = "8px 'Press Start 2P'";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          if (h.hp <= 0) {
            ctx.fillText("DEAD", h.posx, h.posy + 55 + 6); // Centrado en Y
          } else {
            ctx.fillText(`${h.hp}`, h.posx, h.posy + 55 + 6); // Centrado en Y
          }
          ctx.textAlign = "left"; // Resetear alineación
          ctx.textBaseline = "alphabetic"; // Resetear baseline

          // Charge bar background - dividido en 3 bloques (solo si está vivo)
          if (h.hp > 0) {
            ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
            ctx.fillRect(h.posx - 40, h.posy + 70, 80, 8);

            // Charge bar yellow - primer bloque (33.33%)
            ctx.fillStyle = "#FFD700";
            const firstBlockWidth = Math.min(26.67, 26.67 * (h.charge / 33.33));
            if (h.charge > 0) {
              ctx.fillRect(h.posx - 40, h.posy + 70, firstBlockWidth, 8);
            }

            // Segundo bloque (siguiente 33.33%)
            if (h.charge > 33.33) {
              const secondBlockWidth = 26.67 * ((h.charge - 33.33) / 33.33);
              ctx.fillRect(h.posx - 13.33, h.posy + 70, secondBlockWidth, 8);
            }

            // Tercer bloque (último 33.34%)
            if (h.charge > 66.66) {
              const thirdBlockWidth = 26.67 * ((h.charge - 66.66) / 33.34);
              ctx.fillRect(h.posx + 13.33, h.posy + 70, thirdBlockWidth, 8);
            }

            // Separadores entre bloques
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2;
            ctx.beginPath();
            // Primer separador (33.33%)
            ctx.moveTo(h.posx - 13.33, h.posy + 70);
            ctx.lineTo(h.posx - 13.33, h.posy + 78);
            // Segundo separador (66.66%)
            ctx.moveTo(h.posx + 13.33, h.posy + 70);
            ctx.lineTo(h.posx + 13.33, h.posy + 78);
            ctx.stroke();

            // Borde de la barra de carga
            ctx.strokeStyle = "black";
            ctx.lineWidth = 1;
            ctx.strokeRect(h.posx - 40, h.posy + 70, 80, 8);
          }

          // Borde de la barra de HP
          ctx.strokeStyle = "black";
          ctx.lineWidth = 1;
          ctx.strokeRect(h.posx - 40, h.posy + 55, 80, 12);
        });

        enemies.forEach((e) => {
          if (e.hp <= 0 && e.deathAnimComplete) return; // No dibujar si completó animación de muerte

          const size = e.size || 80;

          // Usar los sprites específicos del enemigo según el nivel
          ctx.save();

          // Activar interpolación suave para mejor calidad
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = "high";

          // Seleccionar sprite y calcular posición según animación
          let spriteImg, sx, sy;

          // Verificar si es Demon Slime (usa sprite sheet completo)
          if (e.name === "Demon Slime") {
            spriteImg = demonSlimeAllStatesImg;

            if (e.anim === "die") {
              // Fila 2 (death): 22 frames
              sx = e.frame * e.frameWidth;
              sy = 2 * e.frameHeight;
              // Efecto de desvanecimiento gradual al morir
              const deathProgress = e.frame / ((e.deathFrames || 22) - 1);
              ctx.globalAlpha = 1 - deathProgress * 0.7;
              ctx.filter = "grayscale(50%) brightness(0.5)";
            } else if (e.anim === "hurt") {
              // Para hurt, usar idle (fila 0) pero con efectos visuales
              sx = e.frame * e.frameWidth;
              sy = 0 * e.frameHeight;
              ctx.filter = "hue-rotate(0deg) contrast(1.5) brightness(1.2)";
              ctx.globalAlpha = 0.8 + 0.2 * Math.sin(currentTime * 20);
            } else if (e.anim === "attack") {
              // Fila 1 (attack): 15 frames
              sx = e.frame * e.frameWidth;
              sy = 1 * e.frameHeight;
            } else {
              // Fila 0 (idle): 6 frames
              sx = e.frame * e.frameWidth;
              sy = 0 * e.frameHeight;
            }
          } else {
            // Lógica original para otros enemigos (Demon Bat, Worm)
            if (e.anim === "die") {
              spriteImg = e.sprites ? e.sprites.death : goblinDieImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
              // Efecto de desvanecimiento gradual al morir
              const deathProgress = e.frame / ((e.deathFrames || 6) - 1);
              ctx.globalAlpha = 1 - deathProgress * 0.7;
              ctx.filter = "grayscale(50%) brightness(0.5)";
            } else if (e.anim === "hurt") {
              // Para hurt, usar idle pero con efectos visuales
              spriteImg = e.sprites ? e.sprites.idle : goblinIdleImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
              // Efecto de flash rojo cuando recibe daño
              ctx.filter = "hue-rotate(0deg) contrast(1.5) brightness(1.2)";
              ctx.globalAlpha = 0.8 + 0.2 * Math.sin(currentTime * 20); // Parpadeo
            } else if (e.anim === "attack") {
              // Animación de ataque
              spriteImg = e.sprites ? e.sprites.attack : goblinIdleImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
            } else {
              // idle
              spriteImg = e.sprites ? e.sprites.idle : goblinIdleImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
            }
          }

          // Dibujar el sprite del enemigo
          // Para Demon Slime, mantener las proporciones originales del sprite
          let drawWidth = size;
          let drawHeight = size;

          if (e.name === "Demon Slime") {
            // Mantener proporciones originales del sprite (150x83)
            const aspectRatio = e.frameWidth / e.frameHeight; // 150/83 ≈ 1.81
            drawWidth = size;
            drawHeight = size / aspectRatio; // Ajustar altura para mantener proporción
          }

          ctx.drawImage(
            spriteImg,
            sx,
            sy,
            e.frameWidth,
            e.frameHeight,
            e.posx - drawWidth / 2,
            e.posy - drawHeight / 2,
            drawWidth,
            drawHeight
          );

          ctx.restore();

          // Solo mostrar HUD si no está muerto o aún no completó la animación
          if (e.hp > 0 || !e.deathAnimComplete) {
            // Calcular offset vertical para la barra de HP según el tipo de enemigo
            let hpBarOffset = size / 2 + 25;
            if (e.name === "Demon Slime") {
              // Usar la altura real del sprite renderizado
              const aspectRatio = e.frameWidth / e.frameHeight;
              const actualHeight = size / aspectRatio;
              hpBarOffset = actualHeight / 2 + 25;
            }

            // HP bar background - ahora encima del enemigo
            ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
            ctx.fillRect(e.posx - 40, e.posy - hpBarOffset, 80, 12);

            // HP bar red
            ctx.fillStyle = "red";
            const hpWidth = 80 * (e.hp / e.maxhp);
            ctx.fillRect(e.posx - 40, e.posy - hpBarOffset, hpWidth, 12);

            // Texto de HP centrado perfectamente en la barra
            ctx.fillStyle = "white";
            ctx.font = "8px 'Press Start 2P'";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(`${e.hp}`, e.posx, e.posy - hpBarOffset + 6); // Centrado en Y
            ctx.textAlign = "left"; // Resetear alineación
            ctx.textBaseline = "alphabetic"; // Resetear baseline

            // Charge bar background (solo si está vivo) - directamente debajo de la HP bar
            if (e.hp > 0) {
              ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
              ctx.fillRect(e.posx - 40, e.posy - hpBarOffset + 12, 80, 8);

              // Charge bar orange - barra continua sin divisiones
              ctx.fillStyle = "#FFA500";
              const chargeWidth = 80 * (e.charge / e.maxcharge);
              ctx.fillRect(
                e.posx - 40,
                e.posy - hpBarOffset + 12,
                chargeWidth,
                8
              );

              // Borde de charge bar
              ctx.strokeStyle = "black";
              ctx.lineWidth = 1;
              ctx.strokeRect(e.posx - 40, e.posy - hpBarOffset + 12, 80, 8);

              // Mostrar esferas de ataque especial para el boss
              if (
                e.type === "boss" &&
                e.attacksUntilSpecial !== null &&
                e.attacksUntilSpecial <= 3
              ) {
                // Posición base para las esferas (centradas arriba de la HP bar)
                const sphereY = e.posy - hpBarOffset - 10;
                const sphereSpacing = 12;
                const startX = e.posx - sphereSpacing; // Para centrar 3 esferas

                // Dibujar 3 esferas
                for (let i = 0; i < 3; i++) {
                  const sphereX = startX + i * sphereSpacing;

                  // Determinar si esta esfera debe estar "llena" (roja) o "vacía" (gris)
                  const shouldBeFilled = 3 - e.attacksUntilSpecial > i;

                  // Esfera exterior (borde negro)
                  ctx.fillStyle = "black";
                  ctx.beginPath();
                  ctx.arc(sphereX, sphereY, 4, 0, Math.PI * 2);
                  ctx.fill();

                  // Esfera interior - color diferente según el boss
                  if (shouldBeFilled) {
                    // Color según el tipo de boss
                    if (e.name === "Boss Bat") {
                      ctx.fillStyle = "#ff0000"; // Rojo para Boss Bat
                    } else if (e.name === "Demon Slime") {
                      ctx.fillStyle = "#00ff00"; // Verde tóxico para Demon Slime
                    } else {
                      ctx.fillStyle = "#ff0000"; // Default rojo
                    }
                  } else {
                    // Esfera gris para ataques pendientes
                    ctx.fillStyle = "#666666";
                  }
                  ctx.beginPath();
                  ctx.arc(sphereX, sphereY, 3, 0, Math.PI * 2);
                  ctx.fill();

                  // Brillo interior para esferas llenas
                  if (shouldBeFilled) {
                    if (e.name === "Boss Bat") {
                      ctx.fillStyle = "#ff6666"; // Brillo rojo claro para Boss Bat
                    } else if (e.name === "Demon Slime") {
                      ctx.fillStyle = "#66ff66"; // Brillo verde claro para Demon Slime
                    } else {
                      ctx.fillStyle = "#ff6666"; // Default rojo claro
                    }
                    ctx.beginPath();
                    ctx.arc(sphereX - 1, sphereY - 1, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                  }
                }
              }
            }

            // Borde de HP bar
            ctx.strokeStyle = "black";
            ctx.lineWidth = 1;
            ctx.strokeRect(e.posx - 40, e.posy - hpBarOffset, 80, 12);
          }
        });

        // Footer estilo D&D
        drawFooter();

        // Mostrar indicador de selección de objetivo con ventana modal
        if (state === "select_target_enemy") {
          // Background que ocupa todo el ancho
          const modalWidth = designWidth;
          const modalHeight = 40;
          const modalX = 0;
          const modalY = 75;

          ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
          ctx.fillRect(modalX, modalY, modalWidth, modalHeight);

          // Texto principal - primera letra mayúscula, más pequeño, color menos fuerte
          ctx.fillStyle = "#E0E0E0";
          ctx.font = "10px 'Press Start 2P'";
          ctx.textAlign = "center";
          ctx.fillText(
            "Select enemy",
            designWidth / 2,
            modalY + modalHeight / 2 + 3
          );

          // X de cerrar en la esquina superior derecha del modal
          const closeX = modalX + modalWidth - 15;
          const closeY = modalY + 10;

          ctx.fillStyle = "rgba(255, 0, 0, 0.8)";
          ctx.font = "12px 'Press Start 2P'";
          ctx.textAlign = "center";
          ctx.fillText("X", closeX, closeY);
        } else if (state === "select_target_ally") {
          // Background que ocupa todo el ancho
          const modalWidth = designWidth;
          const modalHeight = 40;
          const modalX = 0;
          const modalY = 75;

          ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
          ctx.fillRect(modalX, modalY, modalWidth, modalHeight);

          // Texto principal - primera letra mayúscula, más pequeño, color menos fuerte
          ctx.fillStyle = "#E0E0E0";
          ctx.font = "10px 'Press Start 2P'";
          ctx.textAlign = "center";
          ctx.fillText(
            "Select ally",
            designWidth / 2,
            modalY + modalHeight / 2 + 3
          );

          // X de cerrar en la esquina superior derecha del modal
          const closeX = modalX + modalWidth - 15;
          const closeY = modalY + 10;

          ctx.fillStyle = "rgba(255, 0, 0, 0.8)";
          ctx.font = "12px 'Press Start 2P'";
          ctx.textAlign = "center";
          ctx.fillText("X", closeX, closeY);
        }
        ctx.textAlign = "left"; // Resetear alineación

        // Indicador visual removido - ya no necesario sin sistema de turnos

        // Renderizar efectos visuales especiales
        renderVisualEffects();

        // Renderizar números de golpe flotantes
        renderHitNumbers();
      }

      function drawHeader() {
        // Fondo del header - color beige claro
        ctx.fillStyle = "#D3BF8F";
        ctx.fillRect(0, 0, designWidth, 60);

        // Borde inferior del header
        ctx.strokeStyle = "#3D2914";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, 60);
        ctx.lineTo(designWidth, 60);
        ctx.stroke();

        // Score centrado - primera sección (altura: 30px, padding: 7px arriba y abajo)
        ctx.font = "bold 12px 'Press Start 2P'";
        ctx.textAlign = "center";

        // Texto "points" en marrón
        ctx.fillStyle = "#3D2914";
        const pointsText = " points";
        const pointsWidth = ctx.measureText(pointsText).width;
        const scoreText = score.toString();
        const scoreWidth = ctx.measureText(scoreText).width;
        const totalWidth = scoreWidth + pointsWidth;

        // Número del score en amarillo con borde marrón oscuro
        ctx.fillStyle = "#FFD700";
        ctx.strokeStyle = "#3D2914";
        ctx.lineWidth = 2;
        ctx.strokeText(
          scoreText,
          designWidth / 2 - totalWidth / 2 + scoreWidth / 2,
          22
        );
        ctx.fillText(
          scoreText,
          designWidth / 2 - totalWidth / 2 + scoreWidth / 2,
          22
        );

        // Texto "points" en marrón
        ctx.fillStyle = "#3D2914";
        ctx.fillText(pointsText, designWidth / 2 + scoreWidth / 2, 22);

        // Línea divisora entre score y level/wave - más ancha
        ctx.strokeStyle = "#3D2914"; // Marrón oscuro
        ctx.lineWidth = 4; // Aumentado de 2 a 4
        ctx.beginPath();
        ctx.moveTo(0, 30);
        ctx.lineTo(designWidth, 30);
        ctx.stroke();

        // Calcular nivel y wave
        const currentLevel = Math.floor((wave - 1) / 3) + 1;
        const currentWaveInLevel = ((wave - 1) % 3) + 1;

        // Obtener título de la dungeon desde la configuración de niveles
        const currentLevelConfig = levelConfig[currentLevel] || levelConfig[1]; // Fallback al nivel 1
        const dungeonTitle = currentLevelConfig
          ? currentLevelConfig.name
          : "Demon Cave";

        // Segunda sección - Level, Dungeon Title y Wave con divisores verticales
        ctx.font = "bold 9px 'Press Start 2P'";
        ctx.textAlign = "center";

        // Líneas divisoras verticales - más anchas
        ctx.strokeStyle = "#3D2914";
        ctx.lineWidth = 4; // Aumentado de 2 a 4
        ctx.beginPath();
        // Primera línea divisora (1/3)
        ctx.moveTo(designWidth / 3, 30);
        ctx.lineTo(designWidth / 3, 60);
        // Segunda línea divisora (2/3)
        ctx.moveTo((designWidth * 2) / 3, 30);
        ctx.lineTo((designWidth * 2) / 3, 60);
        ctx.stroke();

        // Level en la primera sección (0 a 1/3)
        ctx.fillStyle = "#3D2914"; // "Level" en marrón
        const levelTextOnly = "Level ";
        const levelTextWidth = ctx.measureText(levelTextOnly).width;
        const levelNumber = currentLevel.toString();
        const levelNumberWidth = ctx.measureText(levelNumber).width;
        const levelTotalWidth = levelTextWidth + levelNumberWidth;

        ctx.fillText(
          levelTextOnly,
          designWidth / 6 - levelTotalWidth / 2 + levelTextWidth / 2,
          52
        );
        ctx.fillStyle = "#3D2914"; // Número en marrón
        ctx.fillText(levelNumber, designWidth / 6 + levelTextWidth / 2, 52);

        // Título de la dungeon en la sección central (1/3 a 2/3)
        ctx.fillStyle = "#3D2914";
        ctx.fillText(dungeonTitle, designWidth / 2, 52);

        // Wave en la tercera sección (2/3 a 1)
        ctx.fillStyle = "#3D2914"; // "Wave" en marrón
        const waveTextOnly = "Wave ";
        const waveTextWidth = ctx.measureText(waveTextOnly).width;
        const waveFirstNumber = currentWaveInLevel.toString();
        const waveFirstWidth = ctx.measureText(waveFirstNumber).width;
        const waveBar = "/";
        const waveBarWidth = ctx.measureText(waveBar).width;
        const waveSecondNumber = "3";
        const waveSecondWidth = ctx.measureText(waveSecondNumber).width;
        const waveTotalWidth =
          waveTextWidth +
          waveFirstWidth +
          2 +
          waveBarWidth +
          2 +
          waveSecondWidth; // +2 píxeles de separación a cada lado de la barra

        const waveStartX = (designWidth * 5) / 6 - waveTotalWidth / 2;
        ctx.fillText(waveTextOnly, waveStartX + waveTextWidth / 2, 52);
        ctx.fillStyle = "#3D2914"; // Primer número en marrón
        ctx.fillText(
          waveFirstNumber,
          waveStartX + waveTextWidth + waveFirstWidth / 2,
          52
        );
        ctx.fillStyle = "#3D2914"; // Barra en marrón
        ctx.strokeStyle = "#3D2914"; // Borde marrón oscuro para la barra
        ctx.lineWidth = 1; // Línea más fina que los números
        ctx.strokeText(
          waveBar,
          waveStartX + waveTextWidth + waveFirstWidth + 1 + waveBarWidth / 2, // +1 píxel de separación del primer número
          52
        );
        ctx.fillText(
          waveBar,
          waveStartX + waveTextWidth + waveFirstWidth + 1 + waveBarWidth / 2, // +1 píxel de separación del primer número
          52
        );
        ctx.fillStyle = "#3D2914"; // Segundo número en marrón igual que el primero
        ctx.fillText(
          waveSecondNumber,
          waveStartX +
            waveTextWidth +
            waveFirstWidth +
            2 + // +1 píxel de separación antes de la barra
            waveBarWidth +
            1 + // +1 píxel de separación después de la barra
            waveSecondWidth / 2,
          52
        );

        ctx.textAlign = "left"; // Resetear alineación
      }

      function drawFooter() {
        // Fondo del footer - más oscuro y más alto
        ctx.fillStyle = "rgba(30, 20, 10, 0.9)";
        ctx.fillRect(0, 520, designWidth, 120); // Aumentado de 540,100 a 520,120

        // Borde superior del footer
        ctx.strokeStyle = "#3D2914";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, 520); // Movido de 540 a 520
        ctx.lineTo(designWidth, 520);
        ctx.stroke();

        // Dividir en 3 columnas
        const columnWidth = designWidth / 3;
        const heroOrder = ["mage", "warlock", "priest"];

        heroOrder.forEach((heroClass, heroIndex) => {
          const hero = heroes.find((h) => h.clazz === heroClass);
          if (!hero) return;

          const columnX = heroIndex * columnWidth;
          const centerX = columnX + columnWidth / 2;

          // Dibujar panel para cada héroe - usar brown para todos con menos espacio entre cards
          const panelWidth = columnWidth - 5;
          const panelHeight = 110; // Aumentado de 90 a 110
          const panelX = columnX + 2.5;
          const panelY = 525; // Ajustado de 545 a 525

          ctx.drawImage(panelBrownImg, panelX, panelY, panelWidth, panelHeight);

          // Título del héroe - siempre mismo color sin importar si está muerto
          ctx.fillStyle = "#3D2914"; // Siempre marrón oscuro
          ctx.font = "bold 8px 'Press Start 2P'";
          ctx.textAlign = "center";
          ctx.fillText(hero.clazz.toUpperCase(), centerX, 543); // Movido de 541 a 543 (+2px)

          if (hero.hp <= 0) {
            // Mostrar "DEAD" en lugar de botones
            ctx.fillStyle = "red";
            ctx.font = "bold 10px 'Press Start 2P'";
            ctx.textAlign = "center";
            ctx.fillText("DEAD", centerX, 585); // Ajustado de 595 a 585
          } else {
            const actions = Object.keys(classActions[hero.clazz]);

            // Configuración de botones - altura aumentada
            const buttonWidth = panelWidth - 14;
            const buttonHeight = 25; // Aumentado de 23 a 25
            const buttonX = panelX + 7;
            const buttonSpacing = 2; // Aumentado de 1 a 2

            // Botón habilidad principal (1 carga - 33.33%)
            const primaryAction = actions[0];
            const primaryData = classActions[hero.clazz][primaryAction];
            const buttonY1 = 550; // Ajustado de 567 a 550
            const canUsePrimary = hero.charge >= primaryData.reqCharge;

            // Usar botón beige si está activo, panel brown si está inactivo
            const primaryButtonImg = canUsePrimary
              ? buttonLongBeigeImg
              : panelBrownImg;
            ctx.drawImage(
              primaryButtonImg,
              buttonX,
              buttonY1,
              buttonWidth,
              buttonHeight
            );

            // Texto del botón principal - siempre marrón
            ctx.fillStyle = "#3D2914"; // Siempre marrón oscuro
            ctx.font = "bold 7px 'Press Start 2P'"; // Aumentado de 6px a 7px
            ctx.textAlign = "center";
            const primaryText =
              primaryData.name.charAt(0).toUpperCase() +
              primaryData.name.slice(1).toLowerCase();
            ctx.fillText(primaryText, centerX, buttonY1 + 16); // Ajustado para centrar mejor con altura 25

            // Botón habilidad secundaria (2 cargas - 66.66%)
            const secondaryAction = actions[1];
            const secondaryData = classActions[hero.clazz][secondaryAction];
            const buttonY2 = buttonY1 + buttonHeight + buttonSpacing;
            const canUseSecondary = hero.charge >= secondaryData.reqCharge;

            const secondaryButtonImg = canUseSecondary
              ? buttonLongBeigeImg
              : panelBrownImg;
            ctx.drawImage(
              secondaryButtonImg,
              buttonX,
              buttonY2,
              buttonWidth,
              buttonHeight
            );

            // Texto del botón secundario - siempre marrón
            ctx.fillStyle = "#3D2914"; // Siempre marrón oscuro
            ctx.font = "bold 7px 'Press Start 2P'"; // Aumentado de 6px a 7px
            ctx.textAlign = "center";
            const secondaryText =
              secondaryData.name.charAt(0).toUpperCase() +
              secondaryData.name.slice(1).toLowerCase();
            ctx.fillText(secondaryText, centerX, buttonY2 + 16); // Ajustado para centrar mejor con altura 25

            // Botón habilidad terciaria (3 cargas - 100%)
            const tertiaryAction = actions[2];
            const tertiaryData = classActions[hero.clazz][tertiaryAction];
            const buttonY3 = buttonY2 + buttonHeight + buttonSpacing;
            const canUseTertiary = hero.charge >= tertiaryData.reqCharge;

            const tertiaryButtonImg = canUseTertiary
              ? buttonLongBeigeImg
              : panelBrownImg;
            ctx.drawImage(
              tertiaryButtonImg,
              buttonX,
              buttonY3,
              buttonWidth,
              buttonHeight
            );

            // Texto del botón terciario - siempre marrón
            ctx.fillStyle = "#3D2914"; // Siempre marrón oscuro
            ctx.font = "bold 7px 'Press Start 2P'"; // Aumentado de 6px a 7px
            ctx.textAlign = "center";
            const tertiaryText =
              tertiaryData.name.charAt(0).toUpperCase() +
              tertiaryData.name.slice(1).toLowerCase();
            ctx.fillText(tertiaryText, centerX, buttonY3 + 16); // Ajustado para centrar mejor con altura 25
          }
        });

        ctx.textAlign = "left";
      }

      canvas.addEventListener("touchstart", handleInput);
      canvas.addEventListener("click", handleInput);

      function handleInput(e) {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        let clientX, clientY;

        if (e.type === "touchstart") {
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
        } else {
          clientX = e.clientX;
          clientY = e.clientY;
        }

        const touchX = (clientX - rect.left) * (designWidth / rect.width);
        const touchY = (clientY - rect.top) * (designHeight / rect.height);

        // Footer buttons
        if (touchY >= 520 && state === "select_hero") {
          // Actualizado de 540 a 520
          const columnWidth = designWidth / 3;
          const heroOrder = ["mage", "warlock", "priest"];

          heroOrder.forEach((heroClass, heroIndex) => {
            const hero = heroes.find((h) => h.clazz === heroClass);
            if (!hero || hero.hp <= 0) return;

            const actions = Object.keys(classActions[hero.clazz]);
            const columnX = heroIndex * columnWidth;

            // Configuración de botones para coincidir con drawFooter
            const panelWidth = columnWidth - 5; // Actualizado
            const panelX = columnX + 2.5; // Actualizado
            const buttonWidth = panelWidth - 14;
            const buttonHeight = 25; // Actualizado de 23 a 25
            const buttonX = panelX + 7;
            const buttonSpacing = 2; // Actualizado de 1 a 2

            // Botón habilidad principal (1 carga)
            const primaryY = 550; // Actualizado de 567 a 550
            if (
              touchX >= buttonX &&
              touchX <= buttonX + buttonWidth &&
              touchY >= primaryY &&
              touchY <= primaryY + buttonHeight
            ) {
              const action = actions[0];
              const actionData = classActions[hero.clazz][action];
              const canUse = hero.charge >= actionData.reqCharge && hero.hp > 0;

              if (canUse) {
                selectedHero = hero;
                selectedAction = action;

                const actionType = actionData.type;
                if (actionType === "single_enemy") {
                  state = "select_target_enemy";
                  hero.anim = "selected";
                  hero.frame = 0;
                  hero.animTime = 0;
                } else if (actionType === "single_ally") {
                  state = "select_target_ally";
                  hero.anim = "selected";
                  hero.frame = 0;
                  hero.animTime = 0;
                } else if (actionType === "all_enemy") {
                  if (
                    executeAction(
                      selectedHero,
                      action,
                      enemies.filter((e) => e.hp > 0)
                    )
                  ) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                } else if (actionType === "all_ally") {
                  if (
                    executeAction(
                      selectedHero,
                      action,
                      heroes.filter((h) => h.hp > 0)
                    )
                  ) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                } else if (actionType === "self") {
                  if (executeAction(selectedHero, action, selectedHero)) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                }
              }
            }

            // Botón habilidad secundaria (2 cargas)
            const secondaryY = primaryY + buttonHeight + buttonSpacing;
            if (
              touchX >= buttonX &&
              touchX <= buttonX + buttonWidth &&
              touchY >= secondaryY &&
              touchY <= secondaryY + buttonHeight
            ) {
              const action = actions[1];
              const actionData = classActions[hero.clazz][action];
              const canUse = hero.charge >= actionData.reqCharge && hero.hp > 0;

              if (canUse) {
                selectedHero = hero;
                selectedAction = action;

                const actionType = actionData.type;
                if (actionType === "single_enemy") {
                  state = "select_target_enemy";
                  hero.anim = "selected";
                  hero.frame = 0;
                  hero.animTime = 0;
                } else if (actionType === "single_ally") {
                  state = "select_target_ally";
                  hero.anim = "selected";
                  hero.frame = 0;
                  hero.animTime = 0;
                } else if (actionType === "all_enemy") {
                  if (
                    executeAction(
                      selectedHero,
                      action,
                      enemies.filter((e) => e.hp > 0)
                    )
                  ) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                } else if (actionType === "all_ally") {
                  if (
                    executeAction(
                      selectedHero,
                      action,
                      heroes.filter((h) => h.hp > 0)
                    )
                  ) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                } else if (actionType === "self") {
                  if (executeAction(selectedHero, action, selectedHero)) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                }
              }
            }

            // Botón habilidad terciaria (3 cargas)
            const tertiaryY = secondaryY + buttonHeight + buttonSpacing;
            if (
              touchX >= buttonX &&
              touchX <= buttonX + buttonWidth &&
              touchY >= tertiaryY &&
              touchY <= tertiaryY + buttonHeight
            ) {
              const action = actions[2];
              const actionData = classActions[hero.clazz][action];
              const canUse = hero.charge >= actionData.reqCharge && hero.hp > 0;

              if (canUse) {
                selectedHero = hero;
                selectedAction = action;

                const actionType = actionData.type;
                if (actionType === "single_enemy") {
                  state = "select_target_enemy";
                  hero.anim = "selected";
                  hero.frame = 0;
                  hero.animTime = 0;
                } else if (actionType === "single_ally") {
                  state = "select_target_ally";
                  hero.anim = "selected";
                  hero.frame = 0;
                  hero.animTime = 0;
                } else if (actionType === "all_enemy") {
                  if (
                    executeAction(
                      selectedHero,
                      action,
                      enemies.filter((e) => e.hp > 0)
                    )
                  ) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                } else if (actionType === "all_ally") {
                  if (
                    executeAction(
                      selectedHero,
                      action,
                      heroes.filter((h) => h.hp > 0)
                    )
                  ) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                } else if (actionType === "self") {
                  if (executeAction(selectedHero, action, selectedHero)) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                }
              }
            }
          });
          return;
        }

        // Botón X de cerrar - nueva posición en la esquina del modal
        if (state === "select_target_enemy" || state === "select_target_ally") {
          const modalWidth = designWidth;
          const modalX = 0;
          const modalY = 75;
          const closeX = modalX + modalWidth - 15;
          const closeY = modalY + 10;

          if (
            touchX >= closeX - 10 &&
            touchX <= closeX + 10 &&
            touchY >= closeY - 10 &&
            touchY <= closeY + 10
          ) {
            state = "select_hero";
            if (selectedHero) {
              selectedHero.anim = "idle"; // Resetear animación a idle
              selectedHero.frame = 0;
              selectedHero.animTime = 0;
            }
            selectedHero = null;
            selectedAction = null;
            return;
          }
        }

        if (state === "select_hero") {
          heroes.forEach((h) => {
            if (
              h.hp > 0 &&
              Math.abs(touchX - h.posx) < 40 &&
              Math.abs(touchY - h.posy) < 40
            ) {
              // No necesitamos cambiar el estado aquí, solo usamos los botones del footer
              console.log("Hero clicked:", h.clazz);
            }
          });
        } else if (state === "select_target_enemy") {
          enemies.forEach((e) => {
            const size = e.size || 80;
            if (
              e.hp > 0 &&
              Math.abs(touchX - e.posx) < size / 2 &&
              Math.abs(touchY - e.posy) < size / 2
            ) {
              if (executeAction(selectedHero, selectedAction, e)) {
                // No resetear selectedHero aquí, se resetea en applyEffect
                state = "animate";
              }
            }
          });
        } else if (state === "select_target_ally") {
          heroes.forEach((h) => {
            if (
              h.hp > 0 &&
              Math.abs(touchX - h.posx) < 40 &&
              Math.abs(touchY - h.posy) < 40
            ) {
              if (executeAction(selectedHero, selectedAction, h)) {
                // No resetear selectedHero aquí, se resetea en applyEffect
                state = "animate";
              }
            }
          });
        }
      }

      function resetGame() {
        init();
      }

      Promise.all([
        new Promise((r) => (backgroundImg.onload = r)),
        new Promise((r) => (backgroundLevel2Img.onload = r)),
        new Promise((r) => (mageImg.onload = r)),
        new Promise((r) => (priestImg.onload = r)),
        new Promise((r) => (warlockImg.onload = r)),
        new Promise((r) => (demonBatIdleImg.onload = r)),
        new Promise((r) => (demonBatDeathImg.onload = r)),
        new Promise((r) => (demonBatAttackImg.onload = r)),
        new Promise((r) => (wormIdleImg.onload = r)),
        new Promise((r) => (wormDeathImg.onload = r)),
        new Promise((r) => (wormAttackImg.onload = r)),
        new Promise((r) => (bossBatIdleImg.onload = r)),
        new Promise((r) => (bossBatDeathImg.onload = r)),
        new Promise((r) => (bossBatAttackImg.onload = r)),
        new Promise((r) => (demonSlimeAllStatesImg.onload = r)),
        new Promise((r) => (bloodSplatImg.onload = r)),
        new Promise((r) => (enemyImg.onload = r)),
        new Promise((r) => (goblinIdleImg.onload = r)),
        new Promise((r) => (goblinDieImg.onload = r)),
        new Promise((r) => (effectsImg.onload = r)),
        new Promise((r) => (purpleEffectsImg.onload = r)),
        new Promise((r) => (healingEffectsImg.onload = r)),
        new Promise((r) => (lightningEffectsImg.onload = r)),
        new Promise((r) => (darkBoltEffectsImg.onload = r)),
        new Promise((r) => (bloodSplatEffectsImg.onload = r)),
        new Promise((r) => (bloodStormEffectsImg.onload = r)),
        new Promise((r) => (priestSmiteEffectsImg.onload = r)),
        new Promise((r) => (priestHolyWaveEffectsImg.onload = r)),
        new Promise((r) => (priestRegrowthEffectsImg.onload = r)),
        new Promise((r) => (panelBrownImg.onload = r)),
        new Promise((r) => (buttonLongBeigeImg.onload = r)),
      ]).then(() => {
        init();
        requestAnimationFrame(loop);
      });
    </script>
  </body>
</html>
