<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>RPG Battle Game</title>
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@latest/dist/index.min.js"></script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Jacquard+24&family=Jersey+10&display=swap");

      body {
        margin: 0;
        padding: 0;
        background: black;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        font-family: "Press Start 2P", monospace;
        overflow: hidden; /* Evitar scrollbars */
      }
      canvas {
        display: block;
        image-rendering: pixelated;
        width: 100%;
        height: 100%;
        max-width: 100%;
        max-height: 100%;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script>
      /* =============================
      CORE: Canvas & Layout Setup
      ============================= */
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const designWidth = 360;
      const designHeight = 640;
      // Flag de modo desarrollador (botones y utilidades temporales)
      const DEV_MODE = false; // Desactivado: botón Dev L4 oculto
      const screenCenterX = designWidth / 2; // Centro exacto de pantalla: 180px

      // Constantes de layout para áreas fijas
      const HEADER_HEIGHT = 60;
      const FOOTER_HEIGHT = 120;
      const FOOTER_Y = 520;
      const GAME_AREA_Y = HEADER_HEIGHT;
      const GAME_AREA_HEIGHT = FOOTER_Y - HEADER_HEIGHT; // 460px de área de juego

      /* =============================
         CONFIG: Centralized immutable settings (solo lectura)
         Nota: Se añaden referencias; el código existente sigue usando las
         constantes originales para evitar riesgos. Futuras ampliaciones
         pueden leer desde SETTINGS.* sin refactors masivos.
         ============================= */
      const SETTINGS = Object.freeze({
        layout: Object.freeze({
          designWidth,
          designHeight,
          headerHeight: HEADER_HEIGHT,
          footerHeight: FOOTER_HEIGHT,
          footerY: FOOTER_Y,
          gameAreaY: GAME_AREA_Y,
          gameAreaHeight: GAME_AREA_HEIGHT,
        }),
        turn: Object.freeze({
          maxCharge: 100,
        }),
        waves: Object.freeze({
          levelWaveSpan: 3, // Waves por nivel
        }),
        fx: Object.freeze({
          hitNumberRise: 40, // desplazamiento vertical estándar
        }),
      });

      const dpr = window.devicePixelRatio || 1;

      // Función para calcular el tamaño responsivo del canvas
      function calculateCanvasSize() {
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;

        // Calcular la escala manteniendo la proporción del diseño original (360x640)
        const designAspectRatio = designWidth / designHeight;
        const windowAspectRatio = windowWidth / windowHeight;

        let canvasWidth, canvasHeight;

        // Escalar al máximo manteniendo relación de aspecto (letterbox si sobra espacio)
        if (windowAspectRatio > designAspectRatio) {
          // Ventana más ancha: llenamos altura completa
          canvasHeight = windowHeight;
          canvasWidth = canvasHeight * designAspectRatio;
        } else {
          // Ventana más alta: llenamos anchura completa
          canvasWidth = windowWidth;
          canvasHeight = canvasWidth / designAspectRatio;
        }

        return { width: canvasWidth, height: canvasHeight };
      }

      // Función para redimensionar el canvas
      function resizeCanvas() {
        const size = calculateCanvasSize();

        canvas.width = designWidth * dpr;
        canvas.height = designHeight * dpr;
        ctx.scale(dpr, dpr);
        canvas.style.width = size.width + "px";
        canvas.style.height = size.height + "px";
      }

      // Configurar tamaño inicial del canvas
      resizeCanvas();

      // Redimensionar cuando cambie el tamaño de la ventana
      window.addEventListener("resize", resizeCanvas);

      /* =============================
      ASSETS: IMAGES (Backgrounds & Sprites)
      ============================= */
      // Load images
      // Fondos de BATALLA (restaurados a los originales)
      const backgroundImg = new Image();
      backgroundImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ChatGPT%20Image%2010%20ago%202025%2C%2001_31_21-11GclhftpsCG06vNEd4ri4gVBVUY8o.png?aymA";

      const backgroundLevel2Img = new Image();
      backgroundLevel2Img.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/red_dunes-elmz1XktqRUANSNvvj8jYAoxXZsMkt.png?t9TH";

      const backgroundLevel3Img = new Image();
      backgroundLevel3Img.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/dark_swamp-eMmE7CgLp4Bx3xpLSgXlriVLfXN325.png?opu2";

      // Level 4 battle background (Soul Rift)
      const backgroundLevel4Img = new Image();
      backgroundLevel4Img.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/soul_rift_map-i4rZ3PDktCDQHQQIrA9wWHeuOuXtU3.png?ZCgL";

      // Background para pantallas de información de nivel
      const levelInfoBackgroundImg = new Image();
      levelInfoBackgroundImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/crypt-PNZ7duhJjKjlUmf5WnW33JBy22gVjQ.png?OGU6"; // Default level 1

      // Backgrounds específicos para cada nivel de información
      const level1InfoBg = new Image();
      level1InfoBg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/the_crypt-JDJFhsQimpr3nkg32WSsAN6ic00Qrn.png?Wkbe";

      const level2InfoBg = new Image();
      level2InfoBg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/red_dunes-Ao56Lt2qAkHIlR5FYxiSMw9UgasgK2.png?vchj";

      const level3InfoBg = new Image();
      level3InfoBg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/dark_swamp-uPwlcLV7WEy1xF5LUUoi0EJ4GP35Jn.png?lVVa";

      // Level 4 pre-level background (Soul Rift)
      const level4InfoBg = new Image();
      level4InfoBg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/soul_rift-M8KW3raAHJFHnNRxYusMeU1oXzgnu9.png?eh9f";

      // Background para pantalla de inicio
      const mainMenuImg = new Image();
      // Nueva pantalla de inicio
      mainMenuImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/imagen_inicio-7nBR9ar51GDJZmfw8MQTlVjwjfM21y.png?5icp";

      // Imagen de calavera para reemplazar texto DEAD
      const skullDeadImg = new Image();
      skullDeadImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/skulldead-bNFH0XzQQRwQp2QhIu3RrQiIlCfu6F.png?433O";

      // Background para el Book
      const bookBackgroundImg = new Image();
      bookBackgroundImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/fondo_book-AN2QslDiEGnJY1esoB29QQ8JlzX3Uq.png?6KnD";

      // Background dinámico que cambia según el nivel
      let currentBackgroundImg = backgroundImg; // Empezar con The Crypt (nivel 1)
      const mageImg = new Image();
      mageImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/mage-TnWuIwL8nfQgfspUHLdQb117UZpBR3.png?ddSR";
      const priestImg = new Image();
      priestImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/priest-DZKVrCXOeqMuQCe0Rid7DctIkoe4m0.png?XbMV";
      const warlockImg = new Image();
      warlockImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/warlock-ufYIrOZWd5mtgudqtQ8Yd34rteekHt.png?6IzB";

      // Enemy sprites - Demon Bat (Level 1)
      const demonBatIdleImg = new Image();
      demonBatIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/IDLE-V90NoEl8WQxdfu93X92hoipQtHfW7y.png?O0Ak";
      const demonBatDeathImg = new Image();
      demonBatDeathImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/DEATH-r9w4VgFSi93NjgHhRKFPjbBK3x4XYS.png?VLXN";
      const demonBatAttackImg = new Image();
      demonBatAttackImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ATTACK-ZCinJufJA25jik8Qm2R3DSZEdfIHez.png?iCFX";

      // Enemy sprites - Worm (Level 2)
      const wormIdleImg = new Image();
      wormIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/worm_idle-vJDVrN0IWXKWwxGqO3oaeE5VfdeiHx.png?rwdu";
      const wormDeathImg = new Image();
      wormDeathImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/worm_dead-fjt1PKqQPfa4Ql1iEJn92utXSHg48b.png?8dpt";
      const wormAttackImg = new Image();
      wormAttackImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/worm_attack-Lh6J61U6HqA0OHAbOC558yTFytcB58.png?yXF1";

      // Boss Minotaur sprites (Level 2 Boss) - Todas las animaciones en un solo sprite sheet
      const minotaurAllStatesImg = new Image();
      minotaurAllStatesImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/minotaur-sheet-Bv1KHH5UMJznTKr0gBV7kf6WUmOwZr.png?ZYdW";

      // Enemy sprites - Crab Bomb (Red Dunes special enemy)
      const crabBombIdleImg = new Image();
      crabBombIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ExplodingCrab%20Idle%2080x80-0xtADn8zveaJ99wQ8iQ0n4ilSjdiE9.png?UHf2";
      const crabBombDeathImg = new Image();
      crabBombDeathImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ExplodingCrab%20Death%2080x80-zDqZ4Ap4lWpensLHh3Lc2duYTtJCbG.png?1H5H";
      const crabBombExplodeImg = new Image();
      crabBombExplodeImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ExplodingCrab%20Explosion%2080x80-s3lRsNv4geuEqgjeWnasKtj6ibp1Iq.png?2GI8";

      // Enemy sprites - Mushroom (Dark Swamp normal enemy)
      const mushroomIdleImg = new Image();
      mushroomIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Mushroom-Idle-EbLaNtWreU7hEFwLThlVXyUUJUJbai.png?F111";
      const mushroomDeathImg = new Image();
      mushroomDeathImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Mushroom-Die-7HLapaD04zcX4shcBLZ3Wou2eClQCS.png?woNV";

      // Enemy sprites - Dreadwing (Dark Swamp flying enemy)
      const dreadwingIdleImg = new Image();
      dreadwingIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/swamp1_idle-ptG3GPSMeKcPxFdkhF4wXppEuKuIa8.png?XaXC";
      const dreadwingDeathImg = new Image();
      dreadwingDeathImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/swamp1_die-DP89ewxMkNaTGlxgh0HvP1gMsBdALz.png?AIEw";

      // Boss Swamp Gorgon sprites (Level 3 Boss) - Sprites individuales
      const swampGorgonIdleImg = new Image();
      swampGorgonIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Idle-2lKYMS7BBvm0cmpt5PyeU5VHN6g9Wj.png?gXER";

      const swampGorgonAttackImg = new Image();
      swampGorgonAttackImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Attack_2-nIg5G4WQX6MvAqgvOZEvC7jqkPlirE.png?t6rx";

      const swampGorgonSpecialAttackImg = new Image();
      swampGorgonSpecialAttackImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Attack_1-ORaqcWCCsweJHmdryjOSJqMYt9F9v2.png?XGn6";

      const swampGorgonDeathImg = new Image();
      swampGorgonDeathImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Dead-iRXzEKgppuyOurS2Ss4otFen8wiy1N.png?xC4K";

      // Boss Bat sprites (Level 1 Boss)
      const bossBatIdleImg = new Image();
      bossBatIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/IDLE_BOSS_1-N75RUTJp8bkxCSPZuvUWDye1KogjOS.png?C7Ns";
      const bossBatDeathImg = new Image();
      bossBatDeathImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/DEATH_BOSS_1-gjjAV8gTr6DBjZQ94xcwKAM8y63w2h.png?2Akf";
      const bossBatAttackImg = new Image();
      bossBatAttackImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ATTACK_BOSS_1-FArHbCZ2DrOKLJj2YyFvpSztZ5Ryq9.png?SSuQ";

      // Boss special ability effect
      const bloodSplatImg = new Image();
      bloodSplatImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Blood%20Splat-0zg8BGvPxZDBDQds5ZQiTgB7o5ebiC.png?59te";

      // Mantener sprites antiguos para compatibilidad temporal
      const enemyImg = new Image();
      enemyImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/beast_gigasChad-jHhAfiqtBGKuiIHRZJ0MkWs0W5uFQ5.png?9LBT";
      const goblinIdleImg = new Image();
      goblinIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/IDLE-V90NoEl8WQxdfu93X92hoipQtHfW7y.png?O0Ak";
      const goblinDieImg = new Image();
      goblinDieImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/DEATH-r9w4VgFSi93NjgHhRKFPjbBK3x4XYS.png?VLXN";

      // Sprites de efectos de habilidades
      const effectsImg = new Image();
      effectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Red%20Effect%20Bullet%20Impact%20Explosion%2032x32-NnvGEsfH13xUZuEqmJAXk2oelYwGoV.png?b5e9";

      // Sprites de efectos púrpura para warlock
      const purpleEffectsImg = new Image();
      purpleEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Purple%20Effect%20Bullet%20Impact%20Explosion%2032x32-tBftQaSwItblEIfJStK8fGzQZEaFvQ.png?7m6v";

      // Sprite de efectos de curación
      const healingEffectsImg = new Image();
      healingEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Regen-IsFeOv1fkkRBrdZ1wZqoyhE5DrXPmz.png?22AH";

      // Sprite de efectos de rayo para Smite
      const lightningEffectsImg = new Image();
      lightningEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Lightning-JDFXQsYo47LoZYiuRiYJRnGOxeYgZc.png?8HcK";

      // Sprite de efectos de Dark Bolt para Inmolation
      const darkBoltEffectsImg = new Image();
      darkBoltEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Dark-Bolt-XsHZlOlUknjRLKGCm3oDIfLlJimYCf.png?Lpbv";

      // Sprite de efectos de Blood Splat para Boss Bat (habilidad principal - un solo aliado)
      const bloodSplatEffectsImg = new Image();
      bloodSplatEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/sprite-sheet2-fpBxr82a3zc37rRAF6S573qRmIXtGU.png?ANvP";

      // Sprite de efectos de Blood Storm para Boss Bat (habilidad especial - todos los aliados)
      const bloodStormEffectsImg = new Image();
      bloodStormEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/sprite-sheet-F3tkTJhh68R3ZU2T2GrvwFXwEamfaf.png?pJmM";

      // Sprites mejorados para habilidades del Priest
      const priestSmiteEffectsImg = new Image();
      priestSmiteEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/smite-Bjk86Soi2Gf9vFJBLWIvzPGFBp44Hf.png?WXvo";

      // ================================
      // SPRITES DE HABILIDADES NIVEL 4
      // ================================

      // Voidspecter: Dark Bolt sobre héroes (1024x128, 128x128 por frame, 8 frames en row)
      const voidspecterDarkBoltImg = new Image();
      voidspecterDarkBoltImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/dark-bolt-7GYOFPH5CXZPL17wteENuftXrTP7FA.png?JXMQ";

      // Portal de invocación del Abyss King (256x128, frames 64x64 en grid 2x4, 7 frames)
      const summonPortalImg = new Image();
      summonPortalImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/summon-void-5THyENdT5XCnYx2ZOp25oWksbaihmO.png?vAr3";

      // The Hand: Dark Protection sobre enemigos (640x640, 128x128 por frame, 5x5 grid, 23 frames)
      const theHandDarkProtectionImg = new Image();
      theHandDarkProtectionImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/dark-protection-vzaEtL8uiM47RP4MqlzSfMWY4IMpsk.png?4JzZ";

      // Abyss King: Abyss Strike habilidad principal (768x521, 128x128 por frame, 4x6 grid, 23 frames)
      const abyssKingMainAbilityImg = new Image();
      abyssKingMainAbilityImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/abyss-main-lRmDsAB85DIDZoj6nOhk98vZEXAhpo.png?lUdR";

      // ================================
      // NUEVOS SPRITES DE HABILIDADES HÉROES
      // ================================

      // Warlock Agony - 384x512, 128x128 por frame, 12 frames en grid 3x4
      const warlockAgonyImg = new Image();
      warlockAgonyImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/warlock-shield-eVxogrqVTuPBqp7W8kV9SpU8orNfBa.png?POLR";

      // Warlock Dark Slash - 384x384, 128x128 por frame, 7 frames en grid 3x3
      const warlockDarkSlashImg = new Image();
      warlockDarkSlashImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/warlock-slash-i6Us4qeV9aeZJ7SsbtxZWXu08Zjo5X.png?4pFM";

      // Warlock Inmolation - Sprite 1: 384x640, 128x128 por frame, 15 frames en grid 3x5
      const warlockInmolation1Img = new Image();
      warlockInmolation1Img.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/warlock-inmolate-7TUHFRDfA26dXoDr2FtWqPmkCfuOS5.png?PTrv";

      // Warlock Inmolation - Sprite 2: 384x384, 128x128 por frame, 9 frames en grid 3x3
      const warlockInmolation2Img = new Image();
      warlockInmolation2Img.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/warlock-inmolate2-oytDej0HF0mGCpx4yx8MayEsyVv5TT.png?LQpB";

      // Mage Fireblast - 640x256, 128x128 por frame, 7 frames en grid 5x2
      const mageFireblastImg = new Image();
      mageFireblastImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/mage-main-meid90aP1egARPAYmEISJIHdIQCDa6.png?Wjyq";

      // Gorgon Main Ability - 1280x384, 256x192 por frame, 10 frames en grid 5x2
      const gorgonMainAbilityImg = new Image();
      gorgonMainAbilityImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/gorgon-main-hg8wm1ulF6OSdp6lPtLTxRSR2HQ0SS.png?HxZ7";

      // Gorgon Special Ability - 1152x128, 192x128 por frame, 6 frames en row
      const gorgonSpecialAbilityImg = new Image();
      gorgonSpecialAbilityImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/gorgon-special-i1qC0MoaGWIWFV3DXotShqaIfjH666.png?NUQ5";

      /* =============================
     ASSETS: AUDIO (Music & SFX)
     ============================= */

      // Música de fondo
      const menuMusic = new Audio();
      menuMusic.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/inicio-MQDiXSPNvWEeB155H9x56e222bHZLS.mp3?make";
      menuMusic.loop = true;
      menuMusic.volume = 0.4; // Volumen inicial

      const level1Music = new Audio();
      level1Music.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/crypt-LZN8TdnXRiyblZvvzcWPzT7uoQYwz7.mp3?Hg5w";
      level1Music.loop = true;
      level1Music.volume = 0.2; // Volumen reducido para niveles
      const level4Music = new Audio();
      level4Music.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/level4-PLhuzIrAhqaoh6r5Ei03cec2lyrOcr.mp3?mf0H";
      level4Music.loop = true;
      level4Music.volume = 0.2;

      const level2Music = new Audio();
      level2Music.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/dunes-ru73QsoLV35gEZQ55A3rk09T8uleBr.mp3?tVGO";
      level2Music.loop = true;
      level2Music.volume = 0.2; // Volumen reducido para niveles

      const level3Music = new Audio();
      level3Music.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/swamp-UzVNiCOnEhv4JAiX6bpWBSjdpSQ3HR.mp3?fyCd";
      level3Music.loop = true;
      level3Music.volume = 0.2; // Volumen reducido para niveles

      // Efectos de sonido para hechizos
      const mageSpellSound = new Audio();
      mageSpellSound.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/fire-4xwSm7LSlrGc8FWd3CFstxoWINubeG.mp3?7yyv";
      mageSpellSound.volume = 0.6;

      const healSound = new Audio();
      healSound.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/heal-TiCdRKJwwC3qIRZnJFOVVBl2QcQlcO.mp3?ZSQJ";
      healSound.volume = 0.6;

      const smiteSound = new Audio();
      smiteSound.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/smite-ZK5nk41gDDoOYphPE6NCGNtBM9KeUl.mp3?Wkvu";
      smiteSound.volume = 0.6;

      const slashSound = new Audio();
      slashSound.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/slash-ODPOGnjPy7ZKZtYaiES5z2YFTjcZ8r.mp3?M7FY";
      slashSound.volume = 0.6;

      const inmolationSound = new Audio();
      inmolationSound.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/inmolation-mVevlPxJHzaIYbV1pteo7O80Ve5UsI.mp3?O3PH";
      inmolationSound.volume = 0.6;

      const agonySound = new Audio();
      agonySound.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/agony-Un5jNoMJYl7yaAjjPGr1FfZoqeue0N.mp3?xV6m";
      agonySound.volume = 0.6;

      // Variables para control de música
      let currentMusic = null;
      let pendingSounds = []; // Array para manejar sonidos con delay
      let audioInitialized = false; // Para manejar el autoplay de navegadores
      let userHasInteracted = false; // Para rastrear si el usuario ha interactuado
      let pendingMusicToPlay = null; // Música que se debe reproducir cuando el usuario interactúe

      // Funciones de control de audio
      function initializeAudio() {
        if (!audioInitialized && userHasInteracted) {
          /* log removed */

          // Inicializar contexto de audio de forma más simple
          const initAudio = new Audio();
          initAudio.volume = 0;
          initAudio.src =
            "data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwgAztw0O7ZkUcQFE2c6+OmWRYSVZPl7K1NDQxRneftuGMeAztp1etqx6s4AAAq"; // Wav silencioso

          initAudio
            .play()
            .then(() => {
              initAudio.pause();
              audioInitialized = true;

              // Reproducir música pendiente si la hay después de un pequeño delay
              if (pendingMusicToPlay) {
                /* log removed */
                setTimeout(() => {
                  playMusicNow(pendingMusicToPlay);
                  pendingMusicToPlay = null;
                }, 100);
              }
            })
            .catch((e) => {
              /* log removed */
              // Aún así marcar como inicializado para intentar reproducir música
              audioInitialized = true;
              if (pendingMusicToPlay) {
                setTimeout(() => {
                  playMusicNow(pendingMusicToPlay);
                  pendingMusicToPlay = null;
                }, 100);
              }
            });
        }
      }

      function playMusicNow(audioElement) {
        // Detener música actual si existe
        if (currentMusic && currentMusic !== audioElement) {
          currentMusic.pause();
          currentMusic.currentTime = 0;
        }

        currentMusic = audioElement;

        // Reproducir nueva música con manejo robusto
        audioElement.currentTime = 0;
        const playPromise = audioElement.play();

        if (playPromise !== undefined) {
          playPromise.catch((e) => {
            /* log removed */
            // Intentar de nuevo después de un breve delay
            setTimeout(() => {
              /* log removed */
              audioElement.currentTime = 0;
              audioElement.play().catch((e2) => {
                /* log removed */
              });
            }, 300);
          });
        }
      }

      function playMusic(audioElement) {
        if (!userHasInteracted) {
          // Si el usuario no ha interactuado, guardar la música para reproducir después
          pendingMusicToPlay = audioElement;
          /* log removed */
          return;
        }

        initializeAudio();
        playMusicNow(audioElement);
      }

      function stopAllMusic() {
        [menuMusic, level1Music, level2Music, level3Music, level4Music].forEach(
          (music) => {
            music.pause();
            music.currentTime = 0;
          }
        );
        currentMusic = null;
      }

      // Función para manejar la primera interacción del usuario
      function handleFirstInteraction() {
        if (!userHasInteracted) {
          /* log removed */
          userHasInteracted = true;
          initializeAudio();

          // Remover los listeners después de la primera interacción
          document.removeEventListener("click", handleFirstInteraction, true);
          document.removeEventListener(
            "touchstart",
            handleFirstInteraction,
            true
          );
          document.removeEventListener("keydown", handleFirstInteraction, true);
        }
      }

      // Agregar listeners para detectar la primera interacción (useCapture = true para asegurar que se ejecute)
      document.addEventListener("click", handleFirstInteraction, true);
      document.addEventListener("touchstart", handleFirstInteraction, true);
      document.addEventListener("keydown", handleFirstInteraction, true);

      function playSpellSound(spellName, delay = 0) {
        if (!userHasInteracted) {
          /* log removed */
          return;
        }

        initializeAudio();

        let soundToPlay = null;

        // Determinar qué sonido reproducir según el hechizo
        switch (spellName) {
          case "fireblast":
          case "combustion":
          case "inferno":
            soundToPlay = mageSpellSound;
            break;
          case "holywave":
          case "regrowth":
            soundToPlay = healSound;
            break;
          case "smite":
            soundToPlay = smiteSound;
            break;
          case "darkslash":
            soundToPlay = slashSound;
            break;
          case "inmolation":
            soundToPlay = inmolationSound;
            break;
          case "agony":
            soundToPlay = agonySound;
            break;
          default:
            return; // No hay sonido para este hechizo
        }

        if (delay > 0) {
          // Programar el sonido para más tarde
          pendingSounds.push({
            sound: soundToPlay,
            time: currentTime + delay,
          });
        } else {
          // Reproducir inmediatamente
          soundToPlay.currentTime = 0;
          soundToPlay.play().catch((e) => {
            /* log removed */
          });
        }
      }

      function updatePendingSounds() {
        // Verificar si hay sonidos pendientes que deben reproducirse
        for (let i = pendingSounds.length - 1; i >= 0; i--) {
          const pendingSound = pendingSounds[i];
          if (currentTime >= pendingSound.time) {
            pendingSound.sound.currentTime = 0;
            pendingSound.sound.play().catch((e) => {
              /* log removed */
            });
            pendingSounds.splice(i, 1);
          }
        }
      }

      const priestHolyWaveEffectsImg = new Image();
      priestHolyWaveEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/heal-3Xw84tzIf6iA8iM9A7ATJFLffNucdb.png?VXbc";

      const priestRegrowthEffectsImg = new Image();
      priestRegrowthEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/regrowth-jwXtVqqCJVlVmtGbVon46zD1y7zmbJ.png?YYsp";

      // Minotaur effects sprites
      const minotaurSmashEffectsImg = new Image();
      minotaurSmashEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/minotaur_normal-3TLpHMzhlYcUnC1CBuUC2d2VRA3DpS.png?n1Bm";

      const minotaurLifeStealEffectsImg = new Image();
      minotaurLifeStealEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/minotaur_special-zBxxGSBFlpUHDEVfULo1Qk6KuB00K6.png?uuJE";

      // Nuevos efectos mejorados
      const combustionEffectsImg = new Image();
      combustionEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/combustion-0ifHizZSGTiojCA9n7UpSkfkqn6qM5.png?18TW";

      const cthuluMainEffectsImg = new Image();
      cthuluMainEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/poison_main-vaefYRxX0tC5YTqWpWFboyItMAK9sC.png?tqGw";

      const cthuluSpecialEffectsImg = new Image();
      cthuluSpecialEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/poison_special-6DGH6sKHmuBlpk3clAxyhJ1fDcCcpy.png?tmXd";

      // Debuff/Buff Icons
      // Debuffs - Iconos individuales mejorados
      const healingDebuffImg = new Image();
      healingDebuffImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/healing-JlGWLUS50cotiFMVNedgFNHGdj8i74.png?vSGj"; // Nuevo Healing

      const agonyDebuffImg = new Image();
      agonyDebuffImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/agony-0SM70iA5cqUkyXxlHaTfsOxwFvadKp.png?AlDq"; // Nuevo Agony

      const protectionDebuffImg = new Image();
      protectionDebuffImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/protec-X9cTS5hoFr9md7Ltog9G5yC5SKScv4.png?zi1r";

      const combustionDebuffImg = new Image();
      combustionDebuffImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/combustion-CxIzzUzBk4oPuQ1gGkBVWCwQptH44e.png?gLcT"; // Nuevo Combustion

      const bersekerDebuffImg = new Image();
      bersekerDebuffImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/berseker-NN5svWH5xidOyYGTy8zhXiBq3S1CBQ.png?0wfy"; // Nuevo Berseker

      const poisonDebuffImg = new Image();
      poisonDebuffImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/poison-cGrKXY0PtqlbolksreDUBiacGHXUKZ.png?mgi9"; // Nuevo Poison

      const shadowsDebuffImg = new Image();
      shadowsDebuffImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/shadows-476pkIz4pceeRZyDJr4BRv85Dj9mTA.png?C439"; // Nuevo Shadows

      const darkProtectionDebuffImg = new Image();
      darkProtectionDebuffImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/dark_protection-f5URQBJVhJnNmZamNr9bBpBgdiAJ5s.png?vd0n"; // Nuevo Dark Protection

      // Configuración de niveles - CORREGIDO PARA DARK SWAMP LEVEL 3
      /* =============================
      CONFIG: Level Configuration (enemies, backgrounds, stats)
      ============================= */
      const levelConfig = {
        1: {
          name: "The Crypt",
          background:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ChatGPT%20Image%2010%20ago%202025%2C%2001_31_21-11GclhftpsCG06vNEd4ri4gVBVUY8o.png?aymA",
          enemies: {
            normal: {
              name: "Demon Bat",
              hp: 80, // Según especificaciones
              sprites: {
                idle: demonBatIdleImg,
                death: demonBatDeathImg,
                attack: demonBatAttackImg,
              },
              frameWidth: 81,
              frameHeight: 71,
              idleFrames: 4,
              deathFrames: 6,
              attackFrames: 8,
              chargeSpeed: 40, // Aumentado (+2 rating)
              chargeSpeedRating: 8, // Subido de 6 a 8
              size: 80,
              isFlying: true, // Volador según especificaciones
              mainAbility: "basic_attack", // Habilidad básica que hace daño bajo/intermedio a héroe aleatorio
            },
            boss: {
              name: "Noctebane", // Boss renombrado según especificaciones
              hp: 200, // Según especificaciones
              sprites: {
                idle: bossBatIdleImg,
                death: bossBatDeathImg,
                attack: bossBatAttackImg,
              },
              frameWidth: 81,
              frameHeight: 71,
              idleFrames: 4,
              deathFrames: 6,
              attackFrames: 8,
              chargeSpeed: 30, // 6/10 velocidad según especificaciones
              chargeSpeedRating: 6, // 6/10 velocidad según especificaciones
              size: 120,
              specialAttackCounter: 3, // 3 esferas para habilidad especial
              mainAbility: "blood_splat", // Blood Splat: daño normal a héroe aleatorio
              specialAbility: "blood_storm", // Blood Storm: daña a todos los héroes
              isFlying: true, // Volador según especificaciones
            },
          },
        },
        3: {
          name: "Dark Swamp",
          background:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/dark_swamp-eMmE7CgLp4Bx3xpLSgXlriVLfXN325.png?opu2",
          enemies: {
            normal: {
              name: "Mushroom",
              hp: 100, // ✅ Correcto según especificaciones
              sprites: {
                idle: mushroomIdleImg,
                death: mushroomDeathImg,
                attack: mushroomIdleImg, // Usar idle para attack por ahora
              },
              frameWidth: 80, // 560px / 7 frames = 80px por frame
              frameHeight: 64,
              idleFrames: 7, // 7 frames en row para IDLE
              deathFrames: 15, // 15 frames en row para DIE
              attackFrames: 7, // Mismo que idle
              chargeSpeed: 30, // Corregido para 6/10 velocidad
              chargeSpeedRating: 6, // Corregido: 6/10 velocidad según especificaciones
              size: 120, // Aumentado de 100 a 120
              isFlying: false, // Terrestre
              mainAbility: "poison_attack", // Ataque con veneno
            },
            flying: {
              name: "Dreadwing",
              hp: 90, // Corregido: era 80, ahora 90 según especificaciones
              sprites: {
                idle: dreadwingIdleImg,
                death: dreadwingDeathImg,
                attack: dreadwingIdleImg, // Usar idle para attack por ahora
              },
              frameWidth: 64,
              frameHeight: 64,
              idleFrames: 8,
              deathFrames: 17,
              attackFrames: 8, // Mismo que idle
              chargeSpeed: 25, // Corregido para 5/10 velocidad
              chargeSpeedRating: 5, // Corregido: 5/10 velocidad según especificaciones
              size: 90,
              isFlying: true, // Volador
              mainAbility: "double_strike", // Ataque doble
            },
            boss: {
              name: "Gorgon",
              hp: 400, // Corregido: era 350, ahora 400 según especificaciones
              sprites: {
                idle: swampGorgonIdleImg,
                death: swampGorgonDeathImg,
                attack: swampGorgonAttackImg,
                specialAttack: swampGorgonSpecialAttackImg,
              },
              frameWidth: 128, // 128x128 cada frame
              frameHeight: 128,
              idleFrames: 7, // 7 frames para IDLE
              deathFrames: 3, // 3 frames para DIE
              attackFrames: 7, // 7 frames para NORMAL_ATTACK
              specialAttackFrames: 16, // 16 frames para SPECIAL_ATTACK
              chargeSpeed: 30, // Corregido para 6/10 velocidad
              chargeSpeedRating: 6, // Corregido: 6/10 velocidad según especificaciones
              size: 180, // Tamaño reducido para mejor proporción
              specialAttackCounter: 3,
              mainAbility: "poison_strike", // Corregido: nombre según especificaciones
              specialAbility: "toxic_horror", // Mantener la misma habilidad especial
              isFlying: false, // Terrestre
            },
          },
        },
        2: {
          name: "Red Dunes",
          background:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/red_dunes-elmz1XktqRUANSNvvj8jYAoxXZsMkt.png?t9TH",
          enemies: {
            normal: {
              name: "Fire Worm",
              hp: 80, // Según especificaciones
              sprites: {
                idle: wormIdleImg,
                death: wormDeathImg,
                attack: wormAttackImg,
              },
              frameWidth: 90,
              frameHeight: 90,
              idleFrames: 9,
              deathFrames: 8,
              attackFrames: 16,
              chargeSpeed: 30, // 6/10 velocidad según especificaciones
              chargeSpeedRating: 6, // 6/10 velocidad según especificaciones
              size: 130,
              isFlying: false, // Terrestre
              mainAbility: "basic_attack", // Ataque básico intermedio
            },
            special: {
              name: "Crab Bomb",
              hp: 150, // Según especificaciones
              sprites: {
                idle: crabBombIdleImg,
                death: crabBombDeathImg,
                attack: crabBombIdleImg, // Usar idle como fallback
                explode: crabBombExplodeImg, // Sprite especial para explosión
              },
              frameWidth: 80, // 80x80 según especificaciones
              frameHeight: 80,
              idleFrames: 13, // 1040px / 80px = 13 frames
              deathFrames: 6, // 480px / 80px = 6 frames
              explodeFrames: 23, // 1840px / 80px = 23 frames
              chargeSpeed: 25, // 5/10 velocidad según especificaciones
              chargeSpeedRating: 5, // 5/10 velocidad según especificaciones
              size: 120,
              isFlying: false, // Terrestre
              mainAbility: "explode", // Habilidad especial de explosión
              specialAttackCounter: 5, // 5 esferas como especificado
              noBasicAttack: true, // No tiene habilidad básica
            },
            boss: {
              name: "Minotaur",
              hp: 300, // Según especificaciones
              sprites: {
                idle: minotaurAllStatesImg,
                death: minotaurAllStatesImg,
                attack: minotaurAllStatesImg,
              },
              frameWidth: 288,
              frameHeight: 160,
              idleFrames: 16, // Primera fila: IDLE 16 frames
              deathFrames: 16, // No hay animación de muerte, usar idle/attack para transición
              attackFrames: 16, // Segunda fila: ATTACK 16 frames
              chargeSpeed: 30, // Subido a 6/10 velocidad base
              chargeSpeedRating: 6, // Subido a 6/10 y puede seguir escalando
              size: 320,
              specialAttackCounter: 3, // Contador para ataque especial
              mainAbility: "smash", // Nombre correcto según especificaciones
              specialAbility: "life_steal", // Nombre correcto según especificaciones
              isFlying: false, // Terrestre
            },
          },
        },
        // Aquí se añadirán más niveles en el futuro
        4: {
          name: "Soul Rift",
          background:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/soul_rift_map-i4rZ3PDktCDQHQQIrA9wWHeuOuXtU3.png?ZCgL",
          enemies: {
            voidspecter: {
              name: "Voidspecter",
              hp: 110,
              sprites: {
                idle: (() => {
                  const i = new Image();
                  i.src =
                    "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/wizard_level4_idle-7EvcH4zEibEfrCl7wBpXnkc7wOKPCa.png?epgj";
                  return i;
                })(),
                death: (() => {
                  const i = new Image();
                  i.src =
                    "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/wizard_level4_death-0LDBQ97J4thikMc69ynNvFkhjrqcI5.png?XPqw";
                  return i;
                })(),
                attack: null,
              },
              frameWidth: 80,
              frameHeight: 80,
              idleFrames: 10,
              deathFrames: 10,
              attackFrames: 10,
              chargeSpeed: 30,
              chargeSpeedRating: 6,
              size: 110,
              isFlying: true,
              mainAbility: "voidspecter_double",
            },
            thehand: {
              name: "The Hand",
              hp: 80,
              sprites: {
                idle: (() => {
                  const i = new Image();
                  i.src =
                    "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/hand-level4-idle-fp21qt00qnRnsvMiDFjaQYmGPAKOwV.png?fDpo"; // Nuevo idle
                  return i;
                })(),
                death: null,
                attack: (() => {
                  const i = new Image();
                  i.src =
                    "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/hand-level4-attack-RqDpUnNPswprL3zrS7URh7BmprR6I6.png?QOd4"; // 248x80 (4 frames de 62x80)
                  return i;
                })(),
              },
              frameWidth: 62,
              frameHeight: 80, // Altura corregida (antes 64)
              idleFrames: 8,
              deathFrames: 8,
              attackFrames: 4, // Sprite de ataque nuevo: 4 frames
              attackFrameHeight: 80, // Altura distinta para ataque
              chargeSpeed: 25,
              chargeSpeedRating: 5,
              size: 100,
              isFlying: false,
              mainAbility: "dark_protection",
              noBasicAttack: true,
            },
            boss: {
              name: "Abyss King",
              hp: 400,
              sprites: {
                idle: (() => {
                  const i = new Image();
                  i.src =
                    "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/skeleton-XsPylnGSOBvRiu1c7XplFB3aVKdlaA.png?NoJO"; // 1305x268 (2 filas) IDLE fila0 9 frames, ATTACK fila1 8 frames
                  return i;
                })(),
                death: null,
                attack: null,
              },
              frameWidth: 145, // 1305 / 9
              frameHeight: 134, // mitad de 268
              idleFrames: 9,
              deathFrames: 9, // reutiliza idle si no hay sprite separado
              attackFrames: 8, // segunda fila tiene 8
              chargeSpeed: 30,
              chargeSpeedRating: 6,
              size: 170, // reducido
              specialAttackCounter: 3, // reducido de 5 a 3 (cuenta atrás más corta solicitada)
              mainAbility: "abyss_strike",
              specialAbility: "abyss_summon",
              isFlying: false,
            },
          },
        },
      };

      // UI Elements - Solo los elementos que se usan
      const panelBrownImg = new Image();
      panelBrownImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/panel_brown-49f4SM1AoKwCYlEq9piZiXmfxdEC0G.png?ZpjN";

      const panelBeigeImg = new Image();
      panelBeigeImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/panel_beige-S87wunV71Sxq5QTxONuar0vD9W1LrV.png?sZSO";

      const buttonLongBeigeImg = new Image();
      buttonLongBeigeImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/buttonLong_beige-AkYz3mfJrwayHOsnKfj3J2cFcEajGT.png?vtgY";

      // Nuevo botón beige presionado para indicar selección pendiente de target
      const buttonLongBeigePressedImg = new Image();
      buttonLongBeigePressedImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/buttonLong_beige_pressed-AzV9xmFtI8yJOf2BZVcSUyyEaG7GYc.png?XSZY";

      const buttonLongBrownImg = new Image();
      buttonLongBrownImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/buttonLong_brown-oof3pI0kehlONOYt1I39gi6TcPr2Jm.png?KInj";

      const buttonRoundBeigeImg = new Image();
      buttonRoundBeigeImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/buttonRound_beige-cnUh8OwyVlFjAjg2lpGBuVJKnmwV4m.png?wzPo";

      const iconCrossBrownImg = new Image();
      iconCrossBrownImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/iconCross_brown-vkY074tDvp0pjArcKTQ6CYMIcBKwGO.png?V1qv";

      // Animations - actualizadas con nuevas habilidades
      const animationsMage = {
        selected: { row: 0, frames: 6, duration: 0.6 },
        idle: { row: 1, frames: 6, duration: 0.6 },
        fireblast: { row: 2, frames: 7, duration: 1 },
        combustion: { row: 4, frames: 6, duration: 1 }, // Usar la misma fila que inferno
        inferno: { row: 4, frames: 6, duration: 1 },
      };
      const animationsPriest = {
        selected: { row: 0, frames: 6, duration: 0.6 },
        idle: { row: 1, frames: 6, duration: 0.6 },
        holywave: { row: 2, frames: 7, duration: 1 },
        smite: { row: 3, frames: 6, duration: 1 },
        regrowth: { row: 4, frames: 6, duration: 1 },
      };
      const animationsWarlock = {
        selected: { row: 0, frames: 6, duration: 0.6 },
        idle: { row: 1, frames: 6, duration: 0.6 },
        darkslash: { row: 2, frames: 7, duration: 1 },
        agony: { row: 3, frames: 6, duration: 0.5 }, // Instantáneo
        inmolation: { row: 4, frames: 7, duration: 1 },
      };

      let score = 0;
      // Tiempo de inicio del nivel actual (para multiplicador de velocidad)
      let levelStartTime = 0;
      // Configuración del nuevo sistema de puntuación
      const SCORE_CONFIG = Object.freeze({
        waveBase: 400, // Puntos base por wave superada (400 × 3 = 1200 base por nivel)
        levelCompletion: 250, // Bonus adicional al finalizar cada nivel (250 extra)
        maxWaveGain: 1500, // Límite máximo de puntos por wave
        maxTotalScore: 500000, // Límite máximo total de puntuación
        // Multiplicador por tiempo (segundos empleados en el nivel actual)
        timeMultiplier(elapsedSec) {
          if (elapsedSec <= 30) return 1.5; // Muy rápido
          else if (elapsedSec <= 50) return 1.25; // Rápido
          else if (elapsedSec <= 70) return 1.1; // Aceptable
          return 1.0; // Lento
        },
        // Multiplicador por héroes vivos al cerrar la wave
        heroesAliveMultiplier(alive) {
          if (alive >= 3) return 1.5;
          if (alive === 2) return 1.2;
          return 1.0; // 1 o 0 (0 no debería darse porque sería game over)
        },
      });
      let wave = 0;
      let heroes = [];
      let enemies = [];
      let state = "main_menu";
      let selectedHero = null;
      let selectedAction = null;
      let turnPhase = "player";
      let currentEnemyIndex = 0;
      let slashStreak = 0;
      let currentTime = 0;
      let hitNumbers = []; // Array para almacenar los números de golpe flotantes
      let visualEffects = []; // Array para efectos visuales especiales
      let levelCompletionModal = { show: false, level: 0, boss: "", timer: 0 }; // Modal de finalización de nivel
      let currentLevel = 1; // Nivel actual del juego (1, 2, 3)
      // Sistema de turnos por cola
      let turnQueue = []; // Contendrá referencias directas a héroes o enemigos cuyo charge llegó a 100 en orden de llegada
      // Control para evitar múltiples procesamientos de wave
      let waveProcessed = false;

      // Variables de seguridad para el score
      let lastValidScore = 0;
      let scoreBackups = [];

      // Función para crear backup del score
      function backupScore() {
        if (
          typeof score === "number" &&
          !isNaN(score) &&
          score >= 0 &&
          score <= SCORE_CONFIG.maxTotalScore
        ) {
          lastValidScore = score;
          scoreBackups.push({
            score: score,
            timestamp: Date.now(),
            wave: wave,
          });
          // Mantener solo los últimos 5 backups
          if (scoreBackups.length > 5) {
            scoreBackups.shift();
          }
        }
      }

      // Función para restaurar score desde backup
      function restoreScore() {
        if (
          lastValidScore >= 0 &&
          lastValidScore <= SCORE_CONFIG.maxTotalScore
        ) {
          score = lastValidScore;
          console.log("Score restored from backup:", score);
          return true;
        }
        return false;
      }

      // Variables para monitoreo continuo
      let lastScoreCheckTime = 0;

      // Monitoreo continuo del score para detectar anomalías
      function monitorScore() {
        const now = performance.now();
        if (now - lastScoreCheckTime > 1000) {
          // Verificar cada segundo
          if (isNaN(score) || score < 0 || score > SCORE_CONFIG.maxTotalScore) {
            console.error(
              "Score anomaly detected! Current:",
              score,
              "Max allowed:",
              SCORE_CONFIG.maxTotalScore
            );
            if (!restoreScore()) {
              score = 0; // Último recurso
              console.warn("Score reset to 0 due to corruption");
            }
          } else {
            backupScore(); // Backup del score válido
          }
          lastScoreCheckTime = now;
        }
      }
      let activeAction = null; // Acción en curso (animación/delay) bloquea inicio de la siguiente
      let actionDelayTimer = 0; // Pequeño retardo antes de ejecutar el efecto de ataque enemigo
      // Sistema de turnos para debuffs turn-based
      let lastTurnEntity = null;
      // Entidad cuyo turno se preservará entre waves (ej: si una wave termina justo antes de que actúe)
      let preservedTurnEntity = null;
      let globalTurnCounter = 0; // Cuenta turnos globales (cada entidad que comienza turno)
      // Transición entre waves
      let waveTransition = { active: false, timer: 0, delay: 1.2 }; // 1.2s de margen
      let heroInputLocked = false; // Bloqueo temporal de habilidades entre waves
      // Flag para mostrar pantalla de información del siguiente nivel tras transición
      let pendingLevelInfo = false;

      // Sistema de detección de freeze de turnos
      let currentTurnStartTime = 0;
      let lastTurnQueueFront = null;
      const MAX_TURN_TIMEOUT = 10000; // 10 segundos máximo por turno

      // Función para detectar y resolver turnos congelados
      function checkTurnTimeout() {
        const now = performance.now();
        const currentFront = turnQueue.length > 0 ? turnQueue[0] : null;

        // Si cambió el frente de la cola, resetear timer
        if (currentFront !== lastTurnQueueFront) {
          currentTurnStartTime = now;
          lastTurnQueueFront = currentFront;
          return;
        }

        // Si hay una entidad en el frente y ha pasado demasiado tiempo
        if (currentFront && now - currentTurnStartTime > MAX_TURN_TIMEOUT) {
          console.error(
            `Turn timeout detected for ${
              currentFront.name || currentFront.clazz
            }! Forcing turn skip.`
          );

          // Para bosses, hacer limpieza más agresiva de héroes colgados
          if (currentFront.type === "boss") {
            console.warn(
              "Boss timeout - clearing all potential stuck hero actions"
            );
            heroes.forEach((h) => {
              if (h.action) {
                console.warn(
                  `Clearing stuck hero action: ${h.clazz} - ${h.action}`
                );
                h.action = null;
                h.targets = null;
                h.anim = "idle";
                h.animTime = 0;
                h.frame = 0;
                h.actionStartTime = null; // Limpiar timestamp
              }
            });
          }

          // Intentar skip normal primero
          forceTurnSkip(currentFront);

          // Si después del skip la cola sigue con problemas, hacer recovery completo
          if (turnQueue.length > 0 && turnQueue[0] === currentFront) {
            console.error("Turn skip failed, activating emergency recovery");
            emergencyTurnSystemRecovery();
          }

          // Resetear timer
          currentTurnStartTime = now;
          lastTurnQueueFront = turnQueue.length > 0 ? turnQueue[0] : null;
        }

        // Verificación adicional: si la cola está vacía pero hay entidades vivas con carga >= 100
        if (turnQueue.length === 0) {
          const chargedEntities = [...heroes, ...enemies].filter(
            (e) => e.hp > 0 && e.charge >= 100
          );

          if (chargedEntities.length > 0) {
            console.warn(
              "Turn queue empty but charged entities exist, rebuilding queue"
            );
            chargedEntities.forEach((e) => {
              if (!turnQueue.includes(e)) {
                turnQueue.push(e);
              }
            });
          }
        }
      }

      // Función para forzar el skip de un turno problemático
      function forceTurnSkip(entity) {
        console.warn(`Force skipping turn for ${entity.name || entity.clazz}`);

        // Limpiar estados problemáticos
        entity.charge = 0;
        entity.chargeFullTime = null;
        entity.animTime = 0;
        entity.anim = "idle";
        entity.frame = 0;
        entity.action = null;
        entity.actionStartTime = null; // Limpiar timestamp si existe

        // Si es la acción activa, limpiarla
        if (activeAction === entity) {
          activeAction = null;
          actionDelayTimer = 0;
        }

        // Remover de la cola de turnos
        const index = turnQueue.indexOf(entity);
        if (index >= 0) {
          turnQueue.splice(index, 1);
        }

        // Resetear last turn entity
        if (lastTurnEntity === entity) {
          lastTurnEntity = null;
        }

        // Para enemigos, resetear estados especiales
        if (!entity.clazz && entity.type === "boss") {
          if (entity.attacksUntilSpecial !== null) {
            entity.attacksUntilSpecial = entity.specialAttackCounter || 3;
          }
        }
      }

      // Función de recuperación de emergencia para el sistema de turnos
      function emergencyTurnSystemRecovery() {
        console.error("Emergency turn system recovery activated!");

        // Limpiar completamente la cola de turnos
        turnQueue.length = 0;

        // Resetear todas las variables de estado
        activeAction = null;
        actionDelayTimer = 0;
        lastTurnEntity = null;
        currentTurnStartTime = 0;
        lastTurnQueueFront = null;

        // Resetear estados de todas las entidades
        [...heroes, ...enemies].forEach((entity) => {
          if (entity.hp > 0) {
            entity.charge = Math.min(50, entity.charge); // Reducir carga para forzar recarga
            entity.chargeFullTime = null;
            entity.animTime = 0;
            entity.anim = "idle";
            entity.frame = 0;
            entity.action = null;

            // Re-agregar a la cola si tiene carga suficiente
            if (entity.charge >= 100) {
              turnQueue.push(entity);
            }
          }
        });

        console.log(
          "Turn system recovery completed. Queue rebuilt with",
          turnQueue.length,
          "entities"
        );
      }

      function processTurnStart(activeEntity) {
        if (!activeEntity) return;
        globalTurnCounter++;
        const allHeroes = heroes || [];
        const allEnemies = enemies || [];

        // Procesar buffs turn-based en héroes
        allHeroes.forEach((h) => {
          if (!h.buffs) h.buffs = [];
          if (h.hp <= 0) return;
          h.buffs = h.buffs.filter((b) => {
            switch (b.type) {
              case "regrowth": {
                // Curación por turno ajustada (4-5) reducida
                const healAmount = 4 + Math.floor(Math.random() * 2);
                const gained = DAMAGE.heal(h, healAmount, {
                  cap: true,
                  show: true,
                  type: "heal",
                });
                if (gained > 0) {
                  validateHP(h);
                  playHealingAnim(h, "regrowth");
                }
                if (b.remainingTurns !== undefined) {
                  b.remainingTurns--;
                  if (b.remainingTurns <= 0) {
                    removeDebuff(h, "healing");
                    return false;
                  }
                }
                return true;
              }
              case "agony": {
                if (b.remainingTurns !== undefined) {
                  b.remainingTurns--;
                  if (b.remainingTurns <= 0) {
                    removeDebuff(h, "agony");
                    return false;
                  }
                }
                return true;
              }
              case "poison": {
                // Ajuste: si el turno actual pertenece a un HÉROE (cualquiera), aplazamos TODOS los ticks de poison de héroes
                // para que primero se resuelva la acción (p.ej. curaciones) y luego el veneno.
                if (activeEntity && activeEntity.clazz) {
                  // Guardar referencia para procesar después de la acción del héroe activo
                  h._pendingPoisonBuff = b;
                  return true; // No aplicar ahora
                }
                // Turno de enemigo: se mantiene comportamiento previo, el veneno hace tick antes de la acción enemiga
                const stacks = b.stacks || 1;
                const dmg = 2 + (stacks - 1) * 1;
                DAMAGE.apply(h, dmg, {
                  min: 0,
                  show: true,
                  crit: false,
                  type: "poison",
                });
                if (h.hp <= 0)
                  /* log removed (hero poison death) */
                  // Verificar game over tras daño DOT
                  validateHP(h);
                checkGameOver();
                if (b.remainingTurns !== undefined) {
                  b.remainingTurns--;
                  if (b.remainingTurns <= 0) {
                    removeDebuff(h, "poison");
                    return false;
                  }
                }
                return true;
              }
              default:
                return true; // Otros buffs sin cambio
            }
          });

          // Procesar debuffs (shadows/poison) si se aplicaran a héroes via h.debuffs
          if (h.debuffs && h.debuffs.length > 0 && h.hp > 0) {
            h.debuffs = h.debuffs.filter((d) => {
              if (d.type === "shadows") {
                const dmg = d.damagePerTick || 2;
                DAMAGE.apply(h, dmg, {
                  min: 0,
                  show: true,
                  crit: false,
                  type: "damage",
                });
                if (h.hp <= 0) {
                  /* log removed (hero shadows death) */
                }
                if (d.remainingTurns !== undefined) {
                  d.remainingTurns--;
                  if (d.remainingTurns <= 0) return false;
                }
                return true;
              } else if (d.type === "poison") {
                // Igual que en buffs: si un héroe está actuando, aplazar
                if (activeEntity && activeEntity.clazz) {
                  h._pendingPoisonDebuff = d;
                  return true;
                }
                const stacks = d.stacks || 1;
                const dmg = 2 + (stacks - 1) * 1;
                DAMAGE.apply(h, dmg, {
                  min: 0,
                  show: true,
                  crit: false,
                  type: "damage",
                });
                if (h.hp <= 0)
                  /* log removed (hero poison debuff death) */
                  validateHP(h);
                checkGameOver();
                if (d.remainingTurns !== undefined) {
                  d.remainingTurns--;
                  if (d.remainingTurns <= 0) return false;
                }
                return true;
              } else if (
                d.type === "agony" ||
                d.type === "dark_protection" ||
                d.type === "healing"
              ) {
                // Debuffs que solo tienen duración pero no causan daño
                if (d.remainingTurns !== undefined) {
                  d.remainingTurns--;
                  if (d.remainingTurns <= 0) return false;
                }
                return true;
              }
              return true;
            });
          }
        });

        // Procesar debuffs turn-based en enemigos (shadows, poison futuro)
        allEnemies.forEach((e) => {
          if (!e.debuffs) e.debuffs = [];
          if (e.hp <= 0) return;
          e.debuffs = e.debuffs.filter((d) => {
            switch (d.type) {
              case "shadows": {
                const dmg = d.damagePerTick || 2;
                DAMAGE.apply(e, dmg, {
                  min: 0,
                  show: true,
                  crit: false,
                  type: "damage",
                });
                if (e.hp <= 0) {
                  /* log removed (enemy shadows death) */
                  e.isDying = true;
                  e.anim = "die";
                  e.frame = 0;
                  e.animStartTime = currentTime;
                  triggerHapticFeedback();
                }
                if (d.remainingTurns !== undefined) {
                  d.remainingTurns--;
                  if (d.remainingTurns <= 0) {
                    return false;
                  }
                }
                return true;
              }
              case "poison": {
                const stacks = d.stacks || 1;
                const dmg = 2 + (stacks - 1) * 1;
                DAMAGE.apply(e, dmg, {
                  min: 0,
                  show: true,
                  crit: false,
                  type: "damage",
                });
                if (e.hp <= 0) {
                  /* log removed (enemy poison death) */
                  e.isDying = true;
                  e.anim = "die";
                  e.frame = 0;
                  e.animStartTime = currentTime;
                  triggerHapticFeedback();
                }
                validateHP(e);
                if (d.remainingTurns !== undefined) {
                  d.remainingTurns--;
                  if (d.remainingTurns <= 0) return false;
                }
                return true;
              }
              case "berseker":
              case "dark_protection":
              case "agony":
              case "healing": {
                // Debuffs que solo tienen duración pero no causan daño
                if (d.remainingTurns !== undefined) {
                  d.remainingTurns--;
                  if (d.remainingTurns <= 0) return false;
                }
                return true;
              }
              default:
                return true;
            }
          });
        });
      }

      // Variables para el Book
      let bookScrollY = 0; // Posición del scroll vertical
      let guideScrollY = 0; // Posición del scroll vertical para la guía
      const bookScrollSpeed = 30; // Velocidad del scroll

      // Variables para scroll táctil
      let isDragging = false;
      let lastTouchY = 0;

      // Información de los niveles
      const levelInfo = {
        1: {
          name: "The Forgotten Crypt",
          lore: "Beneath the ruined chapel lies a crypt where red embers never die. Noctebane, the great crimson demon, feeds on sealed relic shards – each wave you clear slows his awakening. Reach him before the blood sigils blaze fully.",
          boss: "Noctebane",
          background: "#1a0d0a", // Color de fondo marrón oscuro para la cripta
        },
        2: {
          name: "The Red Dunes",
          lore: "Past the crypt, scorched winds carve the Red Dunes. A half-buried maze shelters the Minotaur Warden, once forged to contain Noctebane — now twisted, guarding burning fragments that keep the demon's heart pulsing.",
          boss: "Minotaur Guardian",
          background: "#3d2012", // Color de fondo marrón rojizo para el desierto
        },
        3: {
          name: "The Dark Swamp",
          lore: "The path sinks into a living mire where time curdles. The Gorgon broods over the last relic core, petrifying intruders to fuel the binding. Shatter her gaze — only then can Noctebane's seal truly break for the final clash.",
          boss: "Swamp Gorgon",
          background: "#0d2818", // Color de fondo verde oscuro para el pantano
          completionLore:
            "With the Gorgon fallen, the final seal fractures. Beyond the swamp's rotting mist, the Soul Rift yawns open – a wound in reality where the Abyss King gathers the void itself.",
        },
        4: {
          name: "Soul Rift",
          lore: "Reality fractures around the Soul Rift. The Abyss King drains echoes of fallen worlds, bending void specters and grasping hands of shadow to guard the final breach. Sever his dominion before the rift devours all memory.",
          boss: "Abyss King",
          background: "#1d0b26",
        },
      };

      function init() {
        heroes = [
          {
            clazz: "mage",
            hp: 100,
            maxhp: 100,
            def: 3, // Poca defensa
            charge: 0, // Start empty
            maxcharge: 100,
            chargeSpeedRating: 4, // Velocidad media-baja (1-10 scale)
            posx: 60, // Alineado centro columna 1
            posy: 415, // Movido 20px arriba (era 450)
            anim: "idle",
            frame: 0,
            animTime: 0,
            acted: false,
            buffs: [],
            debuffs: [], // Array para iconos de debuffs/buffs
            targets: [],
            action: null,
            img: mageImg,
            animations: animationsMage,
            frameW: 100, // Nuevo tamaño de frame
            frameH: 100, // Nuevo tamaño de frame
            size: 90,
          },
          {
            clazz: "warlock",
            hp: 100,
            maxhp: 100,
            def: 15, // Buena defensa
            charge: 0, // Start empty
            maxcharge: 100,
            chargeSpeedRating: 6, // Velocidad media-alta (tanque equilibrado)
            posx: 180, // Centro columna 2 (sin cambio)
            posy: 380, // Movido 20px abajo para mejor alineación visual
            anim: "idle",
            frame: 0,
            animTime: 0,
            acted: false,
            buffs: [],
            debuffs: [], // Array para iconos de debuffs/buffs
            targets: [],
            action: null,
            img: warlockImg,
            animations: animationsWarlock,
            frameW: 100, // Nuevo tamaño de frame
            frameH: 100, // Nuevo tamaño de frame
            size: 90,
          },
          {
            clazz: "priest",
            hp: 100,
            maxhp: 100,
            def: 3, // Poca defensa
            charge: 0, // Start empty
            maxcharge: 100,
            chargeSpeedRating: 6, // Aumentado de 5 a 6 para subir ligeramente la velocidad
            posx: 300, // Alineado centro columna 3
            posy: 415, // Movido 20px arriba (era 450)
            anim: "idle",
            frame: 0,
            animTime: 0,
            acted: false,
            buffs: [],
            debuffs: [], // Array para iconos de debuffs/buffs
            targets: [],
            action: null,
            img: priestImg,
            animations: animationsPriest,
            frameW: 100, // Nuevo tamaño de frame
            frameH: 100, // Nuevo tamaño de frame
            size: 90,
          },
        ];
        enemies = [];
        activeAction = null;
        actionDelayTimer = 0;
        score = 0;
        wave = 0;
        currentLevel = 1;
        state = "level_info"; // Empezar mostrando info del nivel 1
        turnPhase = "player";
        slashStreak = 0;
        currentBackgroundImg = backgroundImg; // The Crypt es nivel 1
        levelCompletionModal = { show: false, level: 0, boss: "", timer: 0 };
        pendingLevelInfo = false;

        // Reproducir música del nivel 1 al inicio del juego
        playMusic(level1Music);

        // No llamar startWave() aquí - se llamará cuando se pulse "Enter" en level_info
      }

      function startGame() {
        /* log removed */
        // Inicializar el juego
        init();
        // El estado ya se establece como "level_info" en init()
      }

      function startWave() {
        /* log removed */
        // Resetear flag de procesamiento para la nueva wave
        waveProcessed = false;

        // Nota: wave++ se realiza más adelante (tras generar los enemigos) para que aquí "wave"
        // represente las waves completadas. Así wave=0 antes de la primera, 1 tras iniciar la primera, etc.

        // Limpiar enemigos de la wave anterior
        enemies = [];

        // Verificar si empezamos un nuevo nivel (cada 3 waves)
        const previousLevel = Math.floor((wave - 1) / 3) + 1;
        const nextLevel = Math.floor(wave / 3) + 1;
        currentLevel = nextLevel;

        // Si estamos a punto de iniciar la primera wave de un nivel (wave completadas %3 === 0)
        // (antes de hacer wave++ al final) capturamos el inicio del nivel.
        if (wave % 3 === 0) {
          levelStartTime = performance.now();
        }

        // Actualizar background según el nivel actual (orden limpio)
        if (currentLevel === 1) {
          currentBackgroundImg = backgroundImg; // The Crypt
        } else if (currentLevel === 2) {
          currentBackgroundImg = backgroundLevel2Img; // Red Dunes
        } else if (currentLevel === 3) {
          currentBackgroundImg = backgroundLevel3Img; // Dark Swamp
        } else if (currentLevel === 4) {
          currentBackgroundImg = backgroundLevel4Img; // Soul Rift
        } else {
          currentBackgroundImg = backgroundImg; // Fallback
        }

        // Cambiar música según el nivel cuando se inicia una nueva wave
        if (currentLevel === 1) {
          if (currentMusic !== level1Music) {
            playMusic(level1Music);
          }
        } else if (currentLevel === 2) {
          if (currentMusic !== level2Music) {
            playMusic(level2Music);
          }
        } else if (currentLevel === 3) {
          if (currentMusic !== level3Music) {
            playMusic(level3Music);
          }
        } else if (currentLevel === 4) {
          if (currentMusic !== level4Music) {
            playMusic(level4Music);
          }
        }

        // Revivir héroes cuando se detecta inicio de un nuevo nivel (justo después de haber terminado una wave múltiplo de 3)
        if (nextLevel > previousLevel && wave % 3 === 0) {
          /* log removed (new level revive notice) */
          heroes.forEach((hero) => {
            hero.hp = hero.maxhp;
            validateHP(hero);
            hero.charge = 0; // Resetear carga también
            hero.anim = "idle"; // Asegurar que estén en animación idle
            hero.frame = 0;
            // Limpiar buffs al empezar nuevo nivel
            hero.buffs = [];
          });
        } else {
          /* log removed (continuing level notice) */
        }

        let enemyPositions = [];
        const currentLevelConfig =
          levelConfig[Math.floor(wave / 3) + 1] || levelConfig[1]; // Fallback al nivel 1 (The Crypt)
        // Adaptable: nivel 4 no tiene clave 'normal'
        const enemyDefs = currentLevelConfig.enemies;
        const fallbackEnemy =
          enemyDefs.normal ||
          enemyDefs.voidspecter ||
          enemyDefs.thehand ||
          enemyDefs.boss;
        const normalHP =
          (enemyDefs.normal && enemyDefs.normal.hp) ||
          (enemyDefs.voidspecter && enemyDefs.voidspecter.hp) ||
          fallbackEnemy.hp;
        const flyingHP = enemyDefs.flying ? enemyDefs.flying.hp : normalHP;
        const specialHP = enemyDefs.special ? enemyDefs.special.hp : normalHP;
        const bossHP = enemyDefs.boss.hp;

        // Determinar el nivel actual para configurar waves específicas
        const actualLevel = Math.floor(wave / 3) + 1;

        if (wave % 3 === 0) {
          // Wave 1/3 para cada nivel
          if (actualLevel === 1) {
            // The Crypt Wave 1: 2 Demon Bat
            enemies = [
              createEnemy(120, 200, normalHP, "normal"), // Demon Bat izquierda
              createEnemy(240, 200, normalHP, "normal"), // Demon Bat derecha
            ];
          } else if (actualLevel === 2) {
            // Red Dunes Wave 1: 1 Fire Worm + 1 Crab Bomb
            enemies = [
              createEnemy(120, 200, normalHP, "normal"), // Fire Worm
              createEnemy(240, 200, specialHP, "special"), // Crab Bomb
            ];
          } else if (actualLevel === 3) {
            // Dark Swamp Wave 1: 1 Mushroom + 1 Dreadwing
            enemies = [
              createEnemy(120, 200, normalHP, "normal"), // Mushroom
              createEnemy(240, 200, flyingHP, "flying"), // Dreadwing
            ];
          } else if (actualLevel === 4) {
            // Soul Rift Wave 1: 1 Voidspecter + 1 The Hand (posiciones 120 y 240 como wave 1 nivel 3)
            enemies = [
              createEnemy(120, 200, 110, "voidspecter"),
              createEnemy(240, 200, 80, "thehand"),
            ];
          } else {
            // Otros niveles mantienen la configuración original (2 enemigos normales)
            enemies = [
              createEnemy(100, 200, normalHP, "normal"),
              createEnemy(260, 200, normalHP, "normal"),
            ];
          }
        } else if (wave % 3 === 1) {
          // Wave 2/3 para cada nivel
          if (actualLevel === 1) {
            // The Crypt Wave 2: 3 Demon Bat
            enemies = [
              createEnemy(80, 200, normalHP, "normal"), // Demon Bat izquierda
              createEnemy(180, 200, normalHP, "normal"), // Demon Bat centro
              createEnemy(280, 200, normalHP, "normal"), // Demon Bat derecha
            ];
          } else if (actualLevel === 2) {
            // Red Dunes Wave 2: 1 Fire Worm + 1 Crab Bomb + 1 Fire Worm
            enemies = [
              createEnemy(80, 200, normalHP, "normal"), // Fire Worm izquierda
              createEnemy(180, 200, specialHP, "special"), // Crab Bomb centro
              createEnemy(280, 200, normalHP, "normal"), // Fire Worm derecha
            ];
          } else if (actualLevel === 3) {
            // Dark Swamp Wave 2: 1 Dreadwing + 1 Mushroom + 1 Dreadwing
            enemies = [
              createEnemy(80, 200, flyingHP, "flying"), // Dreadwing izquierda
              createEnemy(180, 200, normalHP, "normal"), // Mushroom centro
              createEnemy(280, 200, flyingHP, "flying"), // Dreadwing derecha
            ];
          } else if (actualLevel === 4) {
            // Soul Rift Wave 2: Voidspecter + The Hand + Voidspecter
            enemies = [
              createEnemy(80, 200, 110, "voidspecter"),
              createEnemy(180, 200, 80, "thehand"),
              createEnemy(280, 200, 110, "voidspecter"),
            ];
          } else {
            // Otros niveles mantienen la configuración original (3 enemigos normales)
            enemies = [
              createEnemy(80, 200, normalHP, "normal"),
              createEnemy(180, 200, normalHP, "normal"),
              createEnemy(280, 200, normalHP, "normal"),
            ];
          }
        } else {
          // Wave 3/3: boss para todos los niveles - centrado exacto en pantalla
          if (actualLevel === 4) {
            enemies = [createEnemy(screenCenterX, 200, 400, "boss")];
          } else {
            enemies = [createEnemy(screenCenterX, 200, bossHP, "boss")]; // Centro exacto: 180px
          }
        }
        wave++;
        /* log removed */
        heroes.forEach((h) => (h.acted = false));
        // Reiniciar cola de turnos al iniciar wave
        turnQueue = [];
        if (preservedTurnEntity && preservedTurnEntity.hp > 0) {
          // Asegurar disponibilidad inmediata
          preservedTurnEntity.charge = 100;
          if (!turnQueue.includes(preservedTurnEntity)) {
            turnQueue.push(preservedTurnEntity);
          }
          lastTurnEntity = null; // Forzar processTurnStart
          console.log(
            "[WaveTransition] Turno restaurado para",
            preservedTurnEntity.clazz || preservedTurnEntity.name
          );
        }
        preservedTurnEntity = null;
      }

      function createEnemy(x, y, hp, type) {
        // Usar currentLevel global (no derivar de wave, porque tras wave++ en la boss wave las invocaciones daban nivel 5 inexistente)
        const currentLevelConfig = levelConfig[currentLevel] || levelConfig[1]; // Fallback al nivel 1

        let enemyConfig;
        if (type === "boss") {
          enemyConfig = currentLevelConfig.enemies.boss;
        } else if (type === "flying") {
          // Para Dark Swamp, usar el enemigo volador (Dreadwing)
          enemyConfig =
            currentLevelConfig.enemies.flying ||
            currentLevelConfig.enemies.normal;
        } else if (type === "voidspecter") {
          enemyConfig = currentLevelConfig.enemies.voidspecter;
        } else if (type === "thehand") {
          enemyConfig = currentLevelConfig.enemies.thehand;
        } else if (type === "special") {
          // Para Red Dunes, usar el enemigo especial (Crab Bomb)
          enemyConfig =
            currentLevelConfig.enemies.special ||
            currentLevelConfig.enemies.normal;
        } else {
          // Tipo normal o por defecto
          enemyConfig = currentLevelConfig.enemies.normal;
        }

        if (!enemyConfig) {
          console.warn(
            "Enemy config missing for type",
            type,
            "level",
            currentLevel,
            " -> fallback basic placeholder"
          );
          enemyConfig = {
            name: type,
            frameWidth: 80,
            frameHeight: 80,
            idleFrames: 1,
            deathFrames: 1,
            attackFrames: 1,
            chargeSpeed: 30,
            isFlying: false,
            size: 100,
            sprites: { idle: null, death: null, attack: null },
            mainAbility: "basic_attack",
          };
        }

        // Determinar posición Y según si es volador o terrestre
        let adjustedY = y;
        if (enemyConfig.isFlying) {
          adjustedY = y - 10; // Voladores más arriba
        } else {
          adjustedY = y + 20; // Terrestres más abajo
        }

        const enemy = {
          hp: hp,
          maxhp: hp,
          charge: 0,
          maxcharge: 100,
          posx: x,
          posy: adjustedY,
          type,
          animTime: 0,
          def: type === "boss" ? 10 : 5,
          baseDef: type === "boss" ? 10 : 5,
          size: enemyConfig.size || (type === "boss" ? 140 : 110),
          anim: "idle",
          frame: 0,
          animStartTime: 0,
          isDying: false,
          deathAnimComplete: false,
          spawnFadeProgress: 0,
          debuffs: [],
          name: enemyConfig.name,
          sprites: enemyConfig.sprites,
          frameWidth: enemyConfig.frameWidth,
          frameHeight: enemyConfig.frameHeight,
          idleFrames: enemyConfig.idleFrames,
          deathFrames: enemyConfig.deathFrames,
          attackFrames: enemyConfig.attackFrames,
          explodeFrames: enemyConfig.explodeFrames,
          chargeSpeed: enemyConfig.chargeSpeed,
          isFlying: enemyConfig.isFlying,
          mainAbility: enemyConfig.mainAbility,
          noBasicAttack: enemyConfig.noBasicAttack,
          specialAttackCounter:
            type === "boss" || type === "special"
              ? enemyConfig.specialAttackCounter
              : null,
          specialAbility: type === "boss" ? enemyConfig.specialAbility : null,
          attacksUntilSpecial:
            type === "boss" ? enemyConfig.specialAttackCounter : null,
          sphereCharges: type === "special" ? 0 : null,
          maxSphereCharges:
            type === "special" ? enemyConfig.specialAttackCounter : null,
          damageMultiplier: 1,
          darkProtectionStacks: 0,
          countdownVisible:
            type === "boss" && enemyConfig.specialAttackCounter
              ? enemyConfig.specialAttackCounter
              : null,
        };

        // Validar que HP y maxHP sean números válidos para evitar NaN
        if (isNaN(enemy.hp) || enemy.hp === undefined) {
          enemy.hp = hp;
        }
        if (isNaN(enemy.maxhp) || enemy.maxhp === undefined) {
          enemy.maxhp = hp;
        }

        return enemy;
      }

      // Función para validar y corregir valores de HP
      function validateHP(target) {
        const wasAlive = target.hp > 0; // Recordar si estaba vivo antes

        if (isNaN(target.hp) || target.hp === undefined || target.hp === null) {
          target.hp = target.maxhp || 1;
        }
        if (
          isNaN(target.maxhp) ||
          target.maxhp === undefined ||
          target.maxhp === null
        ) {
          target.maxhp = target.hp || 1;
        }
        target.hp = Math.max(0, target.hp);
        target.maxhp = Math.max(1, target.maxhp);

        // Si el héroe acaba de morir (tenía hp > 0 y ahora hp <= 0), limpiar efectos
        if (wasAlive && target.hp <= 0 && target.clazz) {
          // Solo para héroes (tienen clazz)
          clearAllEffectsOnDeath(target);
        }
      }

      // Función para calcular si un golpe es crítico
      function calculateCritical(baseDamage, customCritChance = 15) {
        const criticalChance = customCritChance / 100; // Convertir porcentaje a decimal
        const isCritical = Math.random() < criticalChance;
        const finalDamage = isCritical
          ? Math.floor(baseDamage * 1.5)
          : baseDamage;

        return {
          damage: finalDamage,
          isCritical: isCritical,
        };
      }

      // Función para calcular valores aleatorios en un rango
      function calculateRandomValue(baseValue, variationPercent = 20) {
        const variation = Math.floor(baseValue * (variationPercent / 100));
        const minValue = baseValue - variation;
        const maxValue = baseValue + variation;
        return minValue + Math.floor(Math.random() * (maxValue - minValue + 1));
      }

      // Función para convertir el rating de velocidad de carga (1-10) a velocidad real
      function getChargeSpeedFromRating(rating) {
        // Rating 1 = velocidad 5 (más lento)
        // Rating 10 = velocidad 50 (más rápido)
        // Escala lineal: velocidad = rating * 5
        return Math.max(1, Math.min(50, rating * 5));
      }

      // Función para aplicar bonificador de velocidad de carga
      function applyChargeSpeedBonus(character, multiplier) {
        if (character.chargeSpeedRating) {
          // Para el nuevo sistema, aumentar el rating pero mantener límites
          character.chargeSpeedRating = Math.min(
            10,
            character.chargeSpeedRating * multiplier
          );
        } else {
          // Compatibilidad con el sistema legacy
          character.chargeSpeed = (character.chargeSpeed || 20) * multiplier;
        }
      }

      // Función para obtener la velocidad de carga actual (para debugging)
      function getCurrentChargeSpeed(character) {
        let base = character.chargeSpeedRating
          ? getChargeSpeedFromRating(character.chargeSpeedRating)
          : character.chargeSpeed || 20;
        // Bonus berseker: +3% por stack hasta 10 stacks (30%)
        if (character.debuffs) {
          const bers = character.debuffs.find((d) => d.type === "berseker");
          if (bers && bers.stacks) {
            const bonusPct = Math.min(bers.stacks * 3, 30);
            base *= 1 + bonusPct / 100;
          }
        }
        return base;
      }

      /* =============================
      CONFIG: Class Actions Definitions
      ============================= */
      const classActions = {
        mage: {
          fireblast: {
            name: "Fireblast",
            reqCharge: 100, // Todas las habilidades requieren barra completa
            type: "single_enemy",
            damage: 40,
            anim: "fireblast",
          },
          combustion: {
            name: "Combustion",
            reqCharge: 100, // Todas las habilidades requieren barra completa
            type: "self",
            critBonus: 80, // Gran porcentaje de crítico para el próximo ataque
            anim: "combustion",
          },
          inferno: {
            name: "Inferno",
            reqCharge: 100, // Todas las habilidades requieren barra completa
            type: "all_enemy",
            damage: 22, // Menos que fireblast pero a todos los enemigos
            anim: "inferno",
          },
        },
        priest: {
          holywave: {
            name: "Holy Wave",
            reqCharge: 100, // Todas las habilidades requieren barra completa
            type: "single_ally",
            heal: 60, // Aumentado de 50 a 60
            anim: "holywave",
          },
          smite: {
            name: "Smite",
            reqCharge: 100, // Todas las habilidades requieren barra completa
            type: "single_enemy",
            damage: 25, // Poco daño
            anim: "smite",
          },
          regrowth: {
            name: "Regrowth",
            reqCharge: 100, // Todas las habilidades requieren barra completa
            type: "all_ally",
            heal: 8, // Base para rango 7-9
            ticks: 10, // 10 segundos de duración
            anim: "regrowth",
          },
        },
        warlock: {
          darkslash: {
            name: "Dark Slash",
            reqCharge: 100, // Todas las habilidades requieren barra completa
            type: "single_enemy",
            damage: 5,
            anim: "darkslash",
            shadowsDamage: 2, // Daño base por tick de Shadows
            shadowsDuration: 15, // 15 segundos
            shadowsInterval: 5, // Cada 5 segundos
            stackDamageIncrease: 1, // +1 daño por stack
          },
          agony: {
            name: "Agony",
            reqCharge: 100, // Todas las habilidades requieren barra completa
            type: "all_ally",
            // (Turn-based) ahora otorga +20% DEF temporal (defBonus se calcula al aplicar)
            duration: 20, // Conservado por si otras partes usan duración base (segundos original no usado ya)
            anim: "agony",
          },
          inmolation: {
            name: "Inmolation",
            reqCharge: 100, // Todas las habilidades requieren barra completa
            type: "all_enemy",
            damage: 35, // Mucho daño
            selfDamage: 50, // 60% de su vida
            anim: "inmolation",
          },
        },
      };

      // ================================
      // GAME OVER HANDLING
      // ================================

      /* =============================
      STATE HANDLER: Game Over
      ============================= */
      function handleGameOver() {
        if (state === "game_over") return; // Evitar múltiples envíos
        state = "game_over";

        // Score de consolación si es derrotado en la primera wave del nivel 1
        if (wave === 1) {
          const consolationScore = 100; // Puntuación de consolación
          score = Math.max(score, consolationScore);
          console.log("Score de consolación aplicado:", consolationScore);
        }

        // Limpiar acciones y colas para evitar estados colgados
        activeAction = null;
        actionDelayTimer = 0;
        turnQueue = [];
        lastTurnEntity = null;
        // Enviar score al SDK de Farcade (única acción en game over)
        if (
          window.FarcadeSDK &&
          window.FarcadeSDK.singlePlayer?.actions?.gameOver
        ) {
          try {
            window.FarcadeSDK.singlePlayer.actions.gameOver({ score: score });
            console.log("Game Over enviado al SDK con score:", score);
          } catch (err) {
            console.error("Error enviando gameOver al SDK", err);
          }
        } else {
          console.log("SDK no disponible - game over local. Score:", score);
        }
      }

      // Procesa el tick de poison aplazado para un héroe cuyo turno estaba activo
      function processDeferredPoisonTick(entity) {
        if (!entity) return;
        // Procesar buff aplazado
        if (entity._pendingPoisonBuff) {
          const b = entity._pendingPoisonBuff;
          if (entity.buffs && entity.buffs.includes(b)) {
            const stacks = b.stacks || 1;
            const dmg = 2 + (stacks - 1) * 1;
            DAMAGE.apply(entity, dmg, {
              min: 0,
              show: true,
              crit: false,
              type: "poison",
            });
            validateHP(entity);
            checkGameOver();
            if (b.remainingTurns !== undefined) {
              b.remainingTurns--;
              if (b.remainingTurns <= 0) {
                removeDebuff(entity, "poison");
              }
            }
          }
          entity._pendingPoisonBuff = null;
        }
        // Procesar debuff aplazado (lista de debuffs)
        if (entity._pendingPoisonDebuff) {
          const d = entity._pendingPoisonDebuff;
          if (entity.debuffs && entity.debuffs.includes(d)) {
            const stacks = d.stacks || 1;
            const dmg = 2 + (stacks - 1) * 1;
            DAMAGE.apply(entity, dmg, {
              min: 0,
              show: true,
              crit: false,
              type: "poison",
            });
            validateHP(entity);
            checkGameOver();
            if (d.remainingTurns !== undefined) {
              d.remainingTurns--;
              if (d.remainingTurns <= 0) {
                // Eliminar de la lista de debuffs manualmente
                entity.debuffs = entity.debuffs.filter((x) => x !== d);
              }
            }
          }
          entity._pendingPoisonDebuff = null;
        }
      }

      // Fuerza avanzar el turno actual si se detecta bloqueo
      function forceAdvanceTurn() {
        if (state === "game_over" || waveTransition.active) return;
        console.log(
          "[NEXT] BEFORE rotation queue=",
          turnQueue.map((e) => e.clazz || e.name)
        );
        // Si solo hay 0 elementos, no hacemos nada
        if (turnQueue.length === 0) return;
        // Liberar acción activa atascada (si la hubiera)
        activeAction = null;
        actionDelayTimer = 0;
        const front = turnQueue.shift();
        // Antes de rotar, si tenía poison pendiente y aún no se aplicó (turno termina sin acción o tras saltar), aplicarlo ahora
        processDeferredPoisonTick(front);
        if (front) {
          if (front.anim === "attack") {
            front.anim = "idle";
            front.animTime = 0;
          }
          if (front.charge < 100) front.charge = 100;
          turnQueue.push(front); // Incluso si era el único, vuelve al final (mismo lugar)
        }
        lastTurnEntity = null; // Forzar que el nuevo frente reprocese start turn
        console.log(
          "[NEXT] AFTER rotation queue=",
          turnQueue.map((e) => e.clazz || e.name)
        );
      }

      function checkGameOver() {
        if (heroes.every((h) => h.hp <= 0)) {
          handleGameOver();
          return true;
        }
        return false;
      }
      function checkWaveCleared() {
        // Evitar chequear limpieza de wave mientras estamos en pantallas no jugables
        if (state === "level_info" || state === "main_menu") return false;
        // Si ya estamos en transición, no volver a dispararla
        if (waveTransition.active) return false;
        // Si ya mostramos modal de fin de nivel, no repetir
        if (state === "level_completion") return false;
        // Si ya procesamos esta wave, no procesar de nuevo
        if (waveProcessed) return false;

        if (enemies.every((e) => e.hp <= 0)) {
          // Cancelar inmediatamente cualquier acción en progreso para evitar bugs
          cancelActionsOnWaveCleared();

          // Verificar si todos los enemigos han completado su animación de muerte
          const allDeathAnimationsComplete = enemies.every(
            (e) => e.hp > 0 || e.deathAnimComplete
          );

          if (allDeathAnimationsComplete) {
            // Marcar que ya procesamos esta wave para evitar múltiples cálculos
            waveProcessed = true;

            // Crear backup del score antes de modificarlo
            backupScore();

            /* log removed (wave cleared) */
            // Nuevo sistema de puntuación con validaciones de seguridad
            const alive = heroes.filter((h) => h.hp > 0).length;
            const elapsedSec = levelStartTime
              ? Math.max(0, (performance.now() - levelStartTime) / 1000)
              : 0;
            let base = SCORE_CONFIG.waveBase;
            // Bonus de nivel si wave finaliza nivel (multiplo de 3)
            if (wave % 3 === 0) base += SCORE_CONFIG.levelCompletion;
            const timeMult = SCORE_CONFIG.timeMultiplier(elapsedSec);
            const aliveMult = SCORE_CONFIG.heroesAliveMultiplier(alive);

            // Validar que todos los valores son números válidos
            if (isNaN(base) || isNaN(timeMult) || isNaN(aliveMult)) {
              console.error("Invalid score calculation values:", {
                base,
                timeMult,
                aliveMult,
              });
              base = SCORE_CONFIG.waveBase; // Fallback seguro
              timeMult = 1.0;
              aliveMult = 1.0;
            }

            const waveGain = Math.round(base * timeMult * aliveMult);
            const oldScore = score;

            // Validar que waveGain es un número razonable
            if (
              isNaN(waveGain) ||
              waveGain < 0 ||
              waveGain > SCORE_CONFIG.maxWaveGain
            ) {
              console.error(
                "Invalid wave gain calculated:",
                waveGain,
                "Using fallback of",
                SCORE_CONFIG.waveBase
              );
              const fallbackGain = SCORE_CONFIG.waveBase;
              // Validar que no excedamos el score máximo total
              if (score + fallbackGain <= SCORE_CONFIG.maxTotalScore) {
                score += fallbackGain;
              } else {
                console.warn("Score would exceed maximum, not adding points");
              }
            } else {
              // Validar que no excedamos el score máximo total
              if (score + waveGain <= SCORE_CONFIG.maxTotalScore) {
                score += waveGain;
              } else {
                console.warn("Score would exceed maximum, capping at maximum");
                score = SCORE_CONFIG.maxTotalScore;
              }
            }

            // Verificar que el nuevo score es válido
            if (
              isNaN(score) ||
              score < oldScore ||
              score > SCORE_CONFIG.maxTotalScore
            ) {
              console.error(
                "Score corruption detected! Restoring from backup. Old:",
                oldScore,
                "New:",
                score
              );
              if (!restoreScore()) {
                // Si no se puede restaurar, usar valor seguro
                score = oldScore;
              }
            }

            console.log(
              `Wave ${wave} completed. Points gained: ${
                waveGain || SCORE_CONFIG.waveBase
              }, Total score: ${score}`
            );
            /* log removed (new scoring applied) */

            // Verificar si hemos completado un nivel (wave 3, 6, 9...)
            if (wave % 3 === 0) {
              const completedLevel = Math.floor(wave / 3);
              const levelData = levelInfo[completedLevel];

              // Validar que tenemos datos del nivel (si falta, continuar igualmente)
              if (!levelData) {
                console.error(
                  "Level data not found for level:",
                  completedLevel
                );
              }

              if (completedLevel === 4) {
                // Juego completado (Abyss King derrotado): enviar game over al SDK para registrar puntuación final
                /* log removed (final boss defeated notice) */
                handleGameOver();
              } else {
                // LIMPIAR TODOS LOS BUFFS/DEBUFFS AL TERMINAR EL NIVEL (no persisten entre niveles)
                heroes.forEach((h) => {
                  h.buffs = [];
                  h.debuffs = [];
                  h._pendingPoisonBuff = null;
                });
                console.log(
                  `Cleared all buffs/debuffs after completing level ${completedLevel}`
                );
                console.log(
                  `Level ${completedLevel} completed -> showing completion modal`
                );
                levelCompletionModal.show = true;
                levelCompletionModal.level = completedLevel;
                levelCompletionModal.boss = levelData ? levelData.boss : "";
                state = "level_completion";
              }
            } else {
              // Continuar con la siguiente wave del mismo nivel mediante transición suave
              beginWaveTransition();
            }
            return true;
          }
        }
        return false;
      }

      function beginWaveTransition() {
        // Limpiar efectos visuales residuales y números de golpe
        hitNumbers = [];
        visualEffects = visualEffects.filter((fx) => fx.persistent); // Opcional: mantener solo persistentes si existieran
        // Capturar entidad al frente (si es héroe vivo) para restaurar su turno tras la nueva wave
        if (
          turnQueue.length > 0 &&
          heroes.includes(turnQueue[0]) &&
          turnQueue[0].hp > 0
        ) {
          preservedTurnEntity = turnQueue[0];
          console.log(
            "[WaveTransition] Preservando turno de",
            preservedTurnEntity.clazz || preservedTurnEntity.name
          );
        } else {
          preservedTurnEntity = null;
        }
        waveTransition.active = true;
        waveTransition.timer = waveTransition.delay;
        heroInputLocked = true; // Bloquear acciones de héroe hasta que spawneen los nuevos enemigos
      }

      // NOTA: advanceTurn() removida - ya no se usa sistema de turnos

      // Función para cancelar automáticamente la selección de objetivo si el héroe muere
      function checkAndCancelDeadHeroAction() {
        if (selectedHero && selectedHero.hp <= 0) {
          // Si el héroe seleccionado está muerto y estamos en modo de selección de objetivo
          if (
            state === "select_target_enemy" ||
            state === "select_target_ally"
          ) {
            console.log(
              `${selectedHero.clazz} died during target selection. Canceling action: ${selectedAction}`
            );

            // Resetear todas las variables de selección
            selectedHero = null;
            selectedAction = null;
            state = "select_hero";

            console.log("Action canceled. Returning to hero selection.");
          }
        }
      }

      // Función para cancelar acciones en progreso cuando se elimina la última horda
      function cancelActionsOnWaveCleared() {
        if (
          selectedHero ||
          selectedAction ||
          state === "select_target_enemy" ||
          state === "select_target_ally"
        ) {
          console.log(
            "Wave cleared - canceling any actions in progress to prevent bugs"
          );

          // Resetear todas las variables de selección
          selectedHero = null;
          selectedAction = null;

          // Volver al estado de selección de héroe si estábamos en selección de objetivo
          if (
            state === "select_target_enemy" ||
            state === "select_target_ally"
          ) {
            state = "select_hero";
          }

          console.log("All actions canceled due to wave completion");
        }
      }

      function executeAction(hero, action, targets) {
        const actionData = classActions[hero.clazz][action];

        // Solo puede actuar si es su turno (primero en la cola) en modo de turnos
        if (turnQueue.length === 0 || turnQueue[0] !== hero) {
          return false;
        }

        // Check if we have enough charge before executing
        let requiredCharge = actionData.reqCharge;

        if (hero.charge < requiredCharge) {
          console.log(
            "Not enough charge for action:",
            action,
            "Required:",
            requiredCharge,
            "Current:",
            hero.charge
          );
          return false;
        }

        // Always reset charge to 0 when using any ability
        hero.charge = 0;
        // Retirar de la cola (ya consumió su turno)
        if (turnQueue[0] === hero) {
          turnQueue.shift();
        } else {
          // Seguridad por si estuviera más adelante (no debería ocurrir)
          turnQueue = turnQueue.filter((e) => e !== hero);
        }

        hero.anim = actionData.anim;
        hero.frame = 0;
        hero.animTime = 0;
        // Limpiar targets anteriores antes de asignar nuevos
        hero.targets = [];
        hero.targets = Array.isArray(targets) ? targets : [targets];
        hero.action = action;
        hero.actionStartTime = currentTime; // Marcar tiempo de inicio de la acción
        // NO cambiar estado a "animate" para permitir clicks rápidos
        // state = "animate";

        console.log(
          "Executing action:",
          action,
          "for hero:",
          hero.clazz,
          "with targets:",
          hero.targets.length,
          "charge reset to 0"
        );
        return true;
      }

      function applyEffect(hero, action, targets) {
        // Validar que tenemos todos los datos necesarios
        if (
          !action ||
          !hero.clazz ||
          !classActions[hero.clazz] ||
          !classActions[hero.clazz][action]
        ) {
          console.error("ERROR: Datos inválidos para applyEffect", {
            hero: hero.clazz,
            action: action,
            hasClassActions: !!classActions[hero.clazz],
            hasAction: !!(
              classActions[hero.clazz] && classActions[hero.clazz][action]
            ),
          });
          return;
        }

        const actionData = classActions[hero.clazz][action];
        console.log(
          "Applying effect:",
          action,
          "from hero:",
          hero.clazz,
          "to targets:",
          targets.length,
          "action type:",
          actionData.type
        );

        // Reproducir sonido del hechizo inmediatamente
        playSpellSound(action, 0);

        // Feedback háptico al usar un hechizo
        triggerHapticFeedback();

        // Validación adicional para prevenir contaminación de targets
        if (actionData.type.includes("enemy") && targets.some((t) => t.clazz)) {
          console.error(
            "ERROR: Acción de enemigo aplicada a héroes!",
            action,
            targets
          );
          return;
        }
        if (actionData.type.includes("ally") && targets.some((t) => !t.clazz)) {
          console.error(
            "ERROR: Acción de aliado aplicada a enemigos!",
            action,
            targets
          );
          return;
        }

        // Nuevas mecánicas específicas por habilidad
        if (action === "combustion") {
          // Combustion: buff de críticos para el próximo ataque
          hero.buffs.push({
            type: "combustion",
            critBonus: actionData.critBonus,
            usesRemaining: 1, // Solo para el próximo ataque
          });
          // Agregar icono de combustion debuff
          addDebuff(hero, "combustion", 1);
          console.log(
            "Combustion buff applied to",
            hero.clazz,
            "- next attack will have high critical chance"
          );
          // Agregar efecto visual de combustion en el propio mago
          addCombustionEffect(hero.posx, hero.posy);
        } else if (action === "agony") {
          // Agony: aumento defensivo del 25% a todos los aliados (bajado 5%)
          targets.forEach((target) => {
            if (target.hp > 0) {
              // Basar en baseDef si existe para evitar stacking sobre buff previo
              const baseForCalc =
                target.baseDef !== undefined ? target.baseDef : target.def || 0;
              const defBonus = Math.round(baseForCalc * 0.25);
              target.buffs.push({
                type: "agony",
                remainingTurns: 10,
                defBonus,
              });
              addDebuff(target, "agony", 1); // Icono propio de Agony
              console.log(
                "Agony (turn-based) aplicado a",
                target.clazz,
                "defBonus:",
                defBonus
              );
              addWarlockAgonyEffect(target.posx, target.posy);
            }
          });
        } else if (action === "inmolation") {
          // Inmolation: daño a todos los enemigos + auto-daño al warlock
          targets.forEach((target) => {
            if (target.hp > 0) {
              let damage = actionData.damage;
              const criticalResult = calculateCritical(damage);
              const finalDamage = criticalResult.damage;
              const isCritical = criticalResult.isCritical;
              const effectiveDamage = Math.max(1, finalDamage - target.def);

              target.anim = "hurt";
              target.frame = 0;
              target.animStartTime = currentTime;
              target.hp = Math.max(0, target.hp - effectiveDamage);
              validateHP(target);

              if (target.hp <= 0) {
                target.isDying = true;
                target.anim = "die";
                target.frame = 0;
                target.animStartTime = currentTime;
              }

              showHitNumber(
                target.posx,
                target.posy - 20,
                effectiveDamage,
                false,
                isCritical
              );
              clearEffectsByTypeAndPosition(
                "warlock_inmolation1",
                target.posx,
                target.posy
              );
              clearEffectsByTypeAndPosition(
                "warlock_inmolation2",
                target.posx,
                target.posy
              );
              addWarlockInmolationEffect(target.posx, target.posy);
            }
          });

          // Auto-daño al warlock (60% de su vida)
          const selfDamage = Math.floor(
            hero.maxhp * (actionData.selfDamage / 100)
          );
          hero.hp = Math.max(0, hero.hp - selfDamage); // Puede autodestruirse
          validateHP(hero);
          showHitNumber(
            hero.posx,
            hero.posy - 20,
            selfDamage,
            false,
            false,
            "damage",
            hero
          );
          console.log("Inmolation self-damage:", selfDamage, "to", hero.clazz);
        } else if (action === "regrowth") {
          // Regrowth: curación por ticks a todos los aliados
          targets.forEach((target) => {
            if (target.hp > 0) {
              target.buffs.push({
                type: "regrowth",
                remainingTurns: 5, // 5 turnos globales
              });
              // Mostrar icono 'healing' (según nueva definición)
              addDebuff(target, "healing", 1);
              playHealingAnim(target, "regrowth");
              console.log("Regrowth (turn-based) aplicado a", target.clazz);
            }
          });
        } else if (action === "darkslash") {
          // Dark Slash: daño normal + aplicar/stackear debuff Shadows
          targets.forEach((target) => {
            if (target.hp > 0) {
              // Aplicar daño normal primero
              let damage = calculateRandomValue(actionData.damage, 20);
              let criticalChance = 15;

              const criticalResult = calculateCritical(damage, criticalChance);
              const finalDamage = criticalResult.damage;
              const isCritical = criticalResult.isCritical;

              target.hp = Math.max(0, target.hp - finalDamage);
              validateHP(target);

              showHitNumber(
                target.posx,
                target.posy - 20,
                finalDamage,
                false,
                isCritical
              );

              // Aplicar o stackear debuff Shadows
              const existingShadows = target.debuffs.find(
                (d) => d.type === "shadows"
              );
              if (existingShadows) {
                existingShadows.stacks = (existingShadows.stacks || 1) + 1;
                existingShadows.remainingTurns = 10; // Reinicia duración en turnos
                existingShadows.damagePerTick =
                  (existingShadows.damagePerTick || 2) + 1; // +1 daño por stack
                if (!existingShadows.icon)
                  existingShadows.icon = getDebuffIcon("shadows");
                console.log(
                  `Shadows stack (${existingShadows.stacks}) en ${
                    target.type || target.clazz
                  }. Daño por tick: ${existingShadows.damagePerTick}`
                );
              } else {
                target.debuffs.push({
                  type: "shadows",
                  remainingTurns: 10,
                  damagePerTick: 2 + Math.floor(Math.random() * 2), // 2-3
                  stacks: 1,
                  icon: getDebuffIcon("shadows"),
                });
                console.log(
                  `Shadows aplicado a ${target.type || target.clazz}`
                );
              }

              // Efectos visuales
              clearEffectsByTypeAndPosition(
                "warlock_darkslash",
                target.posx,
                target.posy
              );
              addWarlockDarkSlashEffect(target.posx, target.posy);

              if (target.hp <= 0) {
                target.isDying = true;
                target.anim = "die";
                target.frame = 0;
                target.animStartTime = currentTime;
                // Trigger haptic feedback when enemy dies
                triggerHapticFeedback();
              }
            }
          });
        } else if (actionData.type.includes("enemy")) {
          // Habilidades de daño normales
          targets.forEach((target) => {
            if (target.hp > 0) {
              // Aplicar variación aleatoria al daño base
              let damage = calculateRandomValue(actionData.damage, 20); // ±20% de variación

              // Aplicar buff de combustion si existe
              let criticalChance = 15; // Base 15%
              const combustionBuff = hero.buffs.find(
                (b) => b.type === "combustion"
              );
              if (combustionBuff) {
                criticalChance += combustionBuff.critBonus;
                // Consumir el buff después de usarlo
                combustionBuff.usesRemaining--;
                if (combustionBuff.usesRemaining <= 0) {
                  // Marcar para eliminación
                  combustionBuff.toRemove = true;
                }
              }

              const criticalResult = calculateCritical(damage, criticalChance);
              const finalDamage = criticalResult.damage;
              const isCritical = criticalResult.isCritical;
              const effectiveDamage = Math.max(1, finalDamage - target.def);

              target.anim = "hurt";
              target.frame = 0;
              target.animStartTime = currentTime;
              target.hp = Math.max(0, target.hp - effectiveDamage);
              validateHP(target);

              if (target.hp <= 0) {
                target.isDying = true;
                target.anim = "die";
                target.frame = 0;
                target.animStartTime = currentTime;
              }

              showHitNumber(
                target.posx,
                target.posy - 20,
                effectiveDamage,
                false,
                isCritical
              );

              // Efectos visuales específicos por habilidad
              if (action === "fireblast") {
                clearEffectsByTypeAndPosition(
                  "mage_fireblast",
                  target.posx,
                  target.posy
                );
                addMageFireblastEffect(target.posx, target.posy);
              } else if (action === "inferno") {
                clearEffectsByTypeAndPosition(
                  "conflagration",
                  target.posx,
                  target.posy
                );
                addConflagrationEffect(target.posx, target.posy);
              } else if (action === "darkslash") {
                clearEffectsByTypeAndPosition(
                  "warlock_darkslash",
                  target.posx,
                  target.posy
                );
                addWarlockDarkSlashEffect(target.posx, target.posy);
              } else if (action === "smite") {
                clearEffectsByTypeAndPosition(
                  "smite",
                  target.posx,
                  target.posy
                );
                addSmiteEffect(target.posx, target.posy);
              }
            }
          });
        } else if (
          actionData.type.includes("ally") ||
          actionData.type === "self"
        ) {
          // Habilidades de curación normales
          targets.forEach((target) => {
            // Verificar si el objetivo puede recibir curación
            // Solo bloquear si tiene debuff de regrowth Y estamos aplicando regrowth
            const hasRegrowthDebuff =
              target.debuffs &&
              target.debuffs.some((d) => d.type === "regrowth");
            const isRegrowthAction = action === "regrowth";
            const shouldBlockHealing = hasRegrowthDebuff && isRegrowthAction;

            if (actionData.heal && !shouldBlockHealing) {
              // Verificar si el objetivo está vivo AL MOMENTO de aplicar el efecto
              // (esto permite que la curación falle si el objetivo muere durante la animación)
              if (target.hp > 0) {
                // Aplicar variación aleatoria a la curación
                const healAmount = calculateRandomValue(actionData.heal, 20); // ±20% de variación
                const gained = DAMAGE.heal(target, healAmount, {
                  cap: true,
                  show: true,
                  type: "heal",
                });
                if (gained > 0) {
                  validateHP(target);
                  const healType =
                    action === "holywave" ? "holywave" : "healing";
                  playHealingAnim(target, healType);
                }
              } else if (target.hp <= 0) {
                // Revivir al héroe muerto con la cantidad de curación
                const healAmount = calculateRandomValue(actionData.heal, 20); // ±20% de variación
                const gained = DAMAGE.heal(target, healAmount, {
                  cap: true,
                  show: true,
                  type: "heal",
                });
                if (gained > 0) {
                  validateHP(target);
                  const healType =
                    action === "holywave" ? "holywave" : "healing";
                  playHealingAnim(target, healType);
                }
              }
            } else if (hasHealingDebuff) {
              console.log(
                `${target.clazz} cannot be healed due to healing debuff.`
              );
            }
          });
        }

        checkWaveCleared();
        checkGameOver();

        // Limpiar buffs de combustion consumidos
        hero.buffs = hero.buffs.filter((b) => {
          if (b.toRemove && b.type === "combustion") {
            // Remover también el debuff visual
            removeDebuff(hero, "combustion");
            console.log(
              "Combustion buff consumed and removed from",
              hero.clazz
            );
            return false;
          }
          return true;
        });

        // Resetear selección después de aplicar efectos
        selectedHero = null;
        selectedAction = null;
      }

      function playHealingAnim(target, healType = "healing") {
        // Efecto visual de curación (log removido)

        if (healType === "holywave") {
          addHolyWaveEffect(target.posx, target.posy);
        } else if (healType === "regrowth") {
          addRegrowthEffect(target.posx, target.posy);
        } else {
          addHealingEffect(target.posx, target.posy);
        }
      }

      // type: 'damage' | 'heal' | 'poison'
      function showHitNumber(
        x,
        y,
        value,
        isHealing = false,
        isCritical = false,
        type = null,
        baseEntity = null // pasar héroe/enemigo para posicionamiento relativo
      ) {
        let finalType = type;
        if (!finalType) {
          finalType = isHealing ? "heal" : "damage";
        }

        // Ajustes de posición según tipo y crítico sólo si tenemos entidad base
        if (baseEntity) {
          const baseX = baseEntity.posx;
          const baseY = baseEntity.posy;
          if (isCritical) {
            // Centrado arriba
            x = baseX;
            y = baseY - 60; // un poco más alto que los números normales
          } else if (finalType === "damage") {
            x = baseX - 20; // ligeramente a la izquierda
          } else if (finalType === "heal") {
            x = baseX + 20; // ligeramente a la derecha
          } else if (finalType === "poison") {
            x = baseX; // centro
          }
        }

        // Fallback: si no se pasó baseEntity e impacta probablemente a un héroe, ajustar ahora
        if (!baseEntity) {
          // Detectar héroe cercano (daño a héroes de enemigos, etc.)
          let nearestHero = null;
          let minDist = Infinity;
          heroes.forEach((h) => {
            const dx = Math.abs(h.posx - x);
            const dy = Math.abs(h.posy - 20 - y); // llamadas suelen usar posy-20
            const d = dx + dy;
            if (d < minDist && dx < 50 && dy < 80) {
              minDist = d;
              nearestHero = h;
            }
          });
          if (nearestHero) {
            if (isCritical) {
              x = nearestHero.posx;
              y = nearestHero.posy - 60;
            } else if (finalType === "damage") {
              x = nearestHero.posx - 20;
            } else if (finalType === "heal") {
              x = nearestHero.posx + 20;
            } else if (finalType === "poison") {
              x = nearestHero.posx;
            }
          }
        }

        hitNumbers.push({
          x,
          y,
          value,
          isHealing,
          isCritical,
          type: finalType,
          opacity: 1.0,
          startTime: currentTime,
          duration: 1.5,
        });
      }

      /* =============================
         HELPER: Unified damage/heal application (para futura migración)
         ============================= */
      const DAMAGE = {
        apply(
          target,
          raw,
          {
            min = 1,
            show = true,
            crit = false,
            type = "damage",
            source = null,
          } = {}
        ) {
          if (!target || target.hp <= 0 || isNaN(raw)) return 0;
          const effective = Math.max(min, raw);
          target.hp = Math.max(0, target.hp - effective);

          validateHP(target);
          if (show) {
            showHitNumber(
              target.posx,
              target.posy - 20,
              effective,
              false,
              crit,
              type,
              target
            );
          }
          return effective;
        },
        heal(target, amount, { cap = true, show = true, type = "heal" } = {}) {
          if (!target || target.hp <= 0 || isNaN(amount) || amount <= 0)
            return 0;
          const before = target.hp;
          target.hp = cap
            ? Math.min(target.maxhp, target.hp + amount)
            : target.hp + amount;
          const gained = target.hp - before;
          if (show && gained > 0) {
            showHitNumber(
              target.posx,
              target.posy - 20,
              gained,
              true,
              false,
              type,
              target
            );
          }
          return gained;
        },
      };

      function clearEffectsByTypeAndPosition(effectType, x, y) {
        // Eliminar solo los efectos del tipo especificado en la posición específica (mismo enemigo)
        const initialCount = visualEffects.length;
        for (let i = visualEffects.length - 1; i >= 0; i--) {
          const effect = visualEffects[i];
          if (
            effect.type === effectType &&
            Math.abs(effect.x - x) < 10 &&
            Math.abs(effect.y - y) < 10
          ) {
            visualEffects.splice(i, 1);
          }
        }
        const removedCount = initialCount - visualEffects.length;
        if (removedCount > 0) {
          console.log(
            `Eliminados ${removedCount} efectos de tipo ${effectType} en posición ${x},${y}`
          );
        }
      }

      function addFireblastEffect(x, y) {
        visualEffects.push({
          type: "fireblast",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.4, // Duración original
          frame: 0,
          frameCount: 4,
          frameWidth: 32,
          frameHeight: 32,
          size: 64, // Tamaño más grande
          repeat: 0, // Contador de repeticiones
          maxRepeats: 2, // Se repetirá 2 veces (total 3 reproducciones)
          endTime: currentTime + 0.4 * 3, // Tiempo absoluto de finalización (3 repeticiones)
        });
      }

      function addConflagrationEffect(x, y) {
        visualEffects.push({
          type: "conflagration",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.4, // Duración original
          frame: 0,
          frameCount: 4,
          frameWidth: 32,
          frameHeight: 32,
          size: 64, // Tamaño más grande
          repeat: 0, // Contador de repeticiones
          maxRepeats: 2, // Se repetirá 2 veces (total 3 reproducciones)
          endTime: currentTime + 0.4 * 3, // Tiempo absoluto de finalización (3 repeticiones)
        });
      }

      function addSlashEffect(x, y) {
        /* log removed */
        visualEffects.push({
          type: "slash",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.4, // Duración original
          frame: 0,
          frameCount: 4, // Frames 17, 18, 19, 20
          frameWidth: 32,
          frameHeight: 32,
          size: 64, // Tamaño más grande
          repeat: 0, // Contador de repeticiones
          maxRepeats: 2, // Se repetirá 2 veces (total 3 reproducciones)
          endTime: currentTime + 0.4 * 3, // Tiempo absoluto de finalización (3 repeticiones)
        });
      }

      function addHealingEffect(x, y) {
        /* log removed */
        visualEffects.push({
          type: "healing",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.0, // Duración más larga para aprovechar todos los frames
          frame: 0,
          frameCount: 7, // 7 frames totales (5 en primera fila + 2 en segunda)
          frameWidth: 96, // Nuevo tamaño de frame
          frameHeight: 96, // Nuevo tamaño de frame
          size: 120, // Tamaño renderizado más grande para mejor visibilidad
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 1.0,
        });
      }

      function addHolyWaveEffect(x, y) {
        /* log removed */
        visualEffects.push({
          type: "holy_wave",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.8, // Duración reducida para animación más fluida (era 1.6)
          frame: 0,
          frameCount: 11, // 11 frames en total (3 filas: 5+5+1)
          frameWidth: 128, // 640px / 5 frames por fila
          frameHeight: 128, // 384px / 3 filas
          size: 130, // Tamaño más grande para mejor visibilidad
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 0.8,
        });
      }

      function addRegrowthEffect(x, y) {
        /* log removed */
        visualEffects.push({
          type: "regrowth_new",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.9, // Duración reducida para animación más fluida (era 1.8)
          frame: 0,
          frameCount: 12, // 12 frames en total (3 filas: 5+5+2)
          frameWidth: 128, // 640px / 5 frames por fila
          frameHeight: 128, // 384px / 3 filas
          size: 125, // Tamaño apropiado para regeneración
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 0.9,
        });
      }

      function addCombustionEffect(x, y) {
        /* log removed */
        visualEffects.push({
          type: "combustion",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.8, // Duración reducida para animación más rápida (era 1.3s)
          frame: 0,
          frameCount: 26, // 26 frames en total
          frameWidth: 96, // 96x96 cada frame
          frameHeight: 96,
          size: 120, // Tamaño apropiado para el nuevo sprite
          repeat: 0,
          maxRepeats: 0, // Solo una reproducción
          endTime: currentTime + 0.8, // Tiempo absoluto de finalización actualizado
        });
      }

      function addSmiteEffect(x, y) {
        /* log removed */
        visualEffects.push({
          type: "smite",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.75, // Duración reducida para animación más fluida (era 1.5)
          frame: 0,
          frameCount: 10, // 10 frames en total (2 filas de 5 cada una)
          frameWidth: 128, // 640px / 5 frames por fila (asumiendo 640px total)
          frameHeight: 128, // 256px / 2 filas (asumiendo 256px total)
          size: 120, // Tamaño más grande para mejor impacto visual
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 0.75,
        });
      }

      function addInmolationEffect(x, y) {
        /* log removed */
        visualEffects.push({
          type: "inmolation",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.1, // Duración para 11 frames
          frame: 0,
          frameCount: 11, // 11 frames de dark bolt
          frameWidth: 64,
          frameHeight: 88,
          size: 90, // Tamaño apropiado para el efecto de dark bolt
          repeat: 0,
          maxRepeats: 1, // Se repite una vez (total 2 reproducciones)
          endTime: currentTime + 1.1 * 2, // Tiempo absoluto de finalización
        });
      }

      function addBloodSplatEffect(x, y) {
        /* log removed */
        visualEffects.push({
          type: "blood_splat",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.5, // Duración aumentada para 10 frames
          frame: 0,
          frameCount: 10, // 10 frames en total (2 filas de 5 cada una)
          frameWidth: 128, // 640px / 5 frames por fila
          frameHeight: 128, // 256px / 2 filas
          size: 140, // Tamaño más grande para mejor impacto visual
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 1.5,
        });
      }

      function addBloodStormEffect(x, y) {
        /* log removed */
        visualEffects.push({
          type: "blood_storm",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.2, // Duración para 9 frames
          frame: 0,
          frameCount: 9, // 9 frames en total (2 filas: 5+4)
          frameWidth: 192, // 960px / 5 frames por fila
          frameHeight: 128, // 256px / 2 filas
          size: 150, // Tamaño más grande para AoE
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 1.2,
        });
      }

      function addMinotaurSmashEffect(x, y) {
        /* log removed */
        visualEffects.push({
          type: "minotaur_smash",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.8, // Duración reducida para animación más fluida (era 1.6)
          frame: 0,
          frameCount: 8, // 8 frames en total (4 filas, 2 columnas)
          frameWidth: 128, // 256px / 2 columnas
          frameHeight: 160, // 640px / 4 filas
          size: 160, // Tamaño grande para impacto
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 0.8,
        });
      }

      function addMinotaurLifeStealEffect(x, y) {
        /* log removed */
        visualEffects.push({
          type: "minotaur_life_steal",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.8, // Duración reducida para animación más fluida (era 1.6)
          frame: 0,
          frameCount: 8, // 8 frames en total (4 filas, 2 columnas)
          frameWidth: 128, // 256px / 2 columnas
          frameHeight: 128, // 512px / 4 filas
          size: 150, // Tamaño apropiado para AoE
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 0.8,
        });
      }

      function addLavaEffect(x, y) {
        visualEffects.push({
          type: "lava",
          x: x,
          y: y + 30, // Debajo del enemigo
          startTime: currentTime,
          duration: 0.5, // 1/2 segundo
          particles: [],
        });
      }

      function addProtectionEffect(heroes) {
        heroes.forEach((hero) => {
          if (hero.hp > 0) {
            visualEffects.push({
              type: "protection",
              x: hero.posx,
              y: hero.posy,
              startTime: currentTime,
              duration: 1.0, // 1 segundo
              radius: 0,
            });
          }
        });
      }

      function addPoisonEffect(x, y) {
        /* log removed */
        visualEffects.push({
          type: "poison",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 2.0, // 2 segundos para mejor visibilidad
          radius: 0,
          particles: [],
        });
      }

      function addPoisonMainEffect(x, y) {
        /* log removed */
        visualEffects.push({
          type: "poison_main",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.0, // 1 segundo de duración
          frame: 0,
          frameWidth: 96, // Ancho de cada frame
          frameHeight: 96, // Alto de cada frame
          totalFrames: 31, // 31 frames en el sprite
          frameRate: 30, // 30 fps para animación rápida
        });
      }

      function addCosmicHorrorEffect(x, y) {
        /* log removed */
        visualEffects.push({
          type: "cosmic_horror",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.5, // 1.5 segundos de duración
          radius: 0,
          particles: [],
          intensity: 1.0,
        });
      }

      function addTentacleStrikeEffect(x, y) {
        /* log removed */
        visualEffects.push({
          type: "cthulu_main", // Usar nuevo efecto específico
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.0, // Duración reducida para animación más rápida (era 1.55s)
          frame: 0,
          frameCount: 31, // 31 frames en total
          frameWidth: 96, // 96x96 cada frame
          frameHeight: 96,
          size: 120, // Tamaño apropiado
        });
      }

      function addToxicHorrorEffect(x, y) {
        /* log removed */
        // Crear efecto en cada héroe vivo
        heroes.forEach((hero) => {
          if (hero.hp > 0) {
            visualEffects.push({
              type: "cthulu_special", // Usar nuevo efecto específico
              x: hero.posx,
              y: hero.posy,
              startTime: currentTime,
              duration: 1.2, // Duración reducida para animación más rápida (era 2.0s)
              frame: 0,
              frameCount: 40, // 40 frames en total
              frameWidth: 96, // 96x96 cada frame
              frameHeight: 96,
              size: 120, // Tamaño apropiado
            });
          }
        });
      }

      function addMeteorEffect(x, y) {
        visualEffects.push({
          type: "meteor",
          x: x,
          y: y - 150, // Empezar desde arriba
          targetX: x,
          targetY: y,
          startTime: currentTime,
          duration: 0.8, // 0.8 segundos para caer
          trail: [], // Estela del meteorito
          impacted: false,
        });
      }

      // ================================
      // EFECTOS VISUALES NIVEL 4
      // ================================

      function addVoidspecterDarkBoltEffect(x, y) {
        visualEffects.push({
          type: "voidspecter_darkbolt",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.8, // Duración del efecto
          frame: 0,
          frameCount: 8, // 8 frames en row
          frameWidth: 128, // 128x128 cada frame
          frameHeight: 128,
          size: 140, // Tamaño del efecto
        });
      }

      function addSummonPortalEffect(x, y, onComplete) {
        visualEffects.push({
          type: "summon_portal",
          x,
          y,
          frame: 0,
          totalFrames: 7,
          frameDuration: 0.075, // un poco más lento
          elapsed: 0,
          w: 64,
          h: 64,
          cols: 4,
          rows: 2,
          loopCount: 0, // cuántas iteraciones completas llevamos
          spawnAfterLoops: 2, // retrasar aparición hasta terminar 2 ciclos
          renderScale: 1.35, // portal más grande
          onComplete,
        });
      }

      function addTheHandDarkProtectionEffect(x, y) {
        visualEffects.push({
          type: "thehand_darkprotection",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.2, // Duración del efecto
          frame: 0,
          frameCount: 23, // 23 frames en grid 5x5
          frameWidth: 128, // 128x128 cada frame
          frameHeight: 128,
          size: 130, // Tamaño reducido ligeramente
          gridCols: 5, // 5 columnas en el grid
          gridRows: 5, // 5 filas en el grid
        });
      }

      function addAbyssKingMainAbilityEffect(x, y) {
        visualEffects.push({
          type: "abyss_main_ability",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.0, // Duración del efecto
          frame: 0,
          frameCount: 23, // 23 frames en grid 4x6
          frameWidth: 128, // 128x128 cada frame
          frameHeight: 128,
          size: 160, // Tamaño del efecto
          gridCols: 6, // 6 columnas en el grid
          gridRows: 4, // 4 filas en el grid
        });
      }

      // ================================
      // NUEVOS EFECTOS VISUALES HABILIDADES
      // ================================

      function addWarlockAgonyEffect(x, y) {
        visualEffects.push({
          type: "warlock_agony",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.8, // Duración del efecto
          frame: 0,
          frameCount: 12, // 12 frames en grid 3x4
          frameWidth: 128, // 128x128 cada frame
          frameHeight: 128,
          size: 140, // Tamaño del efecto
          gridCols: 3, // 3 columnas en el grid
          gridRows: 4, // 4 filas en el grid
        });
      }

      function addWarlockDarkSlashEffect(x, y) {
        visualEffects.push({
          type: "warlock_darkslash",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.7, // Duración del efecto
          frame: 0,
          frameCount: 7, // 7 frames en grid 3x3
          frameWidth: 128, // 128x128 cada frame
          frameHeight: 128,
          size: 150, // Tamaño del efecto
          gridCols: 3, // 3 columnas en el grid
          gridRows: 3, // 3 filas en el grid
        });
      }

      function addWarlockInmolation1Effect(x, y) {
        visualEffects.push({
          type: "warlock_inmolation1",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.0, // Duración del efecto
          frame: 0,
          frameCount: 15, // 15 frames en grid 3x5
          frameWidth: 128, // 128x128 cada frame
          frameHeight: 128,
          size: 160, // Tamaño del efecto
          gridCols: 3, // 3 columnas en el grid
          gridRows: 5, // 5 filas en el grid
        });
      }

      function addWarlockInmolation2Effect(x, y) {
        visualEffects.push({
          type: "warlock_inmolation2",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.8, // Duración del efecto
          frame: 0,
          frameCount: 9, // 9 frames en grid 3x3
          frameWidth: 128, // 128x128 cada frame
          frameHeight: 128,
          size: 140, // Tamaño del efecto
          gridCols: 3, // 3 columnas en el grid
          gridRows: 3, // 3 filas en el grid
        });
      }

      function addWarlockInmolationEffect(x, y) {
        // Añadir primer sprite de inmolation
        addWarlockInmolation1Effect(x, y);

        // Añadir segundo sprite de inmolation al mismo tiempo (sin delay)
        addWarlockInmolation2Effect(x, y);
      }

      function addMageFireblastEffect(x, y) {
        visualEffects.push({
          type: "mage_fireblast",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.7, // Duración del efecto
          frame: 0,
          frameCount: 7, // 7 frames en grid 5x2
          frameWidth: 128, // 128x128 cada frame
          frameHeight: 128,
          size: 150, // Tamaño del efecto
          gridCols: 5, // 5 columnas en el grid
          gridRows: 2, // 2 filas en el grid
        });
      }

      function addGorgonMainAbilityEffect(x, y) {
        visualEffects.push({
          type: "gorgon_main_ability",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.0, // Duración del efecto
          frame: 0,
          frameCount: 10, // 10 frames en grid 5x2
          frameWidth: 256, // 256x192 cada frame
          frameHeight: 192,
          size: 200, // Tamaño del efecto
          gridCols: 5, // 5 columnas en el grid
          gridRows: 2, // 2 filas en el grid
        });
      }

      function addGorgonSpecialAbilityEffect(x, y) {
        visualEffects.push({
          type: "gorgon_special_ability",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.8, // Duración del efecto
          frame: 0,
          frameCount: 6, // 6 frames en row
          frameWidth: 192, // 192x128 cada frame
          frameHeight: 128,
          size: 180, // Tamaño del efecto
          gridCols: 6, // 6 columnas en el grid
          gridRows: 1, // 1 fila en el grid
        });
      }

      function updateHitNumbers(dt) {
        for (let i = hitNumbers.length - 1; i >= 0; i--) {
          const hitNum = hitNumbers[i];
          const elapsed = currentTime - hitNum.startTime;

          // Mover hacia arriba
          hitNum.y -= 30 * dt;

          // Fade out
          hitNum.opacity = Math.max(0, 1 - elapsed / hitNum.duration);

          // Eliminar cuando termine la animación
          if (elapsed >= hitNum.duration) {
            hitNumbers.splice(i, 1);
          }
        }
      }

      function updateVisualEffects(dt) {
        for (let i = visualEffects.length - 1; i >= 0; i--) {
          const effect = visualEffects[i];
          const elapsed = currentTime - effect.startTime;

          if (effect.type === "fireblast") {
            // Actualizar frame del efecto de fireblast con repeticiones
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Si completó una animación, resetear para repetir
            if (effect.frame >= effect.frameCount) {
              if (effect.repeat < effect.maxRepeats) {
                effect.repeat++;
                effect.startTime = currentTime; // Reiniciar tiempo
                effect.frame = 0;
              }
            }
          } else if (effect.type === "conflagration") {
            // Actualizar frame del efecto de conflagration con repeticiones
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Si completó una animación, resetear para repetir
            if (effect.frame >= effect.frameCount) {
              if (effect.repeat < effect.maxRepeats) {
                effect.repeat++;
                effect.startTime = currentTime; // Reiniciar tiempo
                effect.frame = 0;
              }
            }
          } else if (effect.type === "slash") {
            // Actualizar frame del efecto de slash con repeticiones
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Si completó una animación, resetear para repetir
            if (effect.frame >= effect.frameCount) {
              if (effect.repeat < effect.maxRepeats) {
                effect.repeat++;
                effect.startTime = currentTime; // Reiniciar tiempo
                effect.frame = 0;
              }
            }
          } else if (effect.type === "healing") {
            // Actualizar frame del efecto de curación
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "holy_wave") {
            // Actualizar frame del efecto de Holy Wave
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "regrowth_new") {
            // Actualizar frame del efecto de Regrowth mejorado
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "combustion") {
            // Actualizar frame del efecto de combustion (nueva versión sin repeticiones)
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);
          } else if (effect.type === "cthulu_main") {
            // Actualizar frame del efecto principal de Cthulhu
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);
          } else if (effect.type === "poison_main") {
            // Actualizar frame del efecto principal de veneno del Gorgon
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.totalFrames;
            effect.frame = Math.floor(elapsed / frameDuration);
          } else if (effect.type === "cthulu_special") {
            // Actualizar frame del efecto especial de Cthulhu
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);
          } else if (effect.type === "smite") {
            // Actualizar frame del efecto de smite
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "inmolation") {
            // Actualizar frame del efecto de inmolation con repeticiones
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Si completó una animación, resetear para repetir
            if (effect.frame >= effect.frameCount) {
              if (effect.repeat < effect.maxRepeats) {
                effect.repeat++;
                effect.startTime = currentTime; // Reiniciar tiempo
                effect.frame = 0;
              }
            }
          } else if (effect.type === "blood_splat") {
            // Actualizar frame del efecto de Blood Splat
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "blood_storm") {
            // Actualizar frame del efecto de Blood Storm
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "minotaur_smash") {
            // Actualizar frame del efecto de Minotaur Smash
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "minotaur_life_steal") {
            // Actualizar frame del efecto de Minotaur Life Steal
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "lava") {
            // Generar más partículas de lava (más intenso)
            if (Math.random() < 0.6) {
              // Era 0.3, ahora es 0.6
              effect.particles.push({
                x: effect.x + (Math.random() - 0.5) * 80, // Área más grande
                y: effect.y,
                vy: -40 - Math.random() * 50, // Velocidad más alta
                life: 0.5 + Math.random() * 0.4, // Vida más larga
                maxLife: 0.5 + Math.random() * 0.4,
              });
            }

            // Actualizar partículas
            for (let j = effect.particles.length - 1; j >= 0; j--) {
              const particle = effect.particles[j];
              particle.y += particle.vy * dt;
              particle.life -= dt;
              if (particle.life <= 0) {
                effect.particles.splice(j, 1);
              }
            }
          } else if (effect.type === "protection") {
            // Expandir el escudo
            effect.radius = (elapsed / effect.duration) * 50;
          } else if (effect.type === "poison") {
            // Expandir el efecto de veneno y generar partículas tóxicas
            effect.radius = (elapsed / effect.duration) * 40;

            // Generar partículas de veneno
            if (Math.random() < 0.4) {
              effect.particles.push({
                x: effect.x + (Math.random() - 0.5) * 60,
                y: effect.y + (Math.random() - 0.5) * 60,
                vy: -20 - Math.random() * 30,
                life: 0.8 + Math.random() * 0.6,
                maxLife: 0.8 + Math.random() * 0.6,
              });
            }

            // Actualizar partículas de veneno
            for (let j = effect.particles.length - 1; j >= 0; j--) {
              const particle = effect.particles[j];
              particle.y += particle.vy * dt;
              particle.life -= dt;
              if (particle.life <= 0) {
                effect.particles.splice(j, 1);
              }
            }
          } else if (effect.type === "cosmic_horror") {
            // Efecto de Horror Cósmico - ondas expansivas y distorsión
            effect.radius = (elapsed / effect.duration) * 80;
            effect.intensity = 1 - elapsed / effect.duration;

            // Generar partículas de energía cósmica
            if (Math.random() < 0.6) {
              effect.particles.push({
                x: effect.x + (Math.random() - 0.5) * 100,
                y: effect.y + (Math.random() - 0.5) * 100,
                vy: -30 - Math.random() * 40,
                vx: (Math.random() - 0.5) * 60,
                life: 1.0 + Math.random() * 0.5,
                maxLife: 1.0 + Math.random() * 0.5,
              });
            }

            // Actualizar partículas cósmicas
            for (let j = effect.particles.length - 1; j >= 0; j--) {
              const particle = effect.particles[j];
              particle.x += particle.vx * dt;
              particle.y += particle.vy * dt;
              particle.life -= dt;
              if (particle.life <= 0) {
                effect.particles.splice(j, 1);
              }
            }
          } else if (effect.type === "tentacle_strike") {
            // Efecto de Golpe de Tentáculo - tentáculos serpenteantes
            effect.radius = (elapsed / effect.duration) * 60;

            // Generar partículas de tentáculos
            if (Math.random() < 0.5) {
              effect.particles.push({
                x: effect.x + (Math.random() - 0.5) * 80,
                y: effect.y + (Math.random() - 0.5) * 80,
                vy: -25 - Math.random() * 35,
                vx: (Math.random() - 0.5) * 50,
                life: 0.8 + Math.random() * 0.4,
                maxLife: 0.8 + Math.random() * 0.4,
              });
            }

            // Actualizar partículas de tentáculos
            for (let j = effect.particles.length - 1; j >= 0; j--) {
              const particle = effect.particles[j];
              particle.x += particle.vx * dt;
              particle.y += particle.vy * dt;
              particle.life -= dt;
              if (particle.life <= 0) {
                effect.particles.splice(j, 1);
              }
            }
          } else if (effect.type === "meteor") {
            // Animación del meteorito cayendo
            const progress = Math.min(elapsed / effect.duration, 1);
            const easeProgress = 1 - Math.pow(1 - progress, 3); // Easing para aceleración

            effect.x = effect.targetX;
            effect.y = effect.targetY - 150 + 150 * easeProgress;

            // Agregar punto a la estela
            effect.trail.push({ x: effect.x, y: effect.y, life: 0.3 });

            // Actualizar estela
            for (let j = effect.trail.length - 1; j >= 0; j--) {
              effect.trail[j].life -= dt;
              if (effect.trail[j].life <= 0) {
                effect.trail.splice(j, 1);
              }
            }

            // Impacto al llegar al suelo
            if (progress >= 1 && !effect.impacted) {
              effect.impacted = true;
              // Crear efecto de explosión
              for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                effect.trail.push({
                  x: effect.targetX + Math.cos(angle) * 20,
                  y: effect.targetY + Math.sin(angle) * 20,
                  life: 0.5,
                });
              }
            }
          } else if (effect.type === "voidspecter_darkbolt") {
            // Actualizar frame del efecto de Dark Bolt del Voidspecter
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "summon_portal") {
            // Avanzar frames del portal (basado en frameDuration acumulado)
            effect.elapsed += dt;
            if (effect.elapsed >= effect.frameDuration) {
              effect.elapsed -= effect.frameDuration;
              effect.frame++;
              if (effect.frame >= effect.totalFrames) {
                effect.loopCount = (effect.loopCount || 0) + 1;
                if (
                  effect.spawnAfterLoops &&
                  effect.loopCount < effect.spawnAfterLoops
                ) {
                  // Reiniciar para segundo ciclo antes de invocar
                  effect.frame = 0;
                } else {
                  // Ejecutar callback y eliminar
                  if (effect.onComplete) effect.onComplete();
                  visualEffects.splice(i, 1);
                  i--;
                }
              }
            }
          } else if (effect.type === "thehand_darkprotection") {
            // Actualizar frame del efecto de Dark Protection de The Hand
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "abyss_main_ability") {
            // Actualizar frame del efecto principal del Abyss King
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "warlock_agony") {
            // Actualizar frame del efecto Agony del Warlock
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "warlock_darkslash") {
            // Actualizar frame del efecto Dark Slash del Warlock
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "warlock_inmolation1") {
            // Actualizar frame del efecto Inmolation 1 del Warlock
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "warlock_inmolation2") {
            // Actualizar frame del efecto Inmolation 2 del Warlock
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "mage_fireblast") {
            // Actualizar frame del efecto Fireblast del Mage
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "gorgon_main_ability") {
            // Actualizar frame del efecto principal del Gorgon
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "gorgon_special_ability") {
            // Actualizar frame del efecto especial del Gorgon
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          }

          // Eliminar efecto cuando termine (considerando repeticiones)
          if (
            effect.type === "fireblast" ||
            effect.type === "conflagration" ||
            effect.type === "slash" ||
            effect.type === "combustion" ||
            effect.type === "inmolation" ||
            effect.type === "blood_splat" ||
            effect.type === "blood_storm" ||
            effect.type === "minotaur_smash" ||
            effect.type === "minotaur_life_steal"
          ) {
            // Para efectos con repeticiones, eliminar cuando se haya superado el tiempo absoluto de finalización
            if (currentTime >= effect.endTime) {
              visualEffects.splice(i, 1);
            }
          } else if (elapsed >= effect.duration) {
            // Para otros efectos (healing, holy_wave, regrowth_new, smite, lava, protection, meteor, nivel4, warlock nuevos, mage nuevos, gorgon nuevos), eliminar normalmente
            visualEffects.splice(i, 1);
          }
        }
      }

      function renderHitNumbers() {
        ctx.save();
        ctx.textAlign = "center";

        hitNumbers.forEach((hitNum) => {
          ctx.globalAlpha = hitNum.opacity;

          // Configurar estilo según el tipo de hit
          if (hitNum.isCritical) {
            ctx.font = "bold 20px monospace"; // Reducido aún más (antes 22px)
            ctx.fillStyle = "#FFD700"; // Amarillo dorado para críticos
            ctx.lineWidth = 4;
          } else if (hitNum.type === "heal") {
            ctx.font = "bold 20px monospace";
            ctx.fillStyle = "#00c853"; // Verde ligeramente más oscuro
            ctx.lineWidth = 3;
          } else if (hitNum.type === "poison") {
            ctx.font = "bold 18px monospace"; // un poco más pequeño
            ctx.fillStyle = "#1b5e20"; // Verde oscuro para poison
            ctx.lineWidth = 3;
          } else {
            ctx.font = "bold 20px monospace";
            ctx.fillStyle = "#ff0000"; // Rojo para daño normal
            ctx.lineWidth = 3;
          }

          // Sombra para mejor visibilidad
          ctx.strokeStyle = "#000000";

          let text;
          if (typeof hitNum.value === "string") {
            // Mostrar tal cual para etiquetas especiales (SUMMON, DP+N)
            text = hitNum.value;
            ctx.fillStyle = "#FFFFFF";
            ctx.font = "bold 16px monospace";
          } else if (hitNum.isCritical) {
            text = `CRIT! -${hitNum.value}`;
          } else if (hitNum.type === "heal") {
            text = `+${hitNum.value}`;
          } else if (hitNum.type === "poison") {
            text = `-${hitNum.value}`; // mantener formato negativo
          } else {
            text = `-${hitNum.value}`;
          }

          ctx.strokeText(text, hitNum.x, hitNum.y);
          ctx.fillText(text, hitNum.x, hitNum.y);
        });

        ctx.restore();
      }

      function renderVisualEffects() {
        ctx.save();

        visualEffects.forEach((effect) => {
          const elapsed = currentTime - effect.startTime;
          const progress = elapsed / effect.duration;

          if (effect.type === "fireblast") {
            // Renderizar efecto de fireblast usando sprites - más grande
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = (7 + effect.frame) * effect.frameWidth; // Frames 8,9,10,11 (posiciones 7,8,9,10)
              const sy = 15 * effect.frameHeight; // Fila 15 (empezando desde 0)

              const renderSize = effect.size || 64;
              ctx.drawImage(
                effectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "conflagration") {
            // Renderizar efecto de conflagration usando sprites - más grande
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = (6 + effect.frame) * effect.frameWidth; // Frames 6,7,8,9 (posiciones 6,7,8,9)
              const sy = 0 * effect.frameHeight; // Fila 0 (empezando desde 0)

              const renderSize = effect.size || 64;
              ctx.drawImage(
                effectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "slash") {
            // Renderizar efecto de slash usando sprites púrpura - más grande
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = (17 + effect.frame) * effect.frameWidth; // Frames 17,18,19,20 (posiciones 17,18,19,20)
              const sy = 11 * effect.frameHeight; // Fila 11 (empezando desde 0)

              const renderSize = effect.size || 64;
              ctx.drawImage(
                purpleEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "healing") {
            // Renderizar efecto de curación usando el nuevo sprite específico
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame: 5 frames en primera fila, 2 en segunda
              let sx, sy;
              if (effect.frame < 5) {
                // Primera fila (frames 0-4)
                sx = effect.frame * effect.frameWidth;
                sy = 0;
              } else {
                // Segunda fila (frames 5-6)
                sx = (effect.frame - 5) * effect.frameWidth;
                sy = effect.frameHeight;
              }

              const renderSize = effect.size || 120; // Tamaño por defecto más grande
              ctx.drawImage(
                healingEffectsImg, // Usar el nuevo sprite de curación
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "combustion") {
            // Renderizar efecto de combustion usando el nuevo sprite mejorado
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = effect.frame * effect.frameWidth; // 26 frames en una sola fila
              const sy = 0; // Solo una fila

              const renderSize = effect.size || 120;
              ctx.drawImage(
                combustionEffectsImg, // Usar la nueva imagen
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "smite") {
            // Renderizar efecto de smite usando el nuevo sprite mejorado
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame: 5 frames en primera fila, 5 en segunda
              let sx, sy;
              if (effect.frame < 5) {
                // Primera fila (frames 0-4)
                sx = effect.frame * effect.frameWidth;
                sy = 0;
              } else {
                // Segunda fila (frames 5-9)
                sx = (effect.frame - 5) * effect.frameWidth;
                sy = effect.frameHeight;
              }

              const renderSize = effect.size || 120;
              ctx.drawImage(
                priestSmiteEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "holy_wave") {
            // Renderizar efecto de Holy Wave
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame: 5 frames en primera fila, 5 en segunda, 1 en tercera
              let sx, sy;
              if (effect.frame < 5) {
                // Primera fila (frames 0-4)
                sx = effect.frame * effect.frameWidth;
                sy = 0;
              } else if (effect.frame < 10) {
                // Segunda fila (frames 5-9)
                sx = (effect.frame - 5) * effect.frameWidth;
                sy = effect.frameHeight;
              } else {
                // Tercera fila (frame 10)
                sx = (effect.frame - 10) * effect.frameWidth;
                sy = effect.frameHeight * 2;
              }

              const renderSize = effect.size || 130;
              ctx.drawImage(
                priestHolyWaveEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "regrowth_new") {
            // Renderizar efecto de Regrowth mejorado
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame: 5 frames en primera fila, 5 en segunda, 2 en tercera
              let sx, sy;
              if (effect.frame < 5) {
                // Primera fila (frames 0-4)
                sx = effect.frame * effect.frameWidth;
                sy = 0;
              } else if (effect.frame < 10) {
                // Segunda fila (frames 5-9)
                sx = (effect.frame - 5) * effect.frameWidth;
                sy = effect.frameHeight;
              } else {
                // Tercera fila (frames 10-11)
                sx = (effect.frame - 10) * effect.frameWidth;
                sy = effect.frameHeight * 2;
              }

              const renderSize = effect.size || 125;
              ctx.drawImage(
                priestRegrowthEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "inmolation") {
            // Renderizar efecto de inmolation usando sprite de dark bolt
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = effect.frame * effect.frameWidth; // Frames 0-10
              const sy = 0; // Solo una fila

              const renderSize = effect.size || 90;
              ctx.drawImage(
                darkBoltEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "lava") {
            // Renderizar partículas de lava
            effect.particles.forEach((particle) => {
              const alpha = particle.life / particle.maxLife;
              ctx.globalAlpha = alpha;

              // Gradiente de colores más intenso: rojo-naranja-amarillo-blanco
              const colors = [
                "#ff0000",
                "#ff2200",
                "#ff4500",
                "#ff6600",
                "#ffa500",
                "#ffcc00",
                "#ffff00",
                "#ffffff",
              ];
              const colorIndex = Math.floor((1 - alpha) * (colors.length - 1));
              ctx.fillStyle = colors[colorIndex];

              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 4, 0, Math.PI * 2); // Partículas más grandes
              ctx.fill();

              // Brillo adicional
              ctx.globalAlpha = alpha * 0.5;
              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 6, 0, Math.PI * 2);
              ctx.fill();
            });

            // Base de lava burbujeante más intensa
            ctx.globalAlpha = 1 - progress;
            ctx.fillStyle = "#ff2200";
            for (let i = 0; i < 8; i++) {
              // Más burbujas
              const bubbleX = effect.x + (Math.random() - 0.5) * 70; // Área más grande
              const bubbleY = effect.y + Math.random() * 15;
              const bubbleSize = 3 + Math.random() * 6; // Burbujas más grandes
              ctx.beginPath();
              ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
              ctx.fill();
            }

            // Resplandor de base
            ctx.globalAlpha = (1 - progress) * 0.3;
            ctx.fillStyle = "#ff4500";
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, 30, 0, Math.PI * 2);
            ctx.fill();
          } else if (effect.type === "protection") {
            // Renderizar escudo de protección
            ctx.globalAlpha = Math.max(0, 1 - progress);
            ctx.strokeStyle = "#8A2BE2"; // Púrpura neón
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.stroke();

            // Brillo interior
            ctx.globalAlpha = Math.max(0, (1 - progress) * 0.3);
            ctx.fillStyle = "#9370DB"; // Púrpura más claro para el interior
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.fill();
          } else if (effect.type === "poison") {
            // Renderizar partículas de veneno
            effect.particles.forEach((particle) => {
              const alpha = particle.life / particle.maxLife;
              ctx.globalAlpha = alpha;

              // Colores tóxicos: verde ácido
              const colors = ["#00ff00", "#32cd32", "#adff2f", "#7fff00"];
              const colorIndex = Math.floor((1 - alpha) * (colors.length - 1));
              ctx.fillStyle = colors[colorIndex];

              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
              ctx.fill();

              // Brillo tóxico
              ctx.globalAlpha = alpha * 0.6;
              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 5, 0, Math.PI * 2);
              ctx.fill();
            });

            // Base de veneno burbujeante
            ctx.globalAlpha = Math.max(0, 1 - progress);
            ctx.strokeStyle = "#00ff00"; // Verde tóxico
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.stroke();

            // Resplandor interior venenoso
            ctx.globalAlpha = Math.max(0, (1 - progress) * 0.4);
            ctx.fillStyle = "#32cd32"; // Verde lima para el interior
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.fill();
          } else if (effect.type === "cosmic_horror") {
            // Renderizar efecto de Horror Cósmico
            const progress = (currentTime - effect.startTime) / effect.duration;

            // Renderizar partículas de energía cósmica
            effect.particles.forEach((particle) => {
              const alpha = particle.life / particle.maxLife;
              ctx.globalAlpha = alpha;

              // Colores cósmicos: púrpura oscuro y azul profundo
              const colors = ["#4B0082", "#8A2BE2", "#9400D3", "#6A0DAD"];
              const colorIndex = Math.floor((1 - alpha) * (colors.length - 1));
              ctx.fillStyle = colors[colorIndex];

              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 4, 0, Math.PI * 2);
              ctx.fill();

              // Resplandor cósmico
              ctx.globalAlpha = alpha * 0.5;
              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 7, 0, Math.PI * 2);
              ctx.fill();
            });

            // Ondas expansivas de horror cósmico
            ctx.globalAlpha = effect.intensity * 0.6;
            ctx.strokeStyle = "#4B0082"; // Púrpura profundo
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.stroke();

            // Distorsión central
            ctx.globalAlpha = effect.intensity * 0.3;
            ctx.fillStyle = "#9400D3"; // Violeta oscuro
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius * 0.5, 0, Math.PI * 2);
            ctx.fill();
          } else if (effect.type === "tentacle_strike") {
            // Renderizar efecto de Golpe de Tentáculo
            const progress = (currentTime - effect.startTime) / effect.duration;

            // Renderizar partículas de tentáculos
            effect.particles.forEach((particle) => {
              const alpha = particle.life / particle.maxLife;
              ctx.globalAlpha = alpha;

              // Colores de tentáculos: verde oscuro y marrón
              const colors = ["#2F4F2F", "#556B2F", "#6B8E23", "#8FBC8F"];
              const colorIndex = Math.floor((1 - alpha) * (colors.length - 1));
              ctx.fillStyle = colors[colorIndex];

              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
              ctx.fill();

              // Brillo de tentáculo
              ctx.globalAlpha = alpha * 0.4;
              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 6, 0, Math.PI * 2);
              ctx.fill();
            });

            // Base de tentáculos serpenteantes
            ctx.globalAlpha = Math.max(0, 1 - progress);
            ctx.strokeStyle = "#2F4F2F"; // Verde oscuro
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.stroke();

            // Centro de impacto
            ctx.globalAlpha = Math.max(0, (1 - progress) * 0.5);
            ctx.fillStyle = "#556B2F"; // Verde oliva
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius * 0.6, 0, Math.PI * 2);
            ctx.fill();
          } else if (effect.type === "meteor") {
            // Renderizar estela del meteorito
            effect.trail.forEach((point, index) => {
              const alpha = point.life / 0.5;
              ctx.globalAlpha = alpha;
              const size = 2 + alpha * 3;

              // Colores de fuego para la estela
              const colors = ["#ff0000", "#ff4500", "#ffa500", "#ffff00"];
              const colorIndex = Math.floor((1 - alpha) * (colors.length - 1));
              ctx.fillStyle = colors[colorIndex];

              ctx.beginPath();
              ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
              ctx.fill();
            });

            // Renderizar el meteorito en sí
            if (!effect.impacted) {
              ctx.globalAlpha = 1;

              // Núcleo del meteorito
              ctx.fillStyle = "#ffaa00";
              ctx.beginPath();
              ctx.arc(effect.x, effect.y, 8, 0, Math.PI * 2);
              ctx.fill();

              // Brillo exterior
              ctx.fillStyle = "#ff4500";
              ctx.beginPath();
              ctx.arc(effect.x, effect.y, 12, 0, Math.PI * 2);
              ctx.fill();

              // Resplandor
              ctx.globalAlpha = 0.6;
              ctx.fillStyle = "#ff0000";
              ctx.beginPath();
              ctx.arc(effect.x, effect.y, 16, 0, Math.PI * 2);
              ctx.fill();
            }
          } else if (effect.type === "blood_splat") {
            // Renderizar efecto de blood splat usando el nuevo sprite sheet (10 frames en 2 filas)
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame: 5 frames en primera fila, 5 en segunda
              let sx, sy;
              if (effect.frame < 5) {
                // Primera fila (frames 0-4)
                sx = effect.frame * effect.frameWidth;
                sy = 0;
              } else {
                // Segunda fila (frames 5-9)
                sx = (effect.frame - 5) * effect.frameWidth;
                sy = effect.frameHeight;
              }

              const renderSize = effect.size || 140;
              ctx.drawImage(
                bloodSplatEffectsImg, // Usar el nuevo sprite sheet
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "blood_storm") {
            // Renderizar efecto de blood storm (AoE a todos los aliados)
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame: 5 frames en primera fila, 4 en segunda
              let sx, sy;
              if (effect.frame < 5) {
                // Primera fila (frames 0-4)
                sx = effect.frame * effect.frameWidth;
                sy = 0;
              } else {
                // Segunda fila (frames 5-8)
                sx = (effect.frame - 5) * effect.frameWidth;
                sy = effect.frameHeight;
              }

              const renderSize = effect.size || 150;
              ctx.drawImage(
                bloodStormEffectsImg, // Usar el sprite original para AoE
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "minotaur_smash") {
            // Renderizar efecto de Minotaur Smash
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame en grid 4x2 (4 filas, 2 columnas)
              const col = effect.frame % 2; // Columna (0 o 1)
              const row = Math.floor(effect.frame / 2); // Fila (0-3)
              const sx = col * effect.frameWidth;
              const sy = row * effect.frameHeight;

              const renderSize = effect.size || 160;
              ctx.drawImage(
                minotaurSmashEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "minotaur_life_steal") {
            // Renderizar efecto de Minotaur Life Steal
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame en grid 4x2 (4 filas, 2 columnas)
              const col = effect.frame % 2; // Columna (0 o 1)
              const row = Math.floor(effect.frame / 2); // Fila (0-3)
              const sx = col * effect.frameWidth;
              const sy = row * effect.frameHeight;

              const renderSize = effect.size || 150;
              ctx.drawImage(
                minotaurLifeStealEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "cthulu_main") {
            // Renderizar efecto principal de Cthulhu (Tentacle Strike)
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = effect.frame * effect.frameWidth; // 31 frames en una sola fila
              const sy = 0; // Solo una fila

              const renderSize = effect.size || 120;
              ctx.drawImage(
                cthuluMainEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "poison_main") {
            // Renderizar efecto principal de veneno del Gorgon
            if (effect.frame < effect.totalFrames) {
              ctx.globalAlpha = 1;
              const sx = effect.frame * effect.frameWidth; // 31 frames en una sola fila
              const sy = 0; // Solo una fila

              const renderSize = 96; // Tamaño del efecto (96x96)
              ctx.drawImage(
                cthuluMainEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "cthulu_special") {
            // Renderizar efecto especial de Cthulhu (Toxic Horror)
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = effect.frame * effect.frameWidth; // 40 frames en una sola fila
              const sy = 0; // Solo una fila

              const renderSize = effect.size || 120;
              ctx.drawImage(
                cthuluSpecialEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "summon_portal") {
            const frame = effect.frame;
            const col = frame % effect.cols;
            const row = Math.floor(frame / effect.cols);
            const sx = col * effect.w;
            const sy = row * effect.h;
            ctx.save();
            ctx.globalAlpha = 0.9;
            ctx.translate(effect.x, effect.y);
            const scale = 1 + Math.sin(performance.now() / 140) * 0.08;
            const finalScale = scale * (effect.renderScale || 1);
            ctx.scale(finalScale, finalScale);
            ctx.drawImage(
              summonPortalImg,
              sx,
              sy,
              effect.w,
              effect.h,
              -effect.w / 2,
              -effect.h / 2,
              effect.w,
              effect.h
            );
            ctx.restore();
          } else if (effect.type === "voidspecter_darkbolt") {
            // Renderizar efecto de Dark Bolt del Voidspecter
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = effect.frame * effect.frameWidth; // 8 frames en row
              const sy = 0; // Solo una fila

              const renderSize = effect.size || 140;
              ctx.drawImage(
                voidspecterDarkBoltImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "thehand_darkprotection") {
            // Renderizar efecto de Dark Protection de The Hand
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              // Calcular posición en grid 5x5
              const col = effect.frame % effect.gridCols;
              const row = Math.floor(effect.frame / effect.gridCols);
              const sx = col * effect.frameWidth;
              const sy = row * effect.frameHeight;

              const renderSize = effect.size || 150;
              ctx.drawImage(
                theHandDarkProtectionImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "abyss_main_ability") {
            // Renderizar efecto principal del Abyss King
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              // Calcular posición en grid 4x6
              const col = effect.frame % effect.gridCols;
              const row = Math.floor(effect.frame / effect.gridCols);
              const sx = col * effect.frameWidth;
              const sy = row * effect.frameHeight;

              const renderSize = effect.size || 160;
              ctx.drawImage(
                abyssKingMainAbilityImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "warlock_agony") {
            // Renderizar efecto Agony del Warlock
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              // Calcular posición en grid 4x6
              const col = effect.frame % effect.gridCols;
              const row = Math.floor(effect.frame / effect.gridCols);
              const sx = col * effect.frameWidth;
              const sy = row * effect.frameHeight;

              const renderSize = effect.size || 120;
              ctx.drawImage(
                warlockAgonyImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "warlock_darkslash") {
            // Renderizar efecto Dark Slash del Warlock
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              // Calcular posición en grid 5x5
              const col = effect.frame % effect.gridCols;
              const row = Math.floor(effect.frame / effect.gridCols);
              const sx = col * effect.frameWidth;
              const sy = row * effect.frameHeight;

              const renderSize = effect.size || 120;
              ctx.drawImage(
                warlockDarkSlashImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "warlock_inmolation1") {
            // Renderizar efecto Inmolation 1 del Warlock
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              // Calcular posición en grid 3x5
              const col = effect.frame % effect.gridCols;
              const row = Math.floor(effect.frame / effect.gridCols);
              const sx = col * effect.frameWidth;
              const sy = row * effect.frameHeight;

              const renderSize = effect.size || 120;
              ctx.drawImage(
                warlockInmolation1Img,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "warlock_inmolation2") {
            // Renderizar efecto Inmolation 2 del Warlock
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              // Calcular posición en grid 3x3
              const col = effect.frame % effect.gridCols;
              const row = Math.floor(effect.frame / effect.gridCols);
              const sx = col * effect.frameWidth;
              const sy = row * effect.frameHeight;

              const renderSize = effect.size || 120;
              ctx.drawImage(
                warlockInmolation2Img,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "mage_fireblast") {
            // Renderizar efecto Fireblast del Mage
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              // Calcular posición en grid 5x2
              const col = effect.frame % effect.gridCols;
              const row = Math.floor(effect.frame / effect.gridCols);
              const sx = col * effect.frameWidth;
              const sy = row * effect.frameHeight;

              const renderSize = effect.size || 120;
              ctx.drawImage(
                mageFireblastImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "gorgon_main_ability") {
            // Renderizar efecto principal del Gorgon
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              // Calcular posición en grid 5x5
              const col = effect.frame % effect.gridCols;
              const row = Math.floor(effect.frame / effect.gridCols);
              const sx = col * effect.frameWidth;
              const sy = row * effect.frameHeight;

              const renderSize = effect.size || 120;
              ctx.drawImage(
                gorgonMainAbilityImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "gorgon_special_ability") {
            // Renderizar efecto especial del Gorgon
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              // Calcular posición en grid 6x1
              const col = effect.frame % effect.gridCols;
              const row = Math.floor(effect.frame / effect.gridCols);
              const sx = col * effect.frameWidth;
              const sy = row * effect.frameHeight;

              const renderSize = effect.size || 120;
              ctx.drawImage(
                gorgonSpecialAbilityImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          }
        });

        ctx.restore();
      }

      function getDistance(a, b) {
        const dx = a.posx - b.posx;
        const dy = a.posy - b.posy;
        return Math.sqrt(dx * dx + dy * dy);
      }

      function getClosestHero(enemy, heroes) {
        const aliveHeroes = heroes.filter((h) => h.hp > 0);
        if (aliveHeroes.length === 0) return null;

        let closest = aliveHeroes[0];
        let minDistance = getDistance(enemy, closest);

        for (let i = 1; i < aliveHeroes.length; i++) {
          const distance = getDistance(enemy, aliveHeroes[i]);
          if (distance < minDistance) {
            minDistance = distance;
            closest = aliveHeroes[i];
          }
        }

        return closest;
      }

      function getRandomHero(heroes) {
        const aliveHeroes = heroes.filter((h) => h.hp > 0);
        if (aliveHeroes.length === 0) return null;

        const randomIndex = Math.floor(Math.random() * aliveHeroes.length);
        return aliveHeroes[randomIndex];
      }

      // Funciones para manejo de debuffs/buffs
      function addDebuff(target, type, stacks = 1) {
        // Buscar si ya existe este debuff
        const existingDebuff = target.debuffs.find((d) => d.type === type);

        if (existingDebuff) {
          // Si ya existe, aumentar stacks (máximo según el tipo)
          switch (type) {
            case "berseker":
              existingDebuff.stacks = Math.min(
                existingDebuff.stacks + stacks,
                10
              ); // Máximo 10 stacks (30%)
              break;
            case "poison":
              existingDebuff.stacks += stacks; // Poison es stackeable sin límite
              // Actualizar icono para reflejar nuevo stack count
              existingDebuff.icon = getDebuffIcon(type);
              break;
            case "shadows":
              existingDebuff.stacks += stacks; // Shadows es stackeable sin límite
              // Actualizar icono para reflejar nuevo stack count
              existingDebuff.icon = getDebuffIcon(type);
              break;
            default:
              existingDebuff.stacks = stacks; // Para otros debuffs, reemplazar stacks
              break;
          }
        } else {
          // Si no existe, crear nuevo debuff
          const debuffData = {
            type: type,
            stacks: stacks,
            icon: getDebuffIcon(type), // Usar icon en lugar de iconInfo
          };

          // Asignar duración en turnos según el tipo
          switch (type) {
            case "shadows":
              debuffData.remainingTurns = 10;
              debuffData.damagePerTick = 2 + (stacks - 1) * 1;
              break;
            case "poison":
              debuffData.remainingTurns = 10;
              break;
            case "agony":
              debuffData.remainingTurns = 10;
              break;
            case "healing":
              debuffData.remainingTurns = 5; // Regrowth dura 5 turnos
              break;
            case "dark_protection":
              debuffData.remainingTurns = 10;
              break;
            case "combustion":
              // Combustion no tiene duración en turnos, se consume al usar
              break;
            case "berseker":
              // Berseker es permanente hasta muerte
              break;
            default:
              break;
          }

          target.debuffs.push(debuffData);
        }
      }

      function removeDebuff(target, type) {
        target.debuffs = target.debuffs.filter((d) => d.type !== type);
      }

      // Función para limpiar todos los debuffs y buffs cuando un héroe muere
      function clearAllEffectsOnDeath(hero) {
        if (hero.hp <= 0) {
          console.log(`${hero.clazz} died. Clearing all debuffs and buffs.`);

          // Limpiar todos los debuffs
          hero.debuffs = [];

          // Limpiar todos los buffs
          hero.buffs = [];

          console.log(`All effects cleared for ${hero.clazz}.`);
        }
      }

      function getDebuffIcon(type) {
        switch (type) {
          case "healing":
            return healingDebuffImg;
          case "regrowth":
            return healingDebuffImg;
          case "protection":
            return protectionDebuffImg;
          case "combustion":
            return combustionDebuffImg;
          case "berseker":
            return bersekerDebuffImg;
          case "poison":
            return poisonDebuffImg;
          case "shadows":
            return shadowsDebuffImg;
          case "agony":
            return agonyDebuffImg;
          case "dark_protection":
            return darkProtectionDebuffImg;
          default:
            return null;
        }
      }

      function renderDebuffs(target, baseX, baseY) {
        if (!target.debuffs || target.debuffs.length === 0) return;

        const iconSize = 16; // Ligera reducción (antes 17)
        const startX = baseX - 40; // Empezar desde la izquierda

        target.debuffs.forEach((debuff, index) => {
          const x = startX + index * (iconSize + 2); // Espaciado de 2px entre iconos
          const y = baseY;

          // Renderizar icono del debuff directamente
          if (debuff.icon) {
            ctx.drawImage(debuff.icon, x, y, iconSize, iconSize);

            // Si tiene stacks > 1, mostrar número pequeño
            if (debuff.stacks > 1) {
              ctx.save();
              ctx.fillStyle = "white";
              ctx.strokeStyle = "black";
              ctx.lineWidth = 1;
              ctx.font = "8px Arial";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";

              const text = debuff.stacks.toString();
              const textX = x + iconSize - 4;
              const textY = y + iconSize - 4;

              ctx.strokeText(text, textX, textY);
              ctx.fillText(text, textX, textY);
              ctx.restore();
            }
          }
        });
      }

      // Dibuja una barra con esquinas redondeadas, fondo, relleno proporcional y borde
      function drawRoundedBar(
        ctx,
        x,
        y,
        width,
        height,
        fillRatio,
        options = {}
      ) {
        const bgColor = options.bgColor || "rgba(0,0,0,0.5)";
        const fillColor = options.fillColor || "#FF0000";
        const borderColor = options.borderColor || "#2A1F0F";
        const radius = options.radius !== undefined ? options.radius : 5;
        const lineWidth =
          options.lineWidth !== undefined ? options.lineWidth : 1.2;
        const innerPadding = options.innerPadding || 0; // Por si queremos margen interno
        const r = Math.min(radius, width / 2, height / 2);
        const safeFill = Math.max(0, Math.min(1, fillRatio));

        ctx.save();

        // Fondo
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + width - r, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + r);
        ctx.lineTo(x + width, y + height - r);
        ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
        ctx.lineTo(x + r, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
        ctx.fillStyle = bgColor;
        ctx.fill();

        // Relleno
        if (safeFill > 0) {
          const fillW = (width - innerPadding * 2) * safeFill;
          ctx.save();
          ctx.beginPath();
          ctx.moveTo(x + r, y);
          ctx.lineTo(x + width - r, y);
          ctx.quadraticCurveTo(x + width, y, x + width, y + r);
          ctx.lineTo(x + width, y + height - r);
          ctx.quadraticCurveTo(
            x + width,
            y + height,
            x + width - r,
            y + height
          );
          ctx.lineTo(x + r, y + height);
          ctx.quadraticCurveTo(x, y + height, x, y + height - r);
          ctx.lineTo(x, y + r);
          ctx.quadraticCurveTo(x, y, x + r, y);
          ctx.closePath();
          ctx.clip();
          ctx.fillStyle = fillColor;
          ctx.fillRect(
            x + innerPadding,
            y + innerPadding,
            fillW,
            height - innerPadding * 2
          );
          ctx.restore();
        }

        // Borde
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + width - r, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + r);
        ctx.lineTo(x + width, y + height - r);
        ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
        ctx.lineTo(x + r, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = lineWidth;
        ctx.stroke();

        ctx.restore();
      }

      // NOTA: enemyAct() removida - ahora se usa sistema de auto-attack en el loop principal

      let lastTime = 0;
      function loop(time) {
        const delta = (time - lastTime) / 1000;
        lastTime = time;
        currentTime += delta;

        // Watchdog de Game Over: si todos los héroes murieron y el estado no cambió por alguna ruta, forzar
        if (
          state !== "game_over" &&
          heroes.length > 0 &&
          heroes.every((h) => h.hp <= 0)
        ) {
          console.warn(
            "[Watchdog] All heroes dead but state!=game_over. Forcing handleGameOver()."
          );
          handleGameOver();
        }

        // Actualizar sonidos pendientes
        updatePendingSounds();

        // Solo ejecutar lógica del juego si no estamos en el menú principal o pantallas informativas
        if (
          state !== "main_menu" &&
          state !== "level_info" &&
          state !== "book" &&
          state !== "guide"
        ) {
          // No hay timer automático para el modal - se controla por botón
          // Eliminado bloqueo por modal de fin de nivel (SDK lo maneja)
          // Update hit numbers
          updateHitNumbers(delta);

          // Manejo de transición entre waves
          if (waveTransition.active) {
            waveTransition.timer -= delta;
            // No pausar lógica: sólo un fade muy leve, sin texto, permitiendo que animaciones existentes terminen naturalmente
            const t = Math.max(0, waveTransition.timer / waveTransition.delay); // 1 -> 0
            const alpha = 0.25 * t; // se desvanece rápidamente
            // Dibujar más tarde tras draw() principal (se aplica después de actualizar todo)
          }

          // Update visual effects
          updateVisualEffects(delta);

          // Check wave cleared continuously
          checkWaveCleared();

          // Update buffs
          heroes.forEach((h) => {
            h.buffs = h.buffs.filter((b) => {
              // Buffs de combustión no se eliminan por tiempo, solo por uso
              if (b.type === "combustion") {
                return true; // Mantener hasta que se consuma
              }
              // Tipos convertidos a sistema por turnos (no usar tiempos)
              if (["regrowth", "agony", "poison"].includes(b.type)) return true;

              if (b.endTime && b.endTime <= currentTime) {
                return false;
              }

              if (b.type === "rejuvenation" && b.nextTick <= currentTime) {
                // Verificar si el héroe puede recibir curación
                const hasHealingDebuff =
                  h.debuffs && h.debuffs.some((d) => d.type === "healing");

                if (!hasHealingDebuff && h.hp > 0) {
                  h.hp = Math.min(h.maxhp, h.hp + b.heal);
                  validateHP(h);
                  console.log(
                    "Rejuvenation tick para",
                    h.clazz,
                    "- creando efecto visual de curación"
                  );
                  playHealingAnim(h);
                  showHitNumber(
                    h.posx,
                    h.posy - 20,
                    b.heal,
                    true,
                    false,
                    "heal",
                    h
                  );
                } else if (hasHealingDebuff) {
                  console.log(
                    `${h.clazz} rejuvenation blocked by healing debuff.`
                  );
                }
                b.nextTick += 1;
              }
              return true;
            });
          });

          // Update animations
          heroes.forEach((h) => {
            if (h.hp <= 0) return;
            const animData = h.animations[h.anim];
            h.animTime += delta;
            const frameDuration = animData.duration / animData.frames;
            if (h.animTime >= frameDuration) {
              h.animTime -= frameDuration;
              h.frame = (h.frame + 1) % animData.frames;
              if (h.frame === 0 && h.anim !== "idle" && h.anim !== "selected") {
                // Aplicar efecto si el héroe tiene una acción pendiente (sin depender del estado global)
                if (h.action && h.targets && h.targets.length > 0) {
                  // Marcar acción activa de héroe para bloquear ataques enemigos hasta que se aplique
                  if (!activeAction) activeAction = h;
                  console.log(
                    "Animation completed! Applying effect for hero:",
                    h.clazz,
                    "action:",
                    h.action,
                    "targets:",
                    h.targets ? h.targets.length : 0,
                    "target types:",
                    h.targets
                      ? h.targets.map((t) => t.clazz || "enemy").join(",")
                      : "none"
                  );

                  // Verificar que tenemos una acción válida antes de aplicar efectos
                  if (h.action && h.targets && h.targets.length > 0) {
                    applyEffect(h, h.action, h.targets);

                    // Limpiar propiedades de acción SOLO para este héroe después de aplicar el efecto
                    console.log(
                      "Limpiando propiedades de acción para",
                      h.clazz
                    );
                    // Ahora aplicamos (si existe) el tick diferido de poison - la curación/acción ya ocurrió
                    // Aplicar ticks de poison aplazados de todos los héroes (primero se resolvió la acción: curas, etc.)
                    heroes.forEach(processDeferredPoisonTick);
                    h.targets = [];
                    h.action = null;
                    h.actionStartTime = null; // Limpiar timestamp de acción
                    if (activeAction === h) activeAction = null; // liberar acción activa tras aplicar

                    // CRÍTICO: Remover al héroe del turnQueue después de aplicar su efecto
                    if (turnQueue.length > 0 && turnQueue[0] === h) {
                      turnQueue.shift();
                      console.log(
                        `${h.clazz} removed from turn queue after applying effect`
                      );
                    }

                    // NO cambiar estado global, mantener "select_hero" para permitir clicks rápidos
                    state = "select_hero";
                  } else {
                    console.warn(
                      "Hero",
                      h.clazz,
                      "has no valid action or targets to apply. Action:",
                      h.action,
                      "Targets length:",
                      h.targets ? h.targets.length : 0
                    );
                  }
                }
                // Cambiar a idle después de aplicar el efecto (ya no dependemos del estado "animate")
                h.anim = "idle";
              }
            }
          });

          // Marcar visualmente al héroe cuyo turno está activo con la animación 'selected'
          // Actualizar timer de delay para secuenciar acciones
          if (actionDelayTimer > 0) {
            actionDelayTimer -= delta;
            if (actionDelayTimer < 0) actionDelayTimer = 0;
          }
          // Limpiar entidades muertas de la cola y asegurar que siempre haya un vivo al frente o quede vacía.
          // Además, no iniciar nueva acción mientras otra está activa o en delay.
          let safety = 0;
          while (turnQueue.length > 0 && safety < 50) {
            safety++;
            const front = turnQueue[0];

            // Verificaciones mejoradas de integridad
            if (!front || front.hp === undefined || front.hp <= 0) {
              console.log(
                `Removing invalid/dead entity from turn queue: ${
                  front?.name || front?.clazz || "unknown"
                }`
              );
              turnQueue.shift();
              lastTurnEntity = null;
              continue;
            }

            // Verificar que la entidad aún existe en las listas del juego
            const entityExists = front.clazz
              ? heroes.includes(front)
              : enemies.includes(front);

            if (!entityExists) {
              console.warn(
                `Entity ${
                  front.name || front.clazz
                } no longer exists in game, removing from queue`
              );
              turnQueue.shift();
              lastTurnEntity = null;
              continue;
            }

            // Watchdog: si activeAction quedó colgado sobre una entidad muerta o sin animación, liberarlo
            if (
              activeAction &&
              (activeAction.hp <= 0 ||
                (!enemies.includes(activeAction) &&
                  !heroes.includes(activeAction)) ||
                (activeAction.anim !== "attack" &&
                  activeAction.anim !== "cast" &&
                  activeAction.animTime <= 0))
            ) {
              console.warn(
                `Clearing stuck activeAction for ${
                  activeAction.name || activeAction.clazz
                }`
              );
              activeAction = null;
            }
            // Esperar a que la acción previa termine antes de procesar nuevo turno
            if (
              activeAction &&
              (actionDelayTimer > 0 ||
                (front !== activeAction && activeAction.animTime > 0))
            ) {
              break; // Hay acción en curso, esperamos
            }
            if (front !== lastTurnEntity) {
              processTurnStart(front);
              if (front.hp <= 0) {
                turnQueue.shift();
                lastTurnEntity = null;
                continue;
              }
              // Si tras processTurnStart el frente es enemigo boss listo pero no disparará (p.ej. ataquesUntilSpecial==null), aseguramos que ataquesUntilSpecial exista
              if (front.type === "boss" && front.attacksUntilSpecial == null) {
                front.attacksUntilSpecial = front.specialAttackCounter || 3;
              }
              lastTurnEntity = front;
            }
            break;
          }
          const activeEntity = turnQueue.length > 0 ? turnQueue[0] : null;
          heroes.forEach((h) => {
            if (h.hp <= 0) return;
            if (activeEntity === h) {
              if (h.anim === "idle" || h.anim === "selected") {
                if (h.anim !== "selected") {
                  h.anim = "selected";
                  h.frame = 0;
                  h.animTime = 0;
                }
              }
            } else {
              // Si estaba en selected pero ya no es su turno y no está ejecutando acción, volver a idle
              if (h.anim === "selected" && !h.action) {
                h.anim = "idle";
                h.frame = 0;
                h.animTime = 0;
              }
            }
          });
          // Desbloquear input si todos los enemigos han terminado su fade de spawn
          if (heroInputLocked) {
            const allSpawned = enemies.every(
              (e) =>
                e.spawnFadeProgress === undefined || e.spawnFadeProgress >= 1
            );
            if (!waveTransition.active && allSpawned) heroInputLocked = false;
          }

          // Process debuffs for enemies (Shadows, etc.)
          enemies.forEach((e) => {
            if (e.hp > 0 && e.debuffs) {
              // La lógica de expiración y ticks se maneja en processTurnStart ahora
            }
          });

          // Update enemy charge and check for automatic attacks
          enemies.forEach((e) => {
            // Actualizar animaciones de muerte independientemente del estado
            if (e.anim === "die") {
              const elapsed = currentTime - e.animStartTime;
              const frameDuration = 0.12; // Duración por frame para muerte (más fluido: 0.15 -> 0.12)
              e.frame = Math.floor(elapsed / frameDuration);
              const deathFrames = e.deathFrames || 6; // Usar frames dinámicos o fallback
              if (e.frame >= deathFrames) {
                e.deathAnimComplete = true;
                e.frame = deathFrames - 1; // Mantener en el último frame
              }
            }

            if (e.hp > 0 && !e.isDying) {
              // Use the new charge speed rating system, fallback to legacy chargeSpeed for compatibility
              const chargeSpeed = e.chargeSpeedRating
                ? getChargeSpeedFromRating(e.chargeSpeedRating)
                : e.chargeSpeed || 20;
              e.charge = Math.min(e.maxcharge, e.charge + delta * chargeSpeed);

              // Cuando se llena la barra, añadir a la cola si no está
              if (e.charge >= 100 && !turnQueue.includes(e)) {
                turnQueue.push(e);
                e.chargeFullTime = currentTime; // Marcar cuándo se llenó la carga
              }

              // Verificación de timeout para enemigos con carga llena que no atacan
              if (
                e.charge >= 100 &&
                e.chargeFullTime &&
                currentTime - e.chargeFullTime > 5000
              ) {
                console.warn(
                  `Enemy ${e.name} has been charged for too long (${
                    currentTime - e.chargeFullTime
                  }ms), forcing action reset`
                );
                e.charge = 50; // Reducir carga para forzar nueva carga
                e.chargeFullTime = null;
                // Remover de cola si está presente
                const queueIndex = turnQueue.indexOf(e);
                if (queueIndex >= 0) {
                  turnQueue.splice(queueIndex, 1);
                }
              }

              // Limpiar acciones de héroes que puedan estar colgadas o llevan demasiado tiempo
              heroes.forEach((h) => {
                if (h.hp > 0 && h.action) {
                  const actionAge =
                    currentTime - (h.actionStartTime || currentTime);

                  // Si la acción lleva más de 3 segundos O el héroe está en idle sin animTime
                  if (
                    actionAge > 3000 ||
                    ((!h.anim || h.anim === "idle") && h.animTime <= 0)
                  ) {
                    console.warn(
                      `Clearing stuck action for hero ${h.clazz}:`,
                      h.action,
                      `(age: ${actionAge}ms, anim: ${h.anim}, animTime: ${h.animTime})`
                    );
                    h.action = null;
                    h.targets = null;
                    h.anim = "idle";
                    h.animTime = 0;
                    h.actionStartTime = null;
                  }
                }
              });

              // Procesar ataque solo si es su turno (al frente de la cola)
              if (
                turnQueue.length > 0 &&
                turnQueue[0] === e &&
                e.charge >= 100 &&
                e.animTime <= 0 &&
                (!activeAction || activeAction === e) &&
                actionDelayTimer === 0 &&
                // Solo bloquear si un héroe VIVO tiene acción pendiente
                !heroes.some((h) => h.hp > 0 && h.action) // Esperar resolución de acción de héroe vivo
              ) {
                // Debug específico para Minotaur
                if (e.name === "Minotaur") {
                  console.log(`Minotaur attack processing - conditions met`);
                }

                // Lógica especial para Crab Bomb
                if (e.name === "Crab Bomb") {
                  e.charge = 0; // Reset charge

                  // Incrementar esferas de carga
                  e.sphereCharges = (e.sphereCharges || 0) + 1;
                  console.log(
                    `Crab Bomb sphere charge: ${e.sphereCharges}/${e.maxSphereCharges}`
                  );

                  // Si llegó a 5 esferas, explotar
                  if (e.sphereCharges >= e.maxSphereCharges) {
                    console.log("Crab Bomb explodes!");

                    // Cambiar a animación de explosión
                    e.anim = "explode";
                    e.frame = 0;
                    e.animStartTime = currentTime;

                    // Marcar que debe aplicar daño al final de la animación
                    e.explosionDamagePending = true;

                    // No aplicar daño inmediatamente, se aplicará cuando termine la animación
                  }
                  // Consumió su turno (aunque no haya explotado aún)
                  if (turnQueue[0] === e) turnQueue.shift();
                  return; // Salir de la función para evitar el ataque normal
                }

                // Determinar el nivel actual para decidir el targeting
                const currentLevel = Math.floor(wave / 3) + 1;

                // En Red Dunes (nivel 2) los enemigos atacan a un aliado aleatorio
                // En otros niveles atacan al más cercano
                const target =
                  currentLevel === 2
                    ? getRandomHero(heroes)
                    : getClosestHero(e, heroes);

                if (target) {
                  // RANGOS BASE SEGÚN ESPECIFICACIÓN
                  let damage;
                  if (e.name === "Demon Bat") {
                    damage = 25 + Math.floor(Math.random() * 11); // 25-35
                  } else if (e.name === "Fire Worm") {
                    damage = 30 + Math.floor(Math.random() * 11); // 30-40
                  } else if (e.name === "Mushroom") {
                    damage = 10 + Math.floor(Math.random() * 6); // 10-15
                  } else if (e.name === "Dreadwing") {
                    damage = 20 + Math.floor(Math.random() * 6); // 20-25 por golpe (cada uno)
                  } else if (e.name === "Gorgon") {
                    damage = 20 + Math.floor(Math.random() * 6); // 20-25 (main con poison)
                  } else if (e.name === "Noctebane") {
                    damage = 25 + Math.floor(Math.random() * 11); // 25-35 (main/special se reasigna más abajo)
                  } else if (e.name === "Minotaur") {
                    damage = 45 + Math.floor(Math.random() * 11); // 45-55 base (se ajusta igual en main/special)
                  } else if (e.name === "Crab Bomb") {
                    damage = 0; // explosión aparte
                  } else {
                    damage = 25; // fallback
                  }
                  e.charge = 0; // Reset charge
                  e.chargeFullTime = null; // Limpiar timestamp de carga llena
                  e.animTime = 0.5;
                  // Abyss King siempre permanece en IDLE y parpadea durante ataques
                  if (e.name === "Abyss King") {
                    e.anim = "idle";
                    e.flickerEffect = {
                      active: true,
                      duration: 0.6,
                      startTime: currentTime,
                    }; // Efecto de parpadeo
                  } else {
                    e.anim = "attack"; // Otros enemigos usan animación de ataque normal
                  }
                  e.frame = 0; // Reiniciar frame
                  e.animStartTime = currentTime; // Tiempo de inicio de la animación
                  activeAction = e; // Marcar acción activa

                  // Consumir turno inmediatamente (permite que el siguiente en cola avance mientras anima)
                  if (turnQueue[0] === e) turnQueue.shift();
                  actionDelayTimer = 0.4; // delay base tras iniciar animación

                  // Manejo de ataques de Boss (Boss Bat y Minotaur)
                  let isSpecialAttack = false;
                  let isMainAbility = false;
                  if (e.type === "boss" && e.attacksUntilSpecial !== null) {
                    e.attacksUntilSpecial--;
                    if (e.attacksUntilSpecial <= 0) {
                      isSpecialAttack = true;
                      e.isSpecialAttack = true; // Marcar el enemigo para renderizado
                      e.attacksUntilSpecial = e.specialAttackCounter; // Reset counter
                      // ESPECIALES
                      if (e.name === "Noctebane") {
                        damage = 25 + Math.floor(Math.random() * 11); // 25-35 AoE
                      } else if (e.name === "Minotaur") {
                        damage = 45 + Math.floor(Math.random() * 11); // 45-55 AoE Life Steal
                      } else if (e.name === "Gorgon") {
                        damage = 30 + Math.floor(Math.random() * 11); // 30-40 AoE Toxic Horror
                      } else if (e.name === "Abyss King") {
                        // Especial del Abyss King es invocar: sin daño y sin anim de ataque, permanece idle
                        damage = 0;
                        e.anim = "idle";
                        e.animTime = 0; // evitar desplazamientos temporales de animación
                        e.flickerEffect = {
                          active: true,
                          duration: 0.8,
                          startTime: currentTime,
                        }; // Efecto de parpadeo para especial
                      }
                    } else {
                      // Ataques principales/normales
                      isMainAbility = true;
                      if (e.name === "Noctebane") {
                        damage = 25 + Math.floor(Math.random() * 11); // 25-35 Blood Splat
                      } else if (e.name === "Minotaur") {
                        damage = 45 + Math.floor(Math.random() * 11); // 45-55 Smash
                      } else if (e.name === "Gorgon") {
                        damage = 20 + Math.floor(Math.random() * 6); // 20-25 poison main
                      } else if (e.name === "Abyss King") {
                        damage = 35 + Math.floor(Math.random() * 11); // 35-45 Abyss Strike
                        // Abyss King permanece en IDLE incluso durante ataque principal
                        e.anim = "idle";
                        e.flickerEffect = {
                          active: true,
                          duration: 0.6,
                          startTime: currentTime,
                        }; // Efecto de parpadeo
                      }
                    }
                  }

                  setTimeout(() => {
                    if (isSpecialAttack) {
                      if (e.name === "Noctebane") {
                        // Ataque especial: Blood Storm (daño AoE a todos los héroes)
                        console.log(
                          "Noctebane uses Blood Storm special attack (AoE)!"
                        );
                        heroes.forEach((hero) => {
                          if (hero.hp > 0) {
                            const currentDef =
                              hero.def +
                              hero.buffs.reduce(
                                (sum, b) =>
                                  b.type === "protection" || b.type === "agony"
                                    ? sum + b.defBonus
                                    : sum,
                                0
                              );

                            const criticalResult = calculateCritical(damage);
                            let finalDamage = criticalResult.damage;
                            if (e.name === "Noctebane") {
                              finalDamage = Math.floor(
                                finalDamage * (e.damageMultiplier || 1)
                              );
                            }
                            let effectiveDamage = Math.max(
                              1,
                              finalDamage - currentDef
                            );
                            if (e.name === "Noctebane") {
                              e.damageMultiplier =
                                (e.damageMultiplier || 1) * 1.05; // +5% tras especial
                            }

                            // Agony turn-based: mitigación ya reflejada en currentDef via defBonus.

                            hero.hp = Math.max(0, hero.hp - effectiveDamage);
                            validateHP(hero);

                            console.log(
                              `${
                                hero.clazz || "Hero"
                              } takes ${effectiveDamage} AoE damage from Blood Storm!`
                            );

                            // Mostrar número de daño para cada héroe afectado
                            showHitNumber(
                              hero.posx,
                              hero.posy - 20,
                              effectiveDamage,
                              false,
                              criticalResult.isCritical
                            );

                            // Agregar efecto visual de Blood Storm para cada héroe
                            addBloodStormEffect(hero.posx, hero.posy);
                          }
                        });
                      } else if (e.name === "Minotaur") {
                        // Ataque especial: Life Steal (AoE que roba vida)
                        console.log("Minotaur uses Life Steal special attack!");
                        let totalDamageDealt = 0;

                        heroes.forEach((hero) => {
                          if (hero.hp > 0) {
                            const currentDef =
                              hero.def +
                              hero.buffs.reduce(
                                (sum, b) =>
                                  b.type === "protection" || b.type === "agony"
                                    ? sum + b.defBonus
                                    : sum,
                                0
                              );

                            const criticalResult = calculateCritical(damage);
                            let finalDamage = criticalResult.damage;
                            let effectiveDamage = Math.max(
                              1,
                              finalDamage - currentDef
                            );

                            // Agony turn-based: mitigación ya reflejada en currentDef via defBonus.

                            hero.hp = Math.max(0, hero.hp - effectiveDamage);
                            validateHP(hero);
                            totalDamageDealt += effectiveDamage;

                            console.log(
                              `${
                                hero.clazz || "Hero"
                              } takes ${effectiveDamage} AoE damage from Life Steal!`
                            );

                            // Mostrar número de daño para cada héroe afectado
                            showHitNumber(
                              hero.posx,
                              hero.posy - 20,
                              effectiveDamage,
                              false,
                              criticalResult.isCritical
                            );

                            // Agregar efecto visual de Life Steal para cada héroe
                            addMinotaurLifeStealEffect(hero.posx, hero.posy);
                          }
                        });

                        // El Minotaur roba 5% del daño total realizado
                        const lifeSteal = Math.floor(totalDamageDealt * 0.05);
                        if (lifeSteal > 0 && !isNaN(lifeSteal)) {
                          // Validar que e.hp y e.maxhp sean números válidos
                          e.hp = isNaN(e.hp) ? e.maxhp : e.hp;
                          e.maxhp = isNaN(e.maxhp) ? 400 : e.maxhp;

                          const newHP = e.hp + lifeSteal;
                          e.hp = Math.min(e.maxhp, isNaN(newHP) ? e.hp : newHP);

                          console.log(
                            `Minotaur steals ${lifeSteal} HP from Life Steal attack!`
                          );

                          // Mostrar número de curación para el Minotaur
                          showHitNumber(
                            e.posx,
                            e.posy - 20,
                            lifeSteal,
                            true,
                            false
                          );
                        }

                        // Minotaur: gana 1 stack de Berseker (+3% velocidad de carga visible, hasta 10 stacks)
                        addDebuff(e, "berseker", 1);
                        const bersLS = e.debuffs.find(
                          (d) => d.type === "berseker"
                        );
                        console.log(
                          `Minotaur gains Berseker stack after Life Steal (total: ${
                            bersLS?.stacks || 1
                          }) -> current charge speed ${getCurrentChargeSpeed(
                            e
                          ).toFixed(2)}`
                        );
                      } else if (e.name === "Abyss King") {
                        // Ataque especial: Invocación de aliado (si hay espacio)
                        console.log("Abyss King attempts to summon an ally!");
                        // Contar aliados actuales (excluir al propio boss)
                        const currentAllies = enemies.filter(
                          (en) =>
                            en !== e && en.type !== "projectile" && en.hp > 0
                        );
                        if (currentAllies.length >= 2) {
                          console.log(
                            "Both ally slots occupied -> no summon this turn"
                          );
                        } else {
                          // Determinar slots objetivo (izq: posx < boss.posx, der: posx > boss.posx)
                          const leftOccupied = currentAllies.some(
                            (en) => en.posx < e.posx
                          );
                          const rightOccupied = currentAllies.some(
                            (en) => en.posx > e.posx
                          );
                          const availableSides = [];
                          if (!leftOccupied) availableSides.push("left");
                          if (!rightOccupied) availableSides.push("right");
                          if (availableSides.length === 0) {
                            console.log("No free side to summon");
                          } else {
                            const side =
                              availableSides[
                                Math.floor(
                                  Math.random() * availableSides.length
                                )
                              ];
                            const summonType = "voidspecter"; // Solo invoca Voidspecter
                            // Posiciones más separadas del boss (manteniendo dentro de pantalla)
                            const sx =
                              side === "left"
                                ? Math.max(60, e.posx - 110)
                                : Math.min(300, e.posx + 110);
                            const sy = 220; // Bajado para que sprite y HUD no queden tan arriba
                            // Mostrar portal antes del spawn real
                            addSummonPortalEffect(sx, sy, () => {
                              const hpMap = { voidspecter: 130, thehand: 80 };
                              const summoned = createEnemy(
                                sx,
                                sy,
                                hpMap[summonType] || 100,
                                summonType
                              );
                              // Marcar dependencia del invocador (Abyss King)
                              summoned.summoner = e;
                              summoned.dependsOnSummoner = true;
                              enemies.push(summoned);
                              showHitNumber(
                                summoned.posx,
                                summoned.posy - 40,
                                "SUMMON",
                                true,
                                false,
                                "buff",
                                summoned
                              );
                            });
                          }
                        }
                      } else if (e.name === "Gorgon") {
                        // Ataque especial: Toxic Horror (daño a todos + stack poison)
                        console.log("Gorgon uses Toxic Horror special attack!");
                        const aliveHeroes = heroes.filter((h) => h.hp > 0);

                        // Agregar efecto visual para todos los héroes vivos
                        aliveHeroes.forEach((hero) => {
                          addGorgonSpecialAbilityEffect(hero.posx, hero.posy);
                        });

                        aliveHeroes.forEach((hero) => {
                          const currentDef =
                            hero.def +
                            hero.buffs.reduce(
                              (sum, b) =>
                                b.type === "protection" || b.type === "agony"
                                  ? sum + b.defBonus
                                  : sum,
                              0
                            );

                          // Toxic Horror ajustado: daño 30-40
                          const toxicDamage =
                            30 + Math.floor(Math.random() * 11);
                          let effectiveDamage = Math.max(
                            1,
                            toxicDamage - currentDef
                          );

                          // Agony ahora solo otorga defBonus (ya incluido en currentDef)

                          hero.hp = Math.max(0, hero.hp - effectiveDamage);
                          validateHP(hero);

                          console.log(
                            `${
                              hero.clazz || "Hero"
                            } takes ${effectiveDamage} damage from Toxic Horror!`
                          );

                          // Mostrar número de daño
                          showHitNumber(
                            hero.posx,
                            hero.posy - 20,
                            effectiveDamage,
                            false,
                            false
                          );

                          // Si el héroe tiene poison, aumentar stacks y reiniciar duración
                          const poisonBuff = hero.buffs.find(
                            (b) => b.type === "poison"
                          );
                          if (poisonBuff) {
                            poisonBuff.stacks += 1;
                            poisonBuff.remainingTurns = 10;
                            // +2 daño base por stack adicional
                            poisonBuff.damagePerTick =
                              (poisonBuff.damagePerTick || 3) + 2;
                            addDebuff(hero, "poison", 1);
                            console.log(
                              `${hero.clazz} poison stack -> ${poisonBuff.stacks} daño: ${poisonBuff.damagePerTick}`
                            );
                          } else {
                            // Si no tenía poison, NO se agrega (según especificaciones)
                            console.log(
                              `${hero.clazz} had no poison, so no stack accumulated`
                            );
                          }
                        });
                      }
                    } else if (isMainAbility) {
                      if (e.name === "Noctebane") {
                        // Habilidad principal: Blood Splat (a un solo aliado aleatorio)
                        console.log(
                          "Noctebane uses Blood Splat main ability (single target)!"
                        );
                        const aliveHeroes = heroes.filter((h) => h.hp > 0);
                        if (aliveHeroes.length > 0) {
                          // Seleccionar héroe aleatorio en lugar del más cercano
                          const randomIndex = Math.floor(
                            Math.random() * aliveHeroes.length
                          );
                          const randomTarget = aliveHeroes[randomIndex];

                          // Validar HP antes del cálculo
                          if (
                            isNaN(randomTarget.hp) ||
                            randomTarget.hp === undefined ||
                            randomTarget.hp === null
                          ) {
                            randomTarget.hp = randomTarget.maxhp || 1;
                          }

                          const currentDef =
                            (randomTarget.def || 0) +
                            (randomTarget.buffs || []).reduce(
                              (sum, b) =>
                                b.type === "protection" || b.type === "agony"
                                  ? sum + (b.defBonus || 0)
                                  : sum,
                              0
                            );

                          const criticalResult = calculateCritical(damage);
                          let finalDamage = criticalResult.damage;
                          finalDamage = Math.floor(
                            finalDamage * (e.damageMultiplier || 1)
                          );
                          let effectiveDamage = Math.max(
                            1,
                            finalDamage - currentDef
                          );
                          e.damageMultiplier = (e.damageMultiplier || 1) * 1.05; // +5% tras main

                          // Agony turn-based: defensa ya sumada via defBonus

                          // Validar que el nuevo HP no sea NaN
                          const newHP = randomTarget.hp - effectiveDamage;
                          randomTarget.hp = Math.max(
                            0,
                            isNaN(newHP) ? 0 : newHP
                          );

                          // Validar HP después del ataque
                          validateHP(randomTarget);

                          console.log(
                            `${
                              randomTarget.clazz || "Hero"
                            } takes ${effectiveDamage} damage from Blood Splat!`
                          );

                          // Mostrar número de daño
                          showHitNumber(
                            randomTarget.posx,
                            randomTarget.posy - 20,
                            effectiveDamage,
                            false,
                            criticalResult.isCritical
                          );

                          // Agregar efecto visual de Blood Splat
                          addBloodSplatEffect(
                            randomTarget.posx,
                            randomTarget.posy
                          );
                        }
                      } else if (e.name === "Minotaur") {
                        // Habilidad principal: Smash (ataque devastador a un solo héroe)
                        console.log(
                          "Minotaur uses Smash main ability (single target)!"
                        );
                        const aliveHeroes = heroes.filter((h) => h.hp > 0);
                        if (aliveHeroes.length > 0) {
                          // Seleccionar héroe aleatorio
                          const randomIndex = Math.floor(
                            Math.random() * aliveHeroes.length
                          );
                          const randomTarget = aliveHeroes[randomIndex];

                          // Validar HP antes del cálculo
                          if (
                            isNaN(randomTarget.hp) ||
                            randomTarget.hp === undefined ||
                            randomTarget.hp === null
                          ) {
                            randomTarget.hp = randomTarget.maxhp || 1;
                          }

                          const currentDef =
                            (randomTarget.def || 0) +
                            (randomTarget.buffs || []).reduce(
                              (sum, b) =>
                                b.type === "protection" || b.type === "agony"
                                  ? sum + (b.defBonus || 0)
                                  : sum,
                              0
                            );

                          const criticalResult = calculateCritical(damage);
                          let finalDamage = criticalResult.damage;
                          let effectiveDamage = Math.max(
                            1,
                            finalDamage - currentDef
                          );

                          // Agony turn-based: mitigación ya incorporada en currentDef.

                          // Validar que el nuevo HP no sea NaN
                          const newHP = randomTarget.hp - effectiveDamage;
                          randomTarget.hp = Math.max(
                            0,
                            isNaN(newHP) ? 0 : newHP
                          );

                          // Validar HP después del ataque
                          validateHP(randomTarget);

                          console.log(
                            `${
                              randomTarget.clazz || "Hero"
                            } takes ${effectiveDamage} massive damage from Smash!`
                          );

                          // Mostrar número de daño
                          showHitNumber(
                            randomTarget.posx,
                            randomTarget.posy - 20,
                            effectiveDamage,
                            false,
                            criticalResult.isCritical
                          );

                          // Agregar efecto visual de Smash
                          addMinotaurSmashEffect(
                            randomTarget.posx,
                            randomTarget.posy
                          );

                          // Minotaur: gana 1 stack de Berseker (+3% velocidad de carga visible, hasta 10 stacks)
                          addDebuff(e, "berseker", 1);
                          const bersSmash = e.debuffs.find(
                            (d) => d.type === "berseker"
                          );
                          console.log(
                            `Minotaur gains Berseker stack after Smash (total: ${
                              bersSmash?.stacks || 1
                            }) -> current charge speed ${getCurrentChargeSpeed(
                              e
                            ).toFixed(2)}`
                          );
                        }
                      } else if (e.name === "Gorgon") {
                        // Gorgon: Ataque principal (más daño + veneno a héroe aleatorio)
                        console.log("Gorgon uses poison attack!");

                        const aliveHeroes = heroes.filter((h) => h.hp > 0);
                        if (aliveHeroes.length > 0) {
                          // Seleccionar héroe aleatorio
                          const randomIndex = Math.floor(
                            Math.random() * aliveHeroes.length
                          );
                          const randomTarget = aliveHeroes[randomIndex];

                          // Agregar efecto visual del ataque principal del Gorgon
                          addGorgonMainAbilityEffect(
                            randomTarget.posx,
                            randomTarget.posy
                          );

                          // Calcular defensa del objetivo
                          const currentDef =
                            (randomTarget.def || 0) +
                            (randomTarget.buffs || []).reduce(
                              (sum, b) =>
                                b.type === "protection" || b.type === "agony"
                                  ? sum + (b.defBonus || 0)
                                  : sum,
                              0
                            );

                          // Ataque principal ajustado: daño 20-30
                          const poisonAttackDamage =
                            20 + Math.floor(Math.random() * 6); // 20-25
                          const criticalResult =
                            calculateCritical(poisonAttackDamage);
                          const finalDamage = criticalResult.damage;
                          let effectiveDamage = Math.max(
                            1,
                            finalDamage - currentDef
                          );

                          // Agony turn-based: mitigación ya incorporada en currentDef.

                          // Aplicar daño
                          randomTarget.hp = Math.max(
                            0,
                            randomTarget.hp - effectiveDamage
                          );
                          validateHP(randomTarget);

                          console.log(
                            `${
                              randomTarget.clazz || "Hero"
                            } takes ${effectiveDamage} damage from Gorgon's poison attack!`
                          );

                          // Mostrar número de daño
                          showHitNumber(
                            randomTarget.posx,
                            randomTarget.posy - 20,
                            effectiveDamage,
                            false,
                            criticalResult.isCritical
                          );

                          // Aplicar veneno al objetivo atacado
                          const existingPoison = randomTarget.buffs.find(
                            (b) => b.type === "poison"
                          );
                          if (!existingPoison) {
                            randomTarget.buffs.push({
                              type: "poison",
                              remainingTurns: 10,
                              stacks: 1,
                            });
                            addDebuff(randomTarget, "poison", 1);
                            console.log(
                              `Gorgon aplica poison a ${randomTarget.clazz}`
                            );
                          } else {
                            existingPoison.stacks += 1;
                            existingPoison.remainingTurns = 10; // Reinicia duración
                            addDebuff(randomTarget, "poison", 1); // Actualiza icono (stacks)
                            console.log(
                              `Poison stack (${existingPoison.stacks}) en ${randomTarget.clazz}`
                            );
                          }
                        }
                      } else if (e.name === "Abyss King") {
                        // Habilidad principal: Abyss Strike (daño alto a un solo héroe)
                        console.log(
                          "Abyss King uses Abyss Strike main ability (single target)!"
                        );
                        const aliveHeroes = heroes.filter((h) => h.hp > 0);
                        if (aliveHeroes.length > 0) {
                          const randomIndex = Math.floor(
                            Math.random() * aliveHeroes.length
                          );
                          const randomTarget = aliveHeroes[randomIndex];
                          if (
                            isNaN(randomTarget.hp) ||
                            randomTarget.hp === undefined ||
                            randomTarget.hp === null
                          ) {
                            randomTarget.hp = randomTarget.maxhp || 1;
                          }

                          const currentDef =
                            (randomTarget.def || 0) +
                            (randomTarget.buffs || []).reduce(
                              (sum, b) =>
                                b.type === "protection" || b.type === "agony"
                                  ? sum + (b.defBonus || 0)
                                  : sum,
                              0
                            );

                          const criticalResult = calculateCritical(damage);
                          const finalDamage = criticalResult.damage;
                          let effectiveDamage = Math.max(
                            1,
                            finalDamage - currentDef
                          );

                          const newHP = randomTarget.hp - effectiveDamage;
                          randomTarget.hp = Math.max(
                            0,
                            isNaN(newHP) ? 0 : newHP
                          );
                          validateHP(randomTarget);

                          console.log(
                            `${
                              randomTarget.clazz || "Hero"
                            } takes ${effectiveDamage} damage from Abyss Strike!`
                          );

                          showHitNumber(
                            randomTarget.posx,
                            randomTarget.posy - 20,
                            effectiveDamage,
                            false,
                            criticalResult.isCritical
                          );

                          // Añadir efecto visual del Abyss Strike
                          addAbyssKingMainAbilityEffect(
                            randomTarget.posx,
                            randomTarget.posy
                          );
                        }
                      }
                    } else {
                      // Ataque normal a un solo objetivo

                      // Determinar el objetivo: aleatorio para demonios del nivel 1, más cercano para otros
                      let attackTarget;
                      if (
                        e.name === "Demon Bat" ||
                        e.name === "Fire Worm" ||
                        e.name === "Mushroom" ||
                        e.name === "Dreadwing"
                      ) {
                        // Estos enemigos atacan a un héroe aleatorio
                        const aliveHeroes = heroes.filter((h) => h.hp > 0);
                        if (aliveHeroes.length > 0) {
                          const randomIndex = Math.floor(
                            Math.random() * aliveHeroes.length
                          );
                          attackTarget = aliveHeroes[randomIndex];
                          console.log(
                            `${e.name} targets random hero: ${attackTarget.clazz}`
                          );
                        } else {
                          attackTarget = null;
                        }
                      } else {
                        // Otros enemigos atacan al más cercano
                        attackTarget = target;
                      }

                      if (attackTarget && attackTarget.hp > 0) {
                        // Validar propiedades del target antes del cálculo
                        if (
                          isNaN(attackTarget.def) ||
                          attackTarget.def === undefined ||
                          attackTarget.def === null
                        ) {
                          console.error(
                            "Target defense is NaN or invalid, setting to 3"
                          );
                          attackTarget.def = 3; // Valor por defecto
                        }
                        if (
                          isNaN(attackTarget.hp) ||
                          attackTarget.hp === undefined ||
                          attackTarget.hp === null
                        ) {
                          console.error(
                            "Target HP is NaN or invalid, setting to 100"
                          );
                          attackTarget.hp = 100; // Valor por defecto
                        }

                        let currentDef =
                          attackTarget.def +
                          attackTarget.buffs.reduce(
                            (sum, b) =>
                              b.type === "protection" || b.type === "agony"
                                ? sum + b.defBonus
                                : sum,
                            0
                          );

                        // Validar que currentDef sea un número válido
                        if (
                          isNaN(currentDef) ||
                          currentDef === undefined ||
                          currentDef === null
                        ) {
                          console.error(
                            "Current defense is NaN or invalid, setting to 0"
                          );
                          currentDef = 0;
                        }

                        // Validar que damage sea un número válido antes del cálculo crítico
                        if (
                          isNaN(damage) ||
                          damage === undefined ||
                          damage === null
                        ) {
                          console.error(
                            "Damage is NaN or invalid, resetting to default"
                          );
                          damage = e.type === "boss" ? 45 : 25; // Valor por defecto
                        }

                        // Calcular crítico para auto-ataque de enemigo
                        const criticalResult = calculateCritical(damage);
                        let finalDamage = criticalResult.damage;
                        const isCritical = criticalResult.isCritical;

                        // Validar que finalDamage sea un número válido
                        if (
                          isNaN(finalDamage) ||
                          finalDamage === undefined ||
                          finalDamage === null
                        ) {
                          console.error(
                            "Final damage is NaN or invalid, using base damage"
                          );
                          finalDamage = damage;
                        }

                        let effectiveDamage = Math.max(
                          1,
                          finalDamage - currentDef
                        );

                        // Validar que effectiveDamage sea un número válido
                        if (
                          isNaN(effectiveDamage) ||
                          effectiveDamage === undefined ||
                          effectiveDamage === null
                        ) {
                          console.error(
                            "Effective damage is NaN or invalid, setting to 1"
                          );
                          effectiveDamage = 1;
                        }

                        // Agony turn-based: mitigación ya incorporada en currentDef.

                        attackTarget.hp = Math.max(
                          0,
                          attackTarget.hp - effectiveDamage
                        );

                        // Feedback háptico cuando un héroe recibe daño
                        triggerHapticFeedback();

                        // Validar que el HP del héroe no sea NaN después del cálculo
                        validateHP(attackTarget);

                        // Validar que el HP no sea NaN después del cálculo
                        if (isNaN(attackTarget.hp)) {
                          console.error("Hero HP became NaN, resetting to 0");
                          attackTarget.hp = 0;
                        }

                        // Mostrar número de daño del enemigo auto-attack con crítico
                        showHitNumber(
                          attackTarget.posx,
                          attackTarget.posy - 20,
                          effectiveDamage,
                          false,
                          isCritical
                        );

                        // Implementar habilidades específicas de enemigos del Dark Swamp
                        if (e.name === "Mushroom") {
                          // Mushroom: Ataque básico + aplicar Poison
                          console.log("Mushroom uses poison attack!");

                          // Aplicar veneno al objetivo atacado
                          const existingPoison = attackTarget.buffs.find(
                            (b) => b.type === "poison"
                          );
                          if (!existingPoison) {
                            attackTarget.buffs.push({
                              type: "poison",
                              remainingTurns: 10,
                              stacks: 1,
                            });
                            addDebuff(attackTarget, "poison", 1);
                            console.log(
                              `Mushroom applies poison to ${attackTarget.clazz}!`
                            );
                          } else {
                            existingPoison.stacks += 1;
                            existingPoison.remainingTurns = 10;
                            addDebuff(attackTarget, "poison", 1);
                            console.log(
                              `Mushroom poison stack -> ${existingPoison.stacks}`
                            );
                          }
                        } else if (e.name === "Dreadwing") {
                          // Dreadwing: Ataque doble a dos héroes aleatorios (puede repetir)
                          console.log("Dreadwing uses double strike!");

                          const aliveHeroes = heroes.filter((h) => h.hp > 0);
                          if (aliveHeroes.length > 0) {
                            // Segundo ataque a héroe aleatorio
                            const secondTarget =
                              aliveHeroes[
                                Math.floor(Math.random() * aliveHeroes.length)
                              ];

                            const secondTargetDef =
                              secondTarget.def +
                              secondTarget.buffs.reduce(
                                (sum, b) =>
                                  b.type === "protection" || b.type === "agony"
                                    ? sum + b.defBonus
                                    : sum,
                                0
                              );

                            const secondCriticalResult =
                              calculateCritical(damage);
                            // Reducir daño del segundo golpe igual que el primero (ya que damage ajustado se basó en el primero)
                            let secondBase = 20 + Math.floor(Math.random() * 6); // 20-25 segundo golpe (sin cambios)
                            const secondCriticalResult2 =
                              calculateCritical(secondBase);
                            let secondEffectiveDamage = Math.max(
                              1,
                              secondCriticalResult2.damage - secondTargetDef
                            );

                            // Agony turn-based: mitigación ya incorporada en DEF.

                            secondTarget.hp = Math.max(
                              0,
                              secondTarget.hp - secondEffectiveDamage
                            );

                            showHitNumber(
                              secondTarget.posx,
                              secondTarget.posy - 20,
                              secondEffectiveDamage,
                              false,
                              secondCriticalResult2.isCritical
                            );

                            console.log(
                              `Dreadwing's second strike hits ${secondTarget.clazz} for ${secondEffectiveDamage} damage!`
                            );

                            checkGameOver();
                          }
                        } else if (e.name === "Fire Worm") {
                          // Fire Worm: Ataque intermedio básico (ya aplicado en damage base)
                          console.log(
                            "Fire Worm uses basic intermediate attack!"
                          );
                          // No hay lógica adicional, solo el ataque básico intermedio
                        } else if (e.name === "Minotaur") {
                          applyChargeSpeedBonus(e, 1.05); // solo velocidad
                          console.log(`Minotaur charge speed buff (basic).`);
                        }

                        // Lógica de veneno para enemigos del Dark Swamp (Mushroom y Gorgon)
                        if (e.name === "Gorgon") {
                          const aliveHeroes = heroes.filter((h) => h.hp > 0);
                          if (aliveHeroes.length > 0) {
                            const randomIndex = Math.floor(
                              Math.random() * aliveHeroes.length
                            );
                            const poisonTarget = aliveHeroes[randomIndex];
                            const existingPoison = poisonTarget.buffs.find(
                              (b) => b.type === "poison"
                            );
                            if (!existingPoison) {
                              poisonTarget.buffs.push({
                                type: "poison",
                                remainingTurns: 10,
                                stacks: 1,
                              });
                              addDebuff(poisonTarget, "poison", 1);
                              console.log(
                                `${e.name} applies poison to ${poisonTarget.clazz}!`
                              );
                            } else {
                              existingPoison.stacks += 1;
                              existingPoison.remainingTurns = 10;
                              addDebuff(poisonTarget, "poison", 1);
                              console.log(
                                `${e.name} poison stack -> ${existingPoison.stacks} on ${poisonTarget.clazz}`
                              );
                            }
                          }
                        } else if (e.name === "Voidspecter") {
                          // Voidspecter: daño alto a 2 héroes aleatorios distintos (o 1 si solo queda uno)
                          console.log("Voidspecter uses dual void blast!");
                          const aliveHeroes = heroes.filter((h) => h.hp > 0);
                          const targets = [];
                          if (aliveHeroes.length > 0) {
                            const firstIndex = Math.floor(
                              Math.random() * aliveHeroes.length
                            );
                            targets.push(aliveHeroes[firstIndex]);
                            if (aliveHeroes.length > 1) {
                              let second;
                              do {
                                second =
                                  aliveHeroes[
                                    Math.floor(
                                      Math.random() * aliveHeroes.length
                                    )
                                  ];
                              } while (
                                second === targets[0] &&
                                aliveHeroes.length > 1
                              );
                              targets.push(second);
                            }
                          }
                          targets.forEach((tgt) => {
                            if (!tgt || tgt.hp <= 0) return;
                            const currentDef =
                              tgt.def +
                              tgt.buffs.reduce(
                                (sum, b) =>
                                  b.type === "protection" || b.type === "agony"
                                    ? sum + b.defBonus
                                    : sum,
                                0
                              );
                            // Daño ajustado: reducción adicional (antes 25-35, ahora 20-30)
                            let vdmg = 20 + Math.floor(Math.random() * 11); // 20-30
                            const crit = calculateCritical(vdmg);
                            vdmg = crit.damage;
                            let eff = Math.max(1, vdmg - currentDef);
                            // Aplicar daño unificado
                            DAMAGE.apply(tgt, eff, {
                              min: 0,
                              show: true,
                              crit: crit.isCritical,
                              type: "damage",
                            });
                            validateHP(tgt);

                            // Añadir efecto visual de Dark Bolt del Voidspecter
                            addVoidspecterDarkBoltEffect(tgt.posx, tgt.posy);
                          });
                        } else if (e.name === "The Hand") {
                          // The Hand: aplica Dark Protection a UN aliado aleatorio que no sea él mismo
                          const candidates = enemies.filter(
                            (en) => en !== e && en.hp > 0
                          );
                          if (candidates.length > 0) {
                            const targetBuff =
                              candidates[
                                Math.floor(Math.random() * candidates.length)
                              ];
                            targetBuff.darkProtectionStacks =
                              (targetBuff.darkProtectionStacks || 0) + 1;
                            // Recalcular defensa: baseDef * (1 + 0.05 * stacks)
                            if (targetBuff.baseDef !== undefined) {
                              const stacks = targetBuff.darkProtectionStacks;
                              // 20% primer stack +5% cada adicional => 1.2 + 0.05*(stacks-1)
                              targetBuff.def = Math.round(
                                targetBuff.baseDef * (1.2 + 0.05 * (stacks - 1))
                              );
                            }
                            // Actualizar/añadir debuff para mostrar icono y stacks
                            if (!targetBuff.debuffs) targetBuff.debuffs = [];
                            const dpDebuff = targetBuff.debuffs.find(
                              (d) => d.type === "dark_protection"
                            );
                            if (dpDebuff) {
                              dpDebuff.stacks = targetBuff.darkProtectionStacks;
                              dpDebuff.icon = getDebuffIcon("dark_protection");
                            } else {
                              targetBuff.debuffs.push({
                                type: "dark_protection",
                                stacks: targetBuff.darkProtectionStacks,
                                icon: getDebuffIcon("dark_protection"),
                              });
                            }
                            // Mostrar número flotante tipo buff
                            showHitNumber(
                              targetBuff.posx,
                              targetBuff.posy - 40,
                              `DP+${targetBuff.darkProtectionStacks}`,
                              true,
                              false,
                              "buff",
                              targetBuff
                            );

                            // Añadir efecto visual de Dark Protection
                            addTheHandDarkProtectionEffect(
                              targetBuff.posx,
                              targetBuff.posy
                            );
                          }
                        } else if (e.name === "Abyss King") {
                          // Abyss King ya procesó si es especial arriba (isSpecialAttack). Aquí solo main ability (daño alto single random)
                          console.log("Abyss King strikes a random hero");
                          const aliveHeroes = heroes.filter((h) => h.hp > 0);
                          if (aliveHeroes.length > 0) {
                            const r =
                              aliveHeroes[
                                Math.floor(Math.random() * aliveHeroes.length)
                              ];
                            const currentDef =
                              r.def +
                              r.buffs.reduce(
                                (sum, b) =>
                                  b.type === "protection" || b.type === "agony"
                                    ? sum + b.defBonus
                                    : sum,
                                0
                              );
                            let abdmg = 45 + Math.floor(Math.random() * 16); // 45-60
                            const crit = calculateCritical(abdmg);
                            abdmg = crit.damage;
                            let eff = Math.max(1, abdmg - currentDef);
                            DAMAGE.apply(r, eff, {
                              min: 0,
                              show: true,
                              crit: crit.isCritical,
                              type: "damage",
                            });
                            validateHP(r);
                          }
                        }

                        checkGameOver();
                      }
                    }
                  }, 100);
                } else {
                  // No hay target válido - el enemigo debe consumir su turno y resetear su estado
                  console.warn(
                    `Enemy ${e.name} has no valid target, skipping turn`
                  );
                  e.charge = 0; // Reset charge para evitar loop infinito
                  e.chargeFullTime = null; // Limpiar timestamp
                  e.animTime = 0; // Reset animation time
                  e.anim = "idle"; // Volver a idle
                  e.frame = 0;

                  // Consumir turno inmediatamente
                  if (turnQueue[0] === e) {
                    turnQueue.shift();
                    console.log(`${e.name} turn consumed (no target)`);
                  }

                  // Limpiar estados especiales si existen
                  if (e.type === "boss" && e.attacksUntilSpecial !== null) {
                    // Decrementar contador de ataques especiales aunque no ataque
                    e.attacksUntilSpecial--;
                    if (e.attacksUntilSpecial <= 0) {
                      e.attacksUntilSpecial = e.specialAttackCounter || 3;
                    }
                  }
                }
              } else {
                // Debug para Minotaur bloqueado - explicar por qué no puede atacar
                if (
                  e.name === "Minotaur" &&
                  turnQueue.length > 0 &&
                  turnQueue[0] === e
                ) {
                  console.warn(`Minotaur blocked from attacking. Conditions:
                    - In queue front: ${turnQueue[0] === e}
                    - Charge: ${e.charge}/100
                    - AnimTime: ${e.animTime}
                    - ActiveAction: ${
                      activeAction?.name || activeAction?.clazz || "none"
                    }
                    - ActionDelayTimer: ${actionDelayTimer}
                    - Heroes with action: ${
                      heroes
                        .filter((h) => h.hp > 0 && h.action)
                        .map((h) => `${h.clazz}:${h.action}`)
                        .join(", ") || "none"
                    }`);
                }
              }
            }

            // Actualizar animaciones de enemigos - usando sprites dinámicos del nivel
            if (e.anim === "hurt") {
              const elapsed = currentTime - e.animStartTime;
              if (elapsed >= 0.3) {
                // Duración del efecto de daño
                e.anim = "idle";
                e.frame = 0; // Reiniciar frame
                e.animStartTime = currentTime;
              }
            } else if (e.anim === "attack") {
              const elapsed = currentTime - e.animStartTime;
              const frameDuration = 0.08; // Duración por frame para ataque (más fluido: 0.1 -> 0.08)
              e.frame = Math.floor(elapsed / frameDuration);

              // Determinar frames de ataque según el tipo
              let attackFrames = e.attackFrames || 4;
              if (e.name === "Gorgon" && e.isSpecialAttack) {
                attackFrames = e.specialAttackFrames || 16; // Usar frames de ataque especial
              }

              if (e.frame >= attackFrames) {
                e.anim = "idle"; // Volver a idle después del ataque
                e.frame = 0;
                e.animStartTime = currentTime;
                e.isSpecialAttack = false; // Limpiar flag de ataque especial
              }
            } else if (e.anim === "explode") {
              // Animación especial de explosión para Crab Bomb
              const elapsed = currentTime - e.animStartTime;
              const frameDuration = 0.08; // Duración por frame para explosión (más lenta para ser visible)
              e.frame = Math.floor(elapsed / frameDuration);

              const explodeFrames = e.explodeFrames || 23; // 23 frames de explosión
              if (e.frame >= explodeFrames) {
                // La animación de explosión ha terminado, aplicar daño ahora
                if (e.explosionDamagePending) {
                  const explosionDamage = 65 + Math.floor(Math.random() * 11); // 65-75 daño

                  console.log(
                    "Applying explosion damage as animation completes"
                  );

                  heroes.forEach((hero) => {
                    if (hero.hp > 0) {
                      const currentDef =
                        hero.def +
                        hero.buffs.reduce(
                          (sum, b) =>
                            b.type === "protection" || b.type === "agony"
                              ? sum + b.defBonus
                              : sum,
                          0
                        );

                      let effectiveDamage = Math.max(
                        1,
                        explosionDamage - currentDef
                      );

                      // Agony turn-based: mitigación ya incorporada en DEF.

                      hero.hp = Math.max(0, hero.hp - effectiveDamage);
                      validateHP(hero);

                      showHitNumber(
                        hero.posx,
                        hero.posy - 20,
                        effectiveDamage,
                        false,
                        false
                      );
                      console.log(
                        `${hero.clazz} takes ${effectiveDamage} explosion damage!`
                      );
                    }
                  });

                  // Marcar que el daño ya se aplicó
                  e.explosionDamagePending = false;

                  checkGameOver();
                }

                // Terminar explosión y cambiar a muerte
                e.anim = "die";
                e.frame = 0;
                e.animStartTime = currentTime;
                e.hp = 0;
                e.isDying = true;
                console.log(
                  "Explosion animation completed, switching to death"
                );
              }
            } else if (e.anim === "idle" && e.hp > 0) {
              const elapsed = currentTime - e.animStartTime;
              let frameDuration = 0.18; // Duración base
              if (e.name === "Abyss King") {
                frameDuration = 0.16; // Más rápido para nuevo sprite (antes 0.32)
              }
              const idleFrames = e.idleFrames || 4; // Usar frames dinámicos o fallback
              e.frame = Math.floor(elapsed / frameDuration) % idleFrames;
            }

            if (e.animTime > 0) e.animTime -= delta;
          });

          // Update hero charge over time
          heroes.forEach((h) => {
            if (h.hp > 0) {
              // Use the new charge speed rating system
              const chargeSpeed = getChargeSpeedFromRating(
                h.chargeSpeedRating || 5
              );
              h.charge = Math.min(h.maxcharge, h.charge + delta * chargeSpeed);
              if (h.charge >= 100 && !turnQueue.includes(h)) {
                turnQueue.push(h);
              }
            }
          });

          // Verificar si el héroe seleccionado ha muerto durante la selección de objetivo
          checkAndCancelDeadHeroAction();

          // Progresar aparición suave de nuevos enemigos
          enemies.forEach((e) => {
            if (e.spawnFadeProgress !== undefined && e.spawnFadeProgress < 1) {
              e.spawnFadeProgress = Math.min(
                1,
                e.spawnFadeProgress + delta * 2
              ); // 0.5s aprox
            }
            // Si depende de un invocador y este ha muerto, forzar muerte
            if (
              e.dependsOnSummoner &&
              e.hp > 0 &&
              (!e.summoner || e.summoner.hp <= 0)
            ) {
              e.hp = 0;
              e.isDying = true;
              e.anim = "die";
              e.frame = 0;
              e.animStartTime = currentTime;
            }
          });
          // Liberar acción activa cuando termina animación y no hay delay
          if (
            activeAction &&
            activeAction.anim !== "attack" &&
            actionDelayTimer === 0
          ) {
            activeAction = null;
          }
        } // Fin del bloque condicional del juego

        // Monitoreo continuo del score
        monitorScore();

        // Verificar timeout de turnos para evitar freezes
        checkTurnTimeout();

        draw();
        requestAnimationFrame(loop);
      }

      function draw() {
        ctx.clearRect(0, 0, designWidth, designHeight);

        // Configurar interpolación de alta calidad para todos los sprites
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";

        // Si estamos en el menú principal, renderizar la pantalla de inicio
        if (state === "main_menu") {
          drawMainMenu();
          return;
        }

        // Si estamos en la pantalla de información de nivel
        if (state === "level_info") {
          drawLevelInfo();
          return;
        }

        // Si estamos en la pantalla del libro de monstruos
        if (state === "book") {
          drawMonsterBook();
          return;
        }

        // Si estamos en la pantalla de guía
        if (state === "guide") {
          drawGuide();
          return;
        }

        // Eliminado: pantalla de finalización gestionada externamente (SDK)
        if (state === "level_completion") {
          // Dibujar modal de fin de nivel
          const modalW = 300;
          const modalH = 200;
          const modalX = (designWidth - modalW) / 2;
          const modalY = (designHeight - modalH) / 2 - 40;
          ctx.fillStyle = "rgba(0,0,0,0.75)"; // Fondo más oscuro detrás del modal
          ctx.fillRect(0, 0, designWidth, designHeight);
          ctx.fillStyle = "#000000"; // Fondo negro solicitado
          ctx.strokeStyle = "#D3BF8F";
          ctx.lineWidth = 3;
          ctx.fillRect(modalX, modalY, modalW, modalH);
          ctx.strokeRect(modalX, modalY, modalW, modalH);

          ctx.fillStyle = "#FFFFFF"; // Título en blanco
          ctx.font = "bold 26px 'Jersey 10'";
          const title = `Level ${levelCompletionModal.level} Cleared!`;
          ctx.textAlign = "center";
          ctx.fillText(title, designWidth / 2, modalY + 48);
          // (Boss line removed per request)
          ctx.font = "16px 'Jacquard 24'"; // Base for measuring if needed
          ctx.fillStyle = "#FFFFFF";

          // Mini lore adicional tras derrotar boss niveles 1, 2 y 3
          let continuationLore = "";
          if (levelCompletionModal.level === 1) {
            continuationLore =
              "Noctebane's ember dimmed, but deeper heat pulses below. The dunes whisper its heart still feeds...";
          } else if (levelCompletionModal.level === 2) {
            continuationLore =
              "The Minotaur falls, runes crack. Swamp vapors rise — the Gorgon's gaze now guards the final seal.";
          } else if (levelCompletionModal.level === 3) {
            continuationLore =
              "With the Gorgon fallen, the final seal fractures. Beyond the swamp's rotting mist, the Soul Rift yawns open — a wound in reality where the Abyss King gathers the void itself.";
          }
          if (continuationLore) {
            ctx.font = "15px 'Jacquard 24'"; // Más grande
            ctx.fillStyle = "#FFFFFF";
            const wrapLore = (txt, maxW) => {
              const words = txt.split(/\s+/);
              const lines = [];
              let line = "";
              words.forEach((w) => {
                const test = line ? line + " " + w : w;
                if (ctx.measureText(test).width > maxW) {
                  if (line) lines.push(line);
                  line = w;
                } else {
                  line = test;
                }
              });
              if (line) lines.push(line);
              return lines;
            };
            const loreLines = wrapLore(continuationLore, 260);
            loreLines.slice(0, 3).forEach((ln, i) => {
              ctx.fillText(ln, designWidth / 2, modalY + 90 + i * 20); // subir el lore un poco y mayor interlineado
            });
          }

          // Botones
          const btnW = 120;
          const btnH = 36;
          const btnY = modalY + modalH - 50; // Botones más abajo para mayor separación con el lore
          const continueX = designWidth / 2 - btnW - 10;
          const surrenderX = designWidth / 2 + 10;

          // Continuar
          ctx.drawImage(buttonLongBeigeImg, continueX, btnY, btnW, btnH);
          ctx.fillStyle = "#3D2914";
          ctx.font = "bold 18px 'Jersey 10'";
          ctx.fillText("Continue", continueX + btnW / 2, btnY + 24);
          // Surrender
          ctx.drawImage(buttonLongBrownImg, surrenderX, btnY, btnW, btnH);
          ctx.fillStyle = "#3D2914"; // Mismo color que Continue
          ctx.fillText("Surrender", surrenderX + btnW / 2, btnY + 24);
          return;
        }

        // Draw background
        ctx.drawImage(currentBackgroundImg, 0, 0, designWidth, designHeight);

        // IMPORTANTE: Limitar el área de renderizado del juego para que no interfiera con header/footer
        ctx.save();
        ctx.beginPath();
        ctx.rect(0, GAME_AREA_Y, designWidth, GAME_AREA_HEIGHT);
        ctx.clip();

        heroes.forEach((h) => {
          const animData = h.animations[h.anim];
          // El frameOffset ya no es necesario para conflagration ya que usa su propia fila
          let frameOffset = 0;
          const sx = (h.frame + frameOffset) * h.frameW;
          const sy = animData.row * h.frameH;
          const size = h.size || 80;

          // Aplicar efecto de sombra/transparencia si está muerto
          if (h.hp <= 0) {
            ctx.save();
            ctx.globalAlpha = 0.6; // Menos transparente (era 0.4)
            ctx.filter = "brightness(0.3) contrast(0.8)"; // Más oscuro
          }

          ctx.drawImage(
            h.img,
            sx,
            sy,
            h.frameW,
            h.frameH,
            h.posx - size / 2,
            h.posy - size / 2,
            size,
            size
          );

          if (h.hp <= 0) {
            ctx.restore(); // Restaurar efectos
          }

          // Barras unificadas: altura 12px para ambas con esquinas redondeadas
          const barX = h.posx - 40;
          const hpBarY = h.posy + 55;
          const barW = 80;
          const barH = 12; // misma altura para HP y energía
          const hpRatio = Math.max(0, Math.min(1, h.hp / h.maxhp));
          drawRoundedBar(ctx, barX, hpBarY, barW, barH, hpRatio, {
            bgColor: "rgba(0,0,0,0.55)",
            fillColor: "#C62828", // rojo más profundo
            borderColor: "#3B2A1A",
            radius: 5,
            lineWidth: 1.2,
          });

          // Texto de HP centrado perfectamente en la barra
          ctx.fillStyle = "white";
          ctx.font = "bold 15px 'Jersey 10'"; // Más grande
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          if (h.hp <= 0) {
            // Dibujar calavera centrada dentro de la barra de HP
            const skullSize = 10; // Dentro de la barra (12px alto)
            if (skullDeadImg.complete) {
              ctx.drawImage(
                skullDeadImg,
                h.posx - skullSize / 2,
                h.posy + 55 + 6 - skullSize / 2,
                skullSize,
                skullSize
              );
            } else {
              ctx.fillText("X", h.posx, h.posy + 55 + 6);
            }
          } else {
            ctx.fillText(`${h.hp}`, h.posx, h.posy + 55 + 6); // Centrado en Y
          }
          ctx.textAlign = "left"; // Resetear alineación
          ctx.textBaseline = "alphabetic"; // Resetear baseline

          // Barra de energía (charge) - misma altura y estilo
          if (h.hp > 0) {
            const chargeBarY = h.posy + 55 + barH + 2; // pequeño espacio de 2px entre barras
            const chargeRatio = Math.max(0, Math.min(1, h.charge / 100));
            drawRoundedBar(ctx, barX, chargeBarY, barW, barH, chargeRatio, {
              bgColor: "rgba(0,0,0,0.55)",
              fillColor: "#FFC300",
              borderColor: "#3B2A1A",
              radius: 5,
              lineWidth: 1.2,
            });

            // Número de orden de turno (solo si está en la cola)
            const heroOrderIndex = turnQueue.indexOf(h);
            if (heroOrderIndex !== -1) {
              ctx.save();
              const orderText = (heroOrderIndex + 1).toString();
              ctx.font = "bold 15px 'Jersey 10'"; // Más grande
              ctx.textAlign = "right";
              ctx.textBaseline = "middle";
              ctx.strokeStyle = "#000";
              ctx.lineWidth = 3;
              ctx.fillStyle = heroOrderIndex === 0 ? "#FFD700" : "#FFFFFF";
              const tx = h.posx - 46; // ligera separación extra
              const ty = h.posy + 55 + barH + 2 + barH / 2; // centro de la barra de energía
              ctx.strokeText(orderText, tx, ty);
              ctx.fillText(orderText, tx, ty);
              ctx.restore();
            }
          }

          // (Borde ya dibujado por drawRoundedBar para HP)

          // Renderizar debuffs debajo de la barra de energía
          if (h.hp > 0) {
            // Solo si está vivo
            renderDebuffs(h, h.posx, h.posy + 55 + barH + 2 + barH + 2); // ajustar posición bajo segunda barra
          }
        });

        enemies.forEach((e, enemyIndex) => {
          if (e.hp <= 0 && e.deathAnimComplete) return; // No dibujar si completó animación de muerte

          const size = e.size || 80;

          // Usar los sprites específicos del enemigo según el nivel
          ctx.save();

          // Activar interpolación suave para mejor calidad
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = "high";

          // Seleccionar sprite y calcular posición según animación
          if (e.spawnFadeProgress !== undefined && e.spawnFadeProgress < 1) {
            ctx.globalAlpha *= Math.max(0.05, e.spawnFadeProgress); // proteger de alpha 0 absoluto
          }
          let spriteImg, sx, sy;

          // Verificar si es Minotaur (usa sprite sheet completo)
          if (e.name === "Minotaur") {
            spriteImg = minotaurAllStatesImg;

            if (e.anim === "die") {
              // Fila 1 (attack) como "death" visual: 16 frames
              sx = e.frame * e.frameWidth;
              sy = 1 * e.frameHeight;
              // Efecto de desvanecimiento gradual al morir
              const deathProgress = e.frame / ((e.deathFrames || 16) - 1);
              ctx.globalAlpha = 1 - deathProgress * 0.7;
              ctx.filter = "grayscale(50%) brightness(0.5)";
            } else if (e.anim === "hurt") {
              // Para hurt, usar idle (fila 0) pero con efectos visuales
              sx = e.frame * e.frameWidth;
              sy = 0 * e.frameHeight;
              ctx.filter = "hue-rotate(0deg) contrast(1.5) brightness(1.2)";
              ctx.globalAlpha = 0.8 + 0.2 * Math.sin(currentTime * 20);
            } else if (e.anim === "attack") {
              // Fila 1 (attack): 16 frames
              sx = e.frame * e.frameWidth;
              sy = 1 * e.frameHeight;
            } else {
              // Fila 0 (idle): 16 frames
              sx = e.frame * e.frameWidth;
              sy = 0 * e.frameHeight;
            }
          } else if (e.name === "Abyss King") {
            // Sprite sheet 2 filas: fila0 idle (9), fila1 attack (8)
            // Abyss King siempre usa IDLE, nunca la fila de attack
            spriteImg = e.sprites ? e.sprites.idle : goblinIdleImg;

            // Efecto de parpadeo durante ataques
            if (e.flickerEffect && e.flickerEffect.active) {
              const elapsed = currentTime - e.flickerEffect.startTime;
              if (elapsed < e.flickerEffect.duration) {
                // Crear efecto de parpadeo oscilante
                const flickerIntensity = Math.sin(elapsed * 15) * 0.5 + 0.5;
                ctx.globalAlpha *= 0.3 + flickerIntensity * 0.7;
                ctx.filter = "brightness(1.5) contrast(1.3) saturate(1.2)";
              } else {
                // Terminar efecto de parpadeo
                e.flickerEffect.active = false;
              }
            }

            if (e.anim === "die") {
              sx = (e.frame % (e.idleFrames || 9)) * e.frameWidth;
              sy = 0;
              const deathProgress = Math.min(
                1,
                (currentTime - e.animStartTime) / 1.0
              );
              ctx.globalAlpha = 1 - deathProgress;
              ctx.filter = "grayscale(60%) brightness(0.6) blur(1px)";
            } else if (e.anim === "hurt") {
              sx = (e.frame % (e.idleFrames || 9)) * e.frameWidth;
              sy = 0;
              ctx.filter = "contrast(1.3) brightness(1.05)";
              ctx.globalAlpha = 0.9;
            } else {
              // Siempre usar IDLE (fila 0) - sin estado de ataque
              sx = (e.frame % (e.idleFrames || 9)) * e.frameWidth;
              sy = 0;
            }
          } else if (e.name === "Gorgon") {
            // Usar diferentes sprites según la animación
            if (e.anim === "die") {
              spriteImg = swampGorgonDeathImg;
              sx = e.frame * e.frameWidth;
              sy = 0; // Solo una fila en el sprite de muerte
              // Efecto de desvanecimiento gradual al morir
              const deathProgress = e.frame / ((e.deathFrames || 3) - 1);
              ctx.globalAlpha = 1 - deathProgress * 0.7;
              ctx.filter = "grayscale(50%) brightness(0.5)";
            } else if (e.anim === "hurt") {
              spriteImg = swampGorgonIdleImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
              ctx.filter = "hue-rotate(0deg) contrast(1.5) brightness(1.2)";
              ctx.globalAlpha = 0.8 + 0.2 * Math.sin(currentTime * 20);
            } else if (e.anim === "attack") {
              // Verificar si es ataque especial
              if (e.isSpecialAttack) {
                spriteImg = swampGorgonSpecialAttackImg;
              } else {
                spriteImg = swampGorgonAttackImg;
              }
              sx = e.frame * e.frameWidth;
              sy = 0; // Solo una fila en cada sprite de ataque
            } else {
              // Idle animation
              spriteImg = swampGorgonIdleImg;
              sx = e.frame * e.frameWidth;
              sy = 0; // Solo una fila en el sprite idle
            }

            // Mejorar calidad de renderizado para Gorgon
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = "high";
          } else if (e.name === "Crab Bomb") {
            // Usar diferentes sprites según la animación para Crab Bomb
            if (e.anim === "die") {
              spriteImg = crabBombDeathImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
              // Efecto de desvanecimiento gradual al morir
              const deathProgress = e.frame / ((e.deathFrames || 6) - 1);
              ctx.globalAlpha = 1 - deathProgress * 0.7;
              ctx.filter = "grayscale(50%) brightness(0.5)";
            } else if (e.anim === "explode") {
              spriteImg = crabBombExplodeImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
              // Efecto muy brillante y llamativo para la explosión
              ctx.filter = "brightness(1.8) contrast(1.5) saturate(1.3)";
              ctx.globalAlpha = 1.0; // Asegurar que sea completamente visible

              // Agregar un resplandor adicional
              ctx.shadowColor = "orange";
              ctx.shadowBlur = 15;
              ctx.shadowOffsetX = 0;
              ctx.shadowOffsetY = 0;
            } else if (e.anim === "hurt") {
              spriteImg = crabBombIdleImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
              ctx.filter = "hue-rotate(0deg) contrast(1.5) brightness(1.2)";
              ctx.globalAlpha = 0.8 + 0.2 * Math.sin(currentTime * 20);
            } else {
              // idle
              spriteImg = crabBombIdleImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
            }
          } else {
            // Lógica original para otros enemigos (Demon Bat, Worm)
            if (e.anim === "die") {
              if (e.sprites && e.sprites.death) {
                spriteImg = e.sprites.death;
                sx = e.frame * e.frameWidth;
                sy = 0;
                const deathProgress = e.frame / ((e.deathFrames || 6) - 1);
                ctx.globalAlpha = 1 - deathProgress * 0.7;
                ctx.filter = "grayscale(50%) brightness(0.5)";
              } else {
                // Muerte simulada (fade out y escala) para The Hand / Abyss King
                spriteImg = e.sprites ? e.sprites.idle : goblinIdleImg;
                sx = (e.frame % (e.idleFrames || 1)) * e.frameWidth;
                sy = 0;
                const deathProgress = Math.min(
                  1,
                  (currentTime - e.animStartTime) / 1.0
                );
                ctx.globalAlpha = 1 - deathProgress;
                ctx.filter = "grayscale(60%) brightness(0.6) blur(1px)";
              }
            } else if (e.anim === "hurt") {
              spriteImg = e.sprites ? e.sprites.idle : goblinIdleImg;
              sx = (e.frame % (e.idleFrames || 1)) * e.frameWidth;
              sy = 0;
              ctx.filter = "hue-rotate(0deg) contrast(1.5) brightness(1.2)";
              ctx.globalAlpha = 0.8 + 0.2 * Math.sin(currentTime * 20);
            } else if (e.anim === "attack") {
              // Si no hay sprite de ataque, usar idle y simular movimiento
              spriteImg =
                e.sprites && e.sprites.attack
                  ? e.sprites.attack
                  : e.sprites
                  ? e.sprites.idle
                  : goblinIdleImg;
              sx =
                (e.frame % (e.attackFrames || e.idleFrames || 1)) *
                e.frameWidth;
              sy = 0;
              if (!e.sprites || !e.sprites.attack) {
                // Simular pequeño desplazamiento/zoom
                ctx.translate(0, Math.sin(currentTime * 40) * 4);
                ctx.scale(
                  1 + 0.05 * Math.sin(currentTime * 30),
                  1 + 0.05 * Math.sin(currentTime * 30)
                );
              }
            } else {
              spriteImg = e.sprites ? e.sprites.idle : goblinIdleImg;
              sx = (e.frame % (e.idleFrames || 1)) * e.frameWidth;
              sy = 0;
            }
          }

          // Dibujar el sprite del enemigo
          // Para Demon Slime, mantener las proporciones originales del sprite
          let drawWidth = size;
          let drawHeight = size;

          if (e.name === "Minotaur") {
            // Mantener proporciones originales del sprite (288x160)
            const aspectRatio = e.frameWidth / e.frameHeight; // 288/160 = 1.8
            drawWidth = size;
            drawHeight = size / aspectRatio; // Ajustar altura para mantener proporción
          } else if (e.name === "Gorgon") {
            // Mantener proporciones originales del sprite (128x128)
            const aspectRatio = e.frameWidth / e.frameHeight; // 128/128 = 1.0
            drawWidth = size;
            drawHeight = size / aspectRatio; // Ajustar altura para mantener proporción (es cuadrado)
          }

          // Offset extra para enemigo central cuando hay exactamente 3
          let posYOffset = 0;
          if (enemies.length === 3 && enemyIndex === 1) {
            posYOffset = 18; // bajar sprite & HUD
          }
          if (
            spriteImg &&
            (spriteImg instanceof Image ? spriteImg.complete : true)
          ) {
            try {
              // Permitir altura distinta en ataque (p.ej. The Hand 62x80 vs idle 62x64)
              const srcFrameHeight =
                e.anim === "attack" && e.attackFrameHeight
                  ? e.attackFrameHeight
                  : e.frameHeight;
              ctx.drawImage(
                spriteImg,
                sx,
                sy,
                e.frameWidth,
                srcFrameHeight,
                e.posx - drawWidth / 2,
                e.posy + posYOffset - drawHeight / 2,
                drawWidth,
                drawHeight
              );
            } catch (err) {
              console.warn("drawImage failed for", e.name, err);
            }
          } else {
            // Fallback visual simple mientras se carga o falta sprite
            ctx.save();
            ctx.fillStyle = "rgba(120,80,160,0.55)";
            ctx.beginPath();
            ctx.arc(
              e.posx,
              e.posy + posYOffset - drawHeight / 2 + drawHeight / 2,
              drawWidth / 2,
              0,
              Math.PI * 2
            );
            ctx.fill();
            ctx.restore();
          }

          // Reset de efectos visuales para no afectar otros elementos
          ctx.filter = "none";
          ctx.shadowColor = "transparent";
          ctx.shadowBlur = 0;
          ctx.globalAlpha = 1.0;

          ctx.restore();

          // Solo mostrar HUD si no está muerto o aún no completó la animación
          if (e.hp > 0 || !e.deathAnimComplete) {
            // Calcular offset vertical para la barra de HP según el tipo de enemigo
            let hpBarOffset = size / 2 + 25 + posYOffset;
            if (e.name === "Minotaur") {
              // Usar la altura real del sprite renderizado
              const aspectRatio = e.frameWidth / e.frameHeight;
              const actualHeight = size / aspectRatio;
              hpBarOffset = actualHeight / 2 + 25 + posYOffset;
            } else if (e.name === "Gorgon") {
              // Para Gorgon, reducir distancia del HUD
              hpBarOffset = size / 2 + 15 + posYOffset; // Reducido de +25 a +15 para estar más cerca
            } else if (e.name === "The Hand") {
              // Separar un poco más (ligero) porque quedaba muy pegado
              hpBarOffset += 4; // pequeño ajuste
            }

            // Título del enemigo - encima de la barra de HP, pegado a la izquierda
            ctx.fillStyle = "#FFFFFF"; // Blanco
            ctx.strokeStyle = "#2A1F0F"; // Borde marrón oscuro
            ctx.lineWidth = 2;
            ctx.font = "bold 20px 'Jacquard 24'"; // Fuente lore para nombre enemigo
            ctx.textAlign = "left";
            ctx.textBaseline = "alphabetic";

            const titleX = e.posx - 40; // Pegado a la izquierda del HUD
            const titleY = e.posy + posYOffset - hpBarOffset - 8; // Encima de la barra de HP

            // Dibujar borde del título
            ctx.strokeText(e.name, titleX, titleY);
            // Dibujar texto del título
            ctx.fillText(e.name, titleX, titleY);

            // Restaurar alpha previo al HUD (el HUD debe ser siempre 100% visible)
            if (e.spawnFadeProgress !== undefined && e.spawnFadeProgress < 1) {
              ctx.globalAlpha = 1;
            }

            // Barras unificadas con mismo alto y estilo
            const eBarX = e.posx - 40;
            const eBarY = e.posy + posYOffset - hpBarOffset;
            const eBarW = 80;
            const eBarH = 12; // misma altura
            const validHP = isNaN(e.hp) ? 0 : e.hp;
            const validMaxHP = isNaN(e.maxhp) ? 1 : e.maxhp;
            const eHpRatio = validHP / validMaxHP;
            drawRoundedBar(ctx, eBarX, eBarY, eBarW, eBarH, eHpRatio, {
              bgColor: "rgba(0,0,0,0.55)",
              fillColor: "#C62828",
              borderColor: "#3B2A1A",
              radius: 5,
              lineWidth: 1.2,
            });

            // Texto de HP centrado perfectamente en la barra
            ctx.fillStyle = "white";
            ctx.font = "15px 'Jersey 10'"; // Más grande
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            // Mostrar HP válido, si es NaN mostrar 0
            ctx.fillText(
              `${isNaN(e.hp) ? 0 : Math.floor(e.hp)}`,
              e.posx,
              // IMPORTANTE: usar la misma referencia vertical que la barra (eBarY + eBarH/2) para todos los enemigos.
              // Antes faltaba posYOffset, provocando que el enemigo central (con posYOffset=18) dibujara el número 18px por encima de la barra.
              e.posy + posYOffset - hpBarOffset + 6
            );
            ctx.textAlign = "left"; // Resetear alineación
            ctx.textBaseline = "alphabetic"; // Resetear baseline

            // Charge bar background (solo si está vivo) - directamente debajo de la HP bar
            if (e.hp > 0) {
              const eChargeY = eBarY + eBarH + 2; // separador 2px
              const eChargeRatio = e.charge / e.maxcharge;
              drawRoundedBar(ctx, eBarX, eChargeY, eBarW, eBarH, eChargeRatio, {
                bgColor: "rgba(0,0,0,0.55)",
                fillColor: "#FFA500",
                borderColor: "#3B2A1A",
                radius: 5,
                lineWidth: 1.2,
              });

              // Número de orden de turno para enemigo (si está en turnQueue)
              const enemyOrderIndex = turnQueue.indexOf(e);
              if (enemyOrderIndex !== -1) {
                ctx.save();
                const orderText = (enemyOrderIndex + 1).toString();
                ctx.font = "bold 15px 'Jersey 10'"; // Más grande
                // Alinear a la derecha para posicionarlo similar a héroes (consistencia visual)
                ctx.textAlign = "right";
                ctx.textBaseline = "middle";
                ctx.strokeStyle = "#000";
                ctx.lineWidth = 3;
                ctx.fillStyle = enemyOrderIndex === 0 ? "#FFD700" : "#FFFFFF";
                // Separar un poco más: mover 6 píxeles extra hacia la izquierda (-46 como en héroes)
                const tx = e.posx - 46;
                const ty = eBarY + eBarH + 2 + eBarH / 2; // centro de la barra de carga nueva
                ctx.strokeText(orderText, tx, ty);
                ctx.fillText(orderText, tx, ty);
                ctx.restore();
              }

              // Mostrar contador de ataque especial dentro de esfera en el lado derecho del HUD
              if (
                (e.type === "boss" && e.attacksUntilSpecial !== null) ||
                (e.name === "Crab Bomb" && e.maxSphereCharges)
              ) {
                let counterValue;
                if (e.name === "Crab Bomb") {
                  // Para Crab Bomb, cuenta regresiva: 5,4,3,2,1
                  counterValue = e.maxSphereCharges - (e.sphereCharges || 0);
                } else {
                  // Para bosses, mostrar cuenta completa (ej: 5..1)
                  counterValue = e.attacksUntilSpecial;
                }
                // Posicionar esfera en el extremo derecho del HUD enemigo (al final de la barra de carga)
                const radius = 9; // reducido (antes 12)
                // Barra de carga termina en x = e.posx - 40 + 80 = e.posx + 40
                // Colocamos la esfera con un pequeño margen (6px)
                let circleX = e.posx + 40 + radius + 2; // margen lateral menor (antes +6)
                const circleY = e.posy - hpBarOffset + 3 + radius; // más cerca del HUD (antes +6)

                // Si se sale del diseño (designWidth), reposicionar justo antes del borde
                if (circleX + radius > designWidth - 4) {
                  circleX = designWidth - 4 - radius;
                }

                ctx.save();
                // Esfera con color sólido solicitado
                ctx.beginPath();
                ctx.fillStyle = "#D3BF8F";
                ctx.arc(circleX, circleY, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.lineWidth = 1.5;
                ctx.strokeStyle = "#000";
                ctx.stroke();

                // Número centrado
                ctx.font = "bold 11px 'Jersey 10'"; // Más pequeño para mejor legibilidad dentro de la esfera
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.lineWidth = 3;
                ctx.strokeStyle = "#000";
                ctx.fillStyle = "#FFF";
                // Centrado exacto (sin desplazamiento vertical adicional)
                ctx.strokeText(counterValue.toString(), circleX, circleY);
                ctx.fillText(counterValue.toString(), circleX, circleY);
                ctx.restore();
              }
            }

            // (Bordes ya dibujados por drawRoundedBar)

            // Renderizar debuffs debajo de la barra de carga (solo si está vivo)
            renderDebuffs(e, e.posx, eBarY + eBarH + 2 + eBarH + 2);
          }
        });

        // Renderizar efectos visuales especiales
        renderVisualEffects();

        // Renderizar números de golpe flotantes
        renderHitNumbers();

        // Restaurar el contexto para poder renderizar UI sin restricciones
        ctx.restore();
        // Overlay de transición (después de render principal) si activo
        if (waveTransition.active) {
          const t = Math.max(0, waveTransition.timer / waveTransition.delay);
          const alpha = 0.25 * t; // leve y decreciente
          ctx.save();
          ctx.fillStyle = `rgba(0,0,0,${alpha.toFixed(3)})`;
          ctx.fillRect(0, 0, designWidth, designHeight);
          ctx.restore();
          if (waveTransition.timer <= 0) {
            waveTransition.active = false;
            if (pendingLevelInfo) {
              /* log removed (showing next level info) */
              pendingLevelInfo = false;
              state = "level_info";
            } else {
              /* log removed (starting next wave) */
              startWave();
            }
          }
        }

        // Mostrar indicador de selección de objetivo con ventana modal
        if (state === "select_target_enemy") {
          // Modal que ocupa todo el ancho, centrado verticalmente
          const modalWidth = designWidth;
          const modalHeight = 28; // Reducido para un componente más compacto
          const modalX = 0;
          // Ahora pegado al header
          const modalY = HEADER_HEIGHT + 2; // 2px de margen inferior del header

          ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
          ctx.fillRect(modalX, modalY, modalWidth, modalHeight);

          // Texto principal - más grande y visible
          ctx.fillStyle = "#E0E0E0";
          ctx.font = "15px 'Jersey 10'"; // Más grande
          ctx.textAlign = "center";
          ctx.fillText(
            "Select enemy",
            designWidth / 2,
            modalY + modalHeight / 2 + 3
          );
        } else if (state === "select_target_ally") {
          // Modal que ocupa todo el ancho, centrado verticalmente
          const modalWidth = designWidth;
          const modalHeight = 28; // Reducido para un componente más compacto
          const modalX = 0;
          // Ahora pegado al header
          const modalY = HEADER_HEIGHT + 2;

          ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
          ctx.fillRect(modalX, modalY, modalWidth, modalHeight);

          // Texto principal - más grande y visible
          ctx.fillStyle = "#E0E0E0"; // Igual que 'Select enemy'
          ctx.font = "15px 'Jersey 10'"; // Unificado con 'Select enemy'
          ctx.textAlign = "center";
          ctx.fillText(
            "Select ally",
            designWidth / 2,
            modalY + modalHeight / 2 + 3
          );
        }
        ctx.textAlign = "left"; // Resetear alineación

        // Indicador visual removido - ya no necesario sin sistema de turnos

        // RENDERIZAR HEADER Y FOOTER AL FINAL para garantizar que siempre estén visibles
        drawHeader();
        drawFooter();
      }

      // Función helper para dibujar rectángulos redondeados
      function drawRoundedRect(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(
          x + width,
          y + height,
          x + width - radius,
          y + height
        );
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.stroke();
      }

      function drawHeader() {
        // Limpiar completamente el área del header para evitar interferencias
        ctx.clearRect(0, 0, designWidth, HEADER_HEIGHT);

        // Fondo del header
        ctx.fillStyle = "#D3BF8F";
        ctx.fillRect(0, 0, designWidth, HEADER_HEIGHT);

        // Borde inferior del header
        ctx.strokeStyle = "#3D2914";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, HEADER_HEIGHT);
        ctx.lineTo(designWidth, HEADER_HEIGHT);
        ctx.stroke();

        // Línea divisora horizontal entre score y level/wave
        ctx.strokeStyle = "#3D2914";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(0, HEADER_HEIGHT / 2);
        ctx.lineTo(designWidth, HEADER_HEIGHT / 2);
        ctx.stroke();

        // Líneas divisoras verticales en la sección inferior
        ctx.strokeStyle = "#3D2914";
        ctx.lineWidth = 4;
        ctx.beginPath();
        // Primera línea divisora (1/3)
        ctx.moveTo(designWidth / 3, HEADER_HEIGHT / 2);
        ctx.lineTo(designWidth / 3, HEADER_HEIGHT);
        // Segunda línea divisora (2/3)
        ctx.moveTo((designWidth * 2) / 3, HEADER_HEIGHT / 2);
        ctx.lineTo((designWidth * 2) / 3, HEADER_HEIGHT);
        ctx.stroke();

        // Marco interno para Score (sección superior completa)
        const frameMargin = 4; // Padding aumentado para mayor separación
        const dividerThickness = 4; // Grosor de las líneas divisoras
        const cornerRadius = 3; // Radio para esquinas redondeadas

        const scoreFrameX = frameMargin;
        const scoreFrameY = frameMargin;
        const scoreFrameWidth = designWidth - frameMargin * 2;
        const scoreFrameHeight =
          HEADER_HEIGHT / 2 - frameMargin * 2 - dividerThickness / 2; // Respeta frameMargin arriba y abajo + línea divisora

        ctx.strokeStyle = "#AF9E75";
        ctx.lineWidth = 2;
        drawRoundedRect(
          ctx,
          scoreFrameX,
          scoreFrameY,
          scoreFrameWidth,
          scoreFrameHeight,
          cornerRadius
        );

        // Marco interno para Level (primera sección inferior)
        const levelFrameX = frameMargin;
        const levelFrameY =
          HEADER_HEIGHT / 2 + dividerThickness / 2 + frameMargin; // Respeta la línea divisora
        const levelFrameWidth =
          designWidth / 3 - dividerThickness / 2 - frameMargin * 2; // Respeta el margen izquierdo y la línea divisora
        const levelFrameHeight =
          HEADER_HEIGHT / 2 - dividerThickness / 2 - frameMargin * 2;

        ctx.strokeStyle = "#AF9E75";
        ctx.lineWidth = 2;
        drawRoundedRect(
          ctx,
          levelFrameX,
          levelFrameY,
          levelFrameWidth,
          levelFrameHeight,
          cornerRadius
        );

        // Marco interno para Título (sección central inferior)
        const titleFrameX =
          designWidth / 3 + dividerThickness / 2 + frameMargin;
        const titleFrameY =
          HEADER_HEIGHT / 2 + dividerThickness / 2 + frameMargin; // Respeta la línea divisora
        const titleFrameWidth =
          designWidth / 3 - dividerThickness - frameMargin * 2;
        const titleFrameHeight =
          HEADER_HEIGHT / 2 - dividerThickness / 2 - frameMargin * 2;

        ctx.strokeStyle = "#AF9E75";
        ctx.lineWidth = 2;
        drawRoundedRect(
          ctx,
          titleFrameX,
          titleFrameY,
          titleFrameWidth,
          titleFrameHeight,
          cornerRadius
        );

        // Marco interno para Wave (tercera sección inferior)
        const waveFrameX =
          (designWidth * 2) / 3 + dividerThickness / 2 + frameMargin;
        const waveFrameY =
          HEADER_HEIGHT / 2 + dividerThickness / 2 + frameMargin; // Respeta la línea divisora
        const waveFrameWidth =
          designWidth / 3 - dividerThickness / 2 - frameMargin * 2; // Respeta el borde derecho
        const waveFrameHeight =
          HEADER_HEIGHT / 2 - dividerThickness / 2 - frameMargin * 2;

        ctx.strokeStyle = "#AF9E75";
        ctx.lineWidth = 2;
        drawRoundedRect(
          ctx,
          waveFrameX,
          waveFrameY,
          waveFrameWidth,
          waveFrameHeight,
          cornerRadius
        );

        // Score centrado en su marco
        ctx.font = "bold 16px 'Jersey 10'"; // Más grande
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        const pointsText = "Points";
        const scoreText = score.toString();
        const totalScoreText = scoreText + " " + pointsText;

        // Centrar verticalmente en el marco del score
        const scoreCenterY = scoreFrameY + scoreFrameHeight / 2;

        // Texto del score en marrón sin borde
        ctx.fillStyle = "#3D2914";
        ctx.fillText(totalScoreText, designWidth / 2, scoreCenterY);

        // Calcular nivel y wave
        const currentLevel = Math.floor((wave - 1) / 3) + 1;
        const currentWaveInLevel = ((wave - 1) % 3) + 1;

        // Obtener título de la dungeon desde la configuración de niveles
        const currentLevelConfig = levelConfig[currentLevel] || levelConfig[1];
        const dungeonTitle = currentLevelConfig
          ? currentLevelConfig.name
          : "Demon Cave";

        // Configurar fuente y alineación para la sección inferior
        ctx.font = "bold 15px 'Jersey 10'"; // Más grande
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // Level centrado en su marco
        const levelCenterX = levelFrameX + levelFrameWidth / 2;
        const levelCenterY = levelFrameY + levelFrameHeight / 2;
        const levelText = "Level " + currentLevel.toString();

        ctx.fillStyle = "#3D2914";
        ctx.fillText(levelText, levelCenterX, levelCenterY);

        // Título de la dungeon centrado en su marco (en marrón sin borde)
        const titleCenterX = titleFrameX + titleFrameWidth / 2;
        const titleCenterY = titleFrameY + titleFrameHeight / 2;

        // Dibujar texto en marrón sin borde, igual que el resto
        ctx.fillStyle = "#3D2914"; // Marrón igual que el resto de textos
        ctx.fillText(dungeonTitle, titleCenterX, titleCenterY);

        // Wave centrado en su marco
        const waveCenterX = waveFrameX + waveFrameWidth / 2;
        const waveCenterY = waveFrameY + waveFrameHeight / 2;
        const waveText = "Wave " + currentWaveInLevel.toString() + "/3";

        ctx.fillStyle = "#3D2914";
        ctx.fillText(waveText, waveCenterX, waveCenterY);

        ctx.textAlign = "left"; // Resetear alineación
        ctx.textBaseline = "alphabetic"; // Resetear baseline
      }

      function drawFooter() {
        // Limpiar completamente el área del footer para evitar interferencias
        ctx.clearRect(0, FOOTER_Y, designWidth, FOOTER_HEIGHT);

        // Fondo del footer - más oscuro y más alto
        ctx.fillStyle = "rgba(30, 20, 10, 0.9)";
        ctx.fillRect(0, FOOTER_Y, designWidth, FOOTER_HEIGHT);

        // Dividir en 3 columnas
        const columnWidth = designWidth / 3;
        const heroOrder = ["mage", "warlock", "priest"];

        heroOrder.forEach((heroClass, heroIndex) => {
          const hero = heroes.find((h) => h.clazz === heroClass);
          if (!hero) return;
          // Nota: En sistema de turnos sólo el héroe que está en la primera posición de turnQueue puede usar habilidades (se refleja desactivando botones)

          const columnX = heroIndex * columnWidth;
          const centerX = columnX + columnWidth / 2;

          // Dibujar panel para cada héroe - usar beige para todos con menos espacio entre cards
          const panelWidth = columnWidth - 5;
          const panelHeight = 110; // Aumentado de 90 a 110
          const panelX = columnX + 2.5;
          const panelY = 525; // Ajustado de 545 a 525

          ctx.drawImage(panelBeigeImg, panelX, panelY, panelWidth, panelHeight);

          // Título del héroe - siempre mismo color sin importar si está muerto
          ctx.fillStyle = "white"; // Siempre marrón oscuro
          ctx.font = "bold 15px 'Jersey 10'"; // Revertido a fuente anterior héroe
          ctx.textAlign = "center";
          // Espaciado manual entre letras para mejorar legibilidad
          const heroName = hero.clazz.toUpperCase();
          const letterSpacing = 1.5; // separación ligera
          // Medir ancho total aproximado
          let totalWidth = 0;
          for (let i = 0; i < heroName.length; i++) {
            totalWidth += ctx.measureText(heroName[i]).width;
            if (i < heroName.length - 1) totalWidth += letterSpacing;
          }
          let startX = centerX - totalWidth / 2;
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 3;
          for (let i = 0; i < heroName.length; i++) {
            const ch = heroName[i];
            const w = ctx.measureText(ch).width;
            const drawX = startX + w / 2;
            const drawY = 543;
            ctx.strokeText(ch, drawX, drawY);
            ctx.fillText(ch, drawX, drawY); // dibujar centrando cada letra en su mini-bloque
            startX += w + letterSpacing;
          }

          // Botón "Next Turn" encima del panel del WARLOCK (heroIndex==1)
          if (heroClass === "warlock") {
            const nextBtnWidth = 90;
            const nextBtnHeight = 20;
            const nextBtnX = centerX - nextBtnWidth / 2;
            const nextBtnY = panelY - 25; // subido 1px más arriba
            const canForce =
              turnQueue.length > 0 &&
              !waveTransition.active &&
              state !== "game_over";
            // Fondo contenedor oscuro redondeado
            const pad = 4;
            const containerX = nextBtnX - pad;
            const containerY = nextBtnY - pad;
            const containerW = nextBtnWidth + pad * 2;
            const containerH = nextBtnHeight + pad * 2;
            ctx.save();
            ctx.fillStyle = "#1B1209"; // marrón más oscuro solicitado para contenedor Skip
            const r = 6;
            ctx.beginPath();
            ctx.moveTo(containerX + r, containerY);
            ctx.lineTo(containerX + containerW - r, containerY);
            ctx.quadraticCurveTo(
              containerX + containerW,
              containerY,
              containerX + containerW,
              containerY + r
            );
            ctx.lineTo(containerX + containerW, containerY + containerH - r);
            ctx.quadraticCurveTo(
              containerX + containerW,
              containerY + containerH,
              containerX + containerW - r,
              containerY + containerH
            );
            ctx.lineTo(containerX + r, containerY + containerH);
            ctx.quadraticCurveTo(
              containerX,
              containerY + containerH,
              containerX,
              containerY + containerH - r
            );
            ctx.lineTo(containerX, containerY + r);
            ctx.quadraticCurveTo(
              containerX,
              containerY,
              containerX + r,
              containerY
            );
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            ctx.drawImage(
              canForce ? buttonLongBeigeImg : buttonLongBrownImg,
              nextBtnX,
              nextBtnY,
              nextBtnWidth,
              nextBtnHeight
            );
            ctx.fillStyle = "#3D2914";
            ctx.font = "bold 14px 'Jersey 10'"; // Más grande
            ctx.textAlign = "center";
            ctx.fillText("Skip", centerX, nextBtnY + 13);
            // Guardar zona para click detection
            hero.nextTurnButton = {
              x: nextBtnX,
              y: nextBtnY,
              w: nextBtnWidth,
              h: nextBtnHeight,
            };
          }

          if (hero.hp <= 0) {
            // Mostrar imagen de calavera en la posición del segundo botón (habilidad secundaria)
            const buttonWidth = panelWidth - 14;
            const buttonHeight = 25;
            const buttonY1 = 550; // mismo que se usa cuando vivo
            const buttonSpacing = 2;
            const buttonY2 = buttonY1 + buttonHeight + buttonSpacing; // posición segundo botón
            const skullSizePanel = 32; // Un poco más grande
            const skullX = centerX - skullSizePanel / 2;
            const skullY = buttonY2 + buttonHeight / 2 - skullSizePanel / 2;
            if (skullDeadImg.complete) {
              ctx.drawImage(
                skullDeadImg,
                skullX,
                skullY,
                skullSizePanel,
                skullSizePanel
              );
            } else {
              ctx.fillStyle = "red";
              ctx.font = "bold 18px 'Jersey 10'"; // Más grande
              ctx.textAlign = "center";
              ctx.fillText("X", centerX, skullY + skullSizePanel / 2 + 4);
            }
          } else {
            const actions = Object.keys(classActions[hero.clazz]);

            // Configuración de botones - altura aumentada
            const buttonWidth = panelWidth - 14;
            const buttonHeight = 25; // Aumentado de 23 a 25
            const buttonX = panelX + 7;
            const buttonSpacing = 2; // Aumentado de 1 a 2

            // Botón habilidad principal (1 carga - 33.33%)
            const primaryAction = actions[0];
            const primaryData = classActions[hero.clazz][primaryAction];
            const buttonY1 = 550; // Ajustado de 567 a 550
            const canUsePrimary = hero.charge >= primaryData.reqCharge;
            const canActTurn = turnQueue.length > 0 && turnQueue[0] === hero;
            const canUsePrimaryTurn = canUsePrimary && canActTurn;

            // Determinar estado de selección (antes de dibujar)
            const isSelectingTarget =
              state === "select_target_enemy" || state === "select_target_ally";
            const primarySelected =
              isSelectingTarget &&
              selectedHero === hero &&
              selectedAction === primaryAction;
            // Usar botón beige si está activo, botón marrón si está inactivo
            const primaryButtonBaseImg = canUsePrimaryTurn
              ? buttonLongBeigeImg
              : buttonLongBrownImg;
            ctx.drawImage(
              primarySelected && canUsePrimaryTurn
                ? buttonLongBeigePressedImg
                : primaryButtonBaseImg,
              buttonX,
              buttonY1,
              buttonWidth,
              buttonHeight
            );

            // Texto del botón principal - resaltar si seleccionado y en fase de selección de objetivo
            ctx.fillStyle = primarySelected ? "#2A1C0E" : "#3D2914"; // Más oscuro si seleccionado
            ctx.font = "bold 14px 'Jersey 10'"; // Más grande
            ctx.textAlign = "center";
            const primaryText =
              primaryData.name.charAt(0).toUpperCase() +
              primaryData.name.slice(1).toLowerCase();
            ctx.fillText(primaryText, centerX, buttonY1 + 16); // Ajustado para centrar mejor con altura 25

            // Botón habilidad secundaria (2 cargas - 66.66%)
            const secondaryAction = actions[1];
            const secondaryData = classActions[hero.clazz][secondaryAction];
            const buttonY2 = buttonY1 + buttonHeight + buttonSpacing;
            const canUseSecondary = hero.charge >= secondaryData.reqCharge;
            const canUseSecondaryTurn = canUseSecondary && canActTurn;

            const secondarySelected =
              isSelectingTarget &&
              selectedHero === hero &&
              selectedAction === secondaryAction;
            const secondaryButtonBaseImg = canUseSecondaryTurn
              ? buttonLongBeigeImg
              : buttonLongBrownImg;
            ctx.drawImage(
              secondarySelected && canUseSecondaryTurn
                ? buttonLongBeigePressedImg
                : secondaryButtonBaseImg,
              buttonX,
              buttonY2,
              buttonWidth,
              buttonHeight
            );

            // Texto del botón secundario - resaltar si seleccionado
            ctx.fillStyle = secondarySelected ? "#2A1C0E" : "#3D2914";
            ctx.font = "bold 14px 'Jersey 10'"; // Más grande
            ctx.textAlign = "center";
            const secondaryText =
              secondaryData.name.charAt(0).toUpperCase() +
              secondaryData.name.slice(1).toLowerCase();
            ctx.fillText(secondaryText, centerX, buttonY2 + 16); // Ajustado para centrar mejor con altura 25

            // Botón habilidad terciaria (3 cargas - 100%)
            const tertiaryAction = actions[2];
            const tertiaryData = classActions[hero.clazz][tertiaryAction];
            const buttonY3 = buttonY2 + buttonHeight + buttonSpacing;
            const canUseTertiary = hero.charge >= tertiaryData.reqCharge;
            const canUseTertiaryTurn = canUseTertiary && canActTurn;

            const tertiarySelected =
              isSelectingTarget &&
              selectedHero === hero &&
              selectedAction === tertiaryAction;
            const tertiaryButtonBaseImg = canUseTertiaryTurn
              ? buttonLongBeigeImg
              : buttonLongBrownImg;
            ctx.drawImage(
              tertiarySelected && canUseTertiaryTurn
                ? buttonLongBeigePressedImg
                : tertiaryButtonBaseImg,
              buttonX,
              buttonY3,
              buttonWidth,
              buttonHeight
            );

            // Texto del botón terciario - resaltar si seleccionado
            ctx.fillStyle = tertiarySelected ? "#2A1C0E" : "#3D2914";
            ctx.font = "bold 14px 'Jersey 10'"; // Más grande
            ctx.textAlign = "center";
            const tertiaryText =
              tertiaryData.name.charAt(0).toUpperCase() +
              tertiaryData.name.slice(1).toLowerCase();
            ctx.fillText(tertiaryText, centerX, buttonY3 + 16); // Ajustado para centrar mejor con altura 25
          }
        });

        ctx.textAlign = "left";
      }

      function drawMainMenu() {
        // Dibujar fondo de la pantalla de inicio sin compresión
        ctx.imageSmoothingEnabled = false; // Evitar suavizado/compresión
        ctx.drawImage(mainMenuImg, 0, 0, designWidth, designHeight);
        ctx.imageSmoothingEnabled = true; // Restaurar suavizado para otros elementos

        // Configuración de botones estilo habilidades
        const buttonWidth = 200;
        const buttonHeight = 40;
        const buttonSpacing = 20;
        const startY = 350;
        const buttonX = (designWidth - buttonWidth) / 2;

        // Botones base del menú
        const buttons = ["Start", "Guide", "Book"];
        // Botón Dev L4 eliminado

        buttons.forEach((buttonText, index) => {
          const buttonY = startY + index * (buttonHeight + buttonSpacing);

          // Usar estilo de botón similar a las habilidades
          ctx.drawImage(
            buttonLongBeigeImg,
            buttonX,
            buttonY,
            buttonWidth,
            buttonHeight
          );

          // Texto del botón con estilo similar a las habilidades
          ctx.fillStyle = "#3D2914"; // Marrón oscuro como los botones de habilidades
          ctx.font = "bold 19px 'Jersey 10'";
          ctx.textAlign = "center";
          ctx.fillText(buttonText, designWidth / 2, buttonY + 25);
        });

        ctx.textAlign = "left";
      }

      function drawLevelInfo() {
        const levelData = levelInfo[currentLevel];

        // Reproducir música del nivel correspondiente si no está sonando
        let targetMusic;
        if (currentLevel === 1) {
          targetMusic = level1Music;
        } else if (currentLevel === 2) {
          targetMusic = level2Music;
        } else if (currentLevel === 3) {
          targetMusic = level3Music;
        } else if (currentLevel === 4) {
          targetMusic = level4Music; // música específica nivel 4
        } else {
          targetMusic = level1Music; // Fallback
        }

        if (currentMusic !== targetMusic) {
          playMusic(targetMusic);
        }

        // Seleccionar el background correcto según el nivel
        let currentLevelBg;
        if (currentLevel === 1) {
          currentLevelBg = level1InfoBg;
        } else if (currentLevel === 2) {
          currentLevelBg = level2InfoBg;
        } else if (currentLevel === 3) {
          currentLevelBg = level3InfoBg;
        } else if (currentLevel === 4) {
          if (currentMusic !== level4Music) {
            playMusic(level4Music);
          }
          currentLevelBg = level4InfoBg;
        } else {
          currentLevelBg = level1InfoBg; // Fallback
        }

        // Dibujar fondo de imagen para las pantallas de nivel sin compresión
        ctx.imageSmoothingEnabled = false; // Evitar suavizado/compresión
        ctx.drawImage(currentLevelBg, 0, 0, designWidth, designHeight);
        ctx.imageSmoothingEnabled = true; // Restaurar suavizado para otros elementos

        // Oscurecer ligeramente el fondo
        ctx.fillStyle = "rgba(0, 0, 0, 0.15)";
        ctx.fillRect(0, 0, designWidth, designHeight);

        // Marco decorativo
        ctx.strokeStyle = "#D3BF8F";
        ctx.lineWidth = 2;
        ctx.strokeRect(20, 20, designWidth - 40, designHeight - 40);

        // Título del nivel (ahora en blanco)
        ctx.fillStyle = "#FFFFFF";
        ctx.strokeStyle = "#000000"; // Borde negro para mejor contraste
        ctx.lineWidth = 3;
        ctx.font = "bold 36px 'Jersey 10'";
        ctx.letterSpacing = "0.1px";
        ctx.textAlign = "center";

        const levelTitle = `Level ${currentLevel}`; // Blanco
        ctx.strokeText(levelTitle, designWidth / 2, 120);
        ctx.fillText(levelTitle, designWidth / 2, 120);

        // Nombre del nivel
        ctx.font = "bold 30px 'Jersey 10'";
        ctx.letterSpacing = "0.1px";
        ctx.strokeStyle = "#000000"; // Borde negro para mejor contraste
        ctx.strokeText(levelData.name, designWidth / 2, 160);
        ctx.fillText(levelData.name, designWidth / 2, 160);

        // Lore del nivel (texto envuelto) - usando Jacquard 24
        ctx.font = "18px 'Jacquard 24'";
        ctx.fillStyle = "#FFFFFF";
        ctx.strokeStyle = "#2A1F0F";
        ctx.lineWidth = 1;

        const loreLines = wrapText(levelData.lore, 280);
        const lineHeight = 32;
        const startY = 220;

        loreLines.forEach((line, index) => {
          const y = startY + index * lineHeight;
          ctx.strokeText(line, designWidth / 2, y);
          ctx.fillText(line, designWidth / 2, y);
        });

        // Botón "Explore" estilo habilidades
        const buttonY = 420;
        const buttonWidth = 200;
        const buttonHeight = 40;
        const buttonX = (designWidth - buttonWidth) / 2;

        // Usar estilo de botón similar a las habilidades
        ctx.drawImage(
          buttonLongBeigeImg,
          buttonX,
          buttonY,
          buttonWidth,
          buttonHeight
        );

        // Texto del botón con estilo similar a las habilidades
        ctx.fillStyle = "#3D2914"; // Marrón oscuro como los botones de habilidades
        ctx.font = "bold 19px 'Jersey 10'";
        ctx.textAlign = "center";
        ctx.fillText("Explore", designWidth / 2, buttonY + 25);

        ctx.textAlign = "left";
      }

      function drawLevelCompletion() {
        // Dibujar fondo del juego actual
        ctx.drawImage(currentBackgroundImg, 0, 0, designWidth, designHeight);

        // Overlay oscuro
        ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
        ctx.fillRect(0, 0, designWidth, designHeight);

        // Modal central
        const modalWidth = 300;
        const modalHeight = 290; // Aumentado para acomodar el botón Surrender
        const modalX = (designWidth - modalWidth) / 2;
        const modalY = (designHeight - modalHeight) / 2;

        // Fondo del modal
        ctx.fillStyle = "rgba(20, 20, 20, 0.95)";
        ctx.fillRect(modalX, modalY, modalWidth, modalHeight);

        // Marco del modal con el mismo estilo que las pantallas de nivel
        ctx.strokeStyle = "#D3BF8F";
        ctx.lineWidth = 2;
        ctx.strokeRect(modalX, modalY, modalWidth, modalHeight);

        // Título del modal con el mismo estilo que los títulos de nivel
        ctx.fillStyle = "#D3BF8F";
        ctx.strokeStyle = "#000000"; // Borde negro como los títulos de nivel
        ctx.lineWidth = 3;
        ctx.font = "bold 24px 'Jersey 10'";
        ctx.letterSpacing = "0.1px";
        ctx.textAlign = "center";

        let titleText;
        if (levelCompletionModal.gameCompleted) {
          titleText = "Victory!";
        } else {
          titleText = `${levelCompletionModal.boss} Defeated`;
        }

        ctx.strokeText(titleText, designWidth / 2, modalY + 50);
        ctx.fillText(titleText, designWidth / 2, modalY + 50);

        // Texto de preparación para siguiente nivel
        ctx.font = "18px 'Jacquard 24'";
        ctx.fillStyle = "#FFFFFF";
        ctx.strokeStyle = "#2A1F0F";
        ctx.lineWidth = 1;

        let readyText;
        if (levelCompletionModal.gameCompleted) {
          readyText = "You have conquered all dungeons!";
        } else {
          readyText = "Ready for the next level?";
        }

        const readyLines = wrapText(readyText, modalWidth - 40);
        readyLines.forEach((line, index) => {
          const y = modalY + 90 + index * 24;
          ctx.strokeText(line, designWidth / 2, y);
          ctx.fillText(line, designWidth / 2, y);
        });

        // Botón Continue estilo habilidades
        const continueButtonY = modalY + 150;
        const buttonWidth = 160;
        const buttonHeight = 40;
        const buttonX = (designWidth - buttonWidth) / 2;

        // Usar estilo de botón similar a las habilidades
        ctx.drawImage(
          buttonLongBeigeImg,
          buttonX,
          continueButtonY,
          buttonWidth,
          buttonHeight
        );

        // Texto del botón Continue
        ctx.fillStyle = "#3D2914"; // Marrón oscuro como los botones de habilidades
        ctx.font = "bold 17px 'Jersey 10'";
        ctx.textAlign = "center";

        let continueButtonText;
        if (levelCompletionModal.gameCompleted) {
          continueButtonText = "Main Menu";
        } else {
          continueButtonText = "Continue";
        }

        ctx.fillText(continueButtonText, designWidth / 2, continueButtonY + 25);

        // Botón Surrender (solo si no es el final del juego)
        if (!levelCompletionModal.gameCompleted) {
          const surrenderButtonY = continueButtonY + buttonHeight + 10;

          // Usar el mismo estilo de botón
          ctx.drawImage(
            buttonLongBeigeImg,
            buttonX,
            surrenderButtonY,
            buttonWidth,
            buttonHeight
          );

          // Texto del botón Surrender en rojo
          ctx.fillStyle = "#CC0000"; // Rojo para surrender
          ctx.font = "bold 17px 'Jersey 10'";
          ctx.textAlign = "center";
          ctx.fillText("Surrender", designWidth / 2, surrenderButtonY + 25);
        }

        ctx.textAlign = "left";
      }

      // Función para dibujar la pantalla del libro de monstruos
      function drawMonsterBook() {
        // Dibujar fondo del libro
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(bookBackgroundImg, 0, 0, designWidth, designHeight);

        // Datos de todos los monstruos organizados por nivel
        const monstersData = [
          // Level 1 - The Crypt
          {
            name: "Demon Bat",
            type: "Normal Enemy",
            level: "The Forgotten Crypt",
            hp: 80,
            abilities: ["Basic Attack: Low to medium damage to random hero"],
            description:
              "Swift flying creatures that inhabit dark crypts. Their speed makes them dangerous opponents.",
            sprite: demonBatIdleImg,
            frameWidth: 81,
            frameHeight: 71,
            idleFrames: 4,
          },
          {
            name: "Noctebane (BOSS)",
            type: "Boss",
            level: "The Forgotten Crypt",
            hp: 200,
            abilities: [
              "Blood Splat: Normal damage to random hero",
              "Blood Storm: Damages all heroes (after 3 basic attacks)",
              "Passive: Each attack increases its damage by 5% (stacks)",
            ],
            description:
              "The Shadow Bat Lord that rules over the forgotten crypt. Master of dark blood magic.",
            sprite: bossBatIdleImg,
            frameWidth: 81,
            frameHeight: 71,
            idleFrames: 4,
          },
          // Level 2 - Red Dunes
          {
            name: "Fire Worm",
            type: "Normal Enemy",
            level: "The Red Dunes",
            hp: 80,
            abilities: ["Basic Attack: Medium damage to random hero"],
            description:
              "Desert predators that burrow beneath the crimson sands, emerging to ambush unwary travelers.",
            sprite: wormIdleImg,
            frameWidth: 90,
            frameHeight: 90,
            idleFrames: 9,
          },
          {
            name: "Crab Bomb",
            type: "Special Enemy",
            level: "The Red Dunes",
            hp: 150,
            abilities: ["Explode: High damage to all heroes (after 5 charges)"],
            description:
              "Volatile crustaceans that sacrifice themselves in devastating explosions. No basic attacks.",
            sprite: crabBombIdleImg,
            frameWidth: 80,
            frameHeight: 80,
            idleFrames: 13,
          },
          {
            name: "Minotaur (BOSS)",
            type: "Boss",
            level: "The Red Dunes",
            hp: 300,
            abilities: [
              "Smash: Heavy damage to random hero",
              "Life Steal: Damages hero and heals self (after 3 attacks)",
              "Passive: Gains +5% charge speed after every attack (stacks)",
            ],
            description:
              "The mighty guardian of the Red Dunes. This beast grows stronger as the battle progresses.",
            sprite: minotaurAllStatesImg,
            frameWidth: 288,
            frameHeight: 160,
            idleFrames: 16,
          },
          // Level 3 - Dark Swamp
          {
            name: "Mushroom",
            type: "Normal Enemy",
            level: "The Dark Swamp",
            hp: 100,
            abilities: ["Poison Attack: Damages and poisons target hero"],
            description:
              "Toxic fungi that release deadly spores. Their poison can weaken heroes over time.",
            sprite: mushroomIdleImg,
            frameWidth: 80,
            frameHeight: 64,
            idleFrames: 7,
          },
          {
            name: "Dreadwing",
            type: "Flying Enemy",
            level: "The Dark Swamp",
            hp: 90,
            abilities: ["Double Strike: Attacks twice in succession"],
            description:
              "Sinister flying creatures that patrol the marshlands. Their speed allows for devastating combos.",
            sprite: dreadwingIdleImg,
            frameWidth: 64,
            frameHeight: 64,
            idleFrames: 8,
          },
          {
            name: "Gorgon (BOSS)",
            type: "Boss",
            level: "The Dark Swamp",
            hp: 400,
            abilities: [
              "Basic Attack: Poison attack (identical to Mushroom)",
              "Toxic Horror: Massive poison damage to all heroes (after 3 attacks)",
            ],
            description:
              "The ancient master of the Dark Swamp. Her toxic presence corrupts everything around her.",
            sprite: swampGorgonIdleImg,
            frameWidth: 128,
            frameHeight: 128,
            idleFrames: 7,
          },
          // Level 4 - Soul Rift
          {
            name: "Voidspecter",
            type: "Caster Enemy",
            level: "The Soul Rift",
            hp: 110,
            abilities: [
              "Dual Void Bolt: Strikes 2 random heroes (20–30 each)",
              "Flying: Hard to pin down",
            ],
            description:
              "Fractured echoes of lost mages channel twin void bolts across timelines.",
            sprite: (() => {
              const i = new Image();
              i.src =
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/wizard_level4_idle-7EvcH4zEibEfrCl7wBpXnkc7wOKPCa.png?epgj";
              return i;
            })(),
            frameWidth: 80,
            frameHeight: 80,
            idleFrames: 10,
          },
          {
            name: "The Hand",
            type: "Support Enemy",
            level: "The Soul Rift",
            hp: 80,
            abilities: [
              "Dark Protection: +20% defense then +5% per extra stack to an ally",
              "No Basic Attack",
            ],
            description:
              "A grasping ward-weaver that prolongs aberrations with shadow barriers.",
            sprite: (() => {
              const i = new Image();
              i.src =
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/hand-level4-idle-fp21qt00qnRnsvMiDFjaQYmGPAKOwV.png?fDpo";
              return i;
            })(),
            frameWidth: 62,
            frameHeight: 80,
            idleFrames: 8,
          },
          {
            name: "Abyss King (BOSS)",
            type: "Boss",
            level: "The Soul Rift",
            hp: 400,
            abilities: [
              "Abyss Strike: Heavy single-target void damage",
              "Abyss Summon: After 3 strikes opens a portal to summon (summons die on his death)",
            ],
            description:
              "Sovereign of collapsing realities. His fall seals the rift—temporarily.",
            sprite: (() => {
              const i = new Image();
              i.src =
                "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/skeleton-XsPylnGSOBvRiu1c7XplFB3aVKdlaA.png?NoJO";
              return i;
            })(),
            frameWidth: 145,
            frameHeight: 134,
            idleFrames: 9,
          },
        ];

        // Configuración de las cartas
        const cardWidth = 320;
        const cardHeight = 310; // Aumentado (antes 280) para acomodar pasivas adicionales
        const cardsPerRow = 1; // Una carta por fila para mejor legibilidad
        const cardSpacing = 15;
        const startX = (designWidth - cardWidth) / 2;
        const startY = 60;

        // Título principal (más grande para móviles)
        ctx.fillStyle = "#4A3728";
        ctx.font = "bold 32px 'Jacquard 24'"; // Aumentado de 28px a 32px
        ctx.textAlign = "center";
        ctx.fillText("Monster Codex", designWidth / 2, 35);

        // Calcular altura total real (incluye desplazamiento inicial y elimina el spacing final sobrante)
        const totalHeight =
          startY +
          monstersData.length * (cardHeight + cardSpacing) -
          cardSpacing;
        const headerHeight = 50;
        const footerHeight = 60;
        const contentAreaHeight = designHeight - headerHeight - footerHeight;
        const maxScrollY = Math.max(0, totalHeight - contentAreaHeight);

        // Limitar scroll
        bookScrollY = Math.max(0, Math.min(bookScrollY, maxScrollY));

        // Área de contenido con scroll - entre header y footer
        ctx.save();
        ctx.beginPath();
        ctx.rect(0, headerHeight, designWidth, contentAreaHeight);
        ctx.clip();

        monstersData.forEach((monster, index) => {
          const cardY =
            startY + index * (cardHeight + cardSpacing) - bookScrollY;

          // Solo dibujar cartas visibles
          if (cardY > -cardHeight - 50 && cardY < designHeight + 50) {
            drawMonsterCard(monster, startX, cardY, cardWidth, cardHeight);
          }
        });

        ctx.restore();

        // FOOTER FIJO
        const footerY = designHeight - footerHeight;

        // Fondo del footer - usar la misma textura que el background
        ctx.drawImage(
          bookBackgroundImg,
          0,
          footerY,
          designWidth,
          footerHeight,
          0,
          footerY,
          designWidth,
          footerHeight
        );

        // Botón Back centrado en el footer
        const backButtonWidth = 120;
        const backButtonHeight = 40;
        const backButtonX = (designWidth - backButtonWidth) / 2;
        const backButtonY = footerY + 10;

        ctx.drawImage(
          buttonLongBeigeImg,
          backButtonX,
          backButtonY,
          backButtonWidth,
          backButtonHeight
        );

        ctx.fillStyle = "#4A3728";
        ctx.font = "bold 16px 'Jersey 10'";
        ctx.textAlign = "center";
        ctx.fillText(
          "Back",
          backButtonX + backButtonWidth / 2,
          backButtonY + 25
        );

        // Indicador de scroll si es necesario (ajustado para el nuevo layout)
        if (maxScrollY > 0) {
          const scrollBarHeight = contentAreaHeight - 40;
          const scrollBarX = designWidth - 15;
          const scrollBarY = headerHeight + 20;
          const scrollPosition =
            (bookScrollY / maxScrollY) * (scrollBarHeight - 20);

          // Barra de scroll de fondo
          ctx.fillStyle = "rgba(74, 55, 40, 0.3)";
          ctx.fillRect(scrollBarX, scrollBarY, 8, scrollBarHeight);

          // Indicador de posición
          ctx.fillStyle = "#4A3728";
          ctx.fillRect(scrollBarX, scrollBarY + scrollPosition, 8, 20);
        }
      }

      function drawMonsterCard(monster, x, y, width, height) {
        // Border de la carta con esquinas redondeadas
        ctx.strokeStyle = "#4A3728"; // Marrón oscuro
        ctx.lineWidth = 3;

        // Crear path con esquinas redondeadas
        const radius = 10;
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(
          x + width,
          y + height,
          x + width - radius,
          y + height
        );
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.stroke();

        // PRIMERA FILA - 2 columnas
        const padding = 15;
        const firstRowHeight = 120; // Aumentado para más espacio

        // Columna 1: Sprite del enemigo (tamaño especial para Minotaur)
        let spriteSize = 80;
        if (monster.name.includes("Minotaur")) {
          spriteSize = 100; // Más grande para el Minotaur
        }
        const spriteX = x + padding;
        const spriteY = y + padding;

        if (monster.sprite) {
          // Calcular frame para animación idle
          const frame = Math.floor((currentTime * 8) % monster.idleFrames);
          const sx = frame * monster.frameWidth;
          const sy = 0; // Row 0 para idle normalmente

          ctx.drawImage(
            monster.sprite,
            sx,
            sy,
            monster.frameWidth,
            monster.frameHeight,
            spriteX,
            spriteY,
            spriteSize,
            spriteSize
          );
        }

        // Columna 2: Nombre y HP
        const textStartX = spriteX + spriteSize + 20;
        let currentY = y + padding + 15;

        // Nombre (en marrón oscuro, más grande)
        ctx.fillStyle = "#4A3728";
        ctx.font = "bold 26px 'Jersey 10'"; // Aumentado para mayor protagonismo
        ctx.textAlign = "left";
        ctx.fillText(monster.name, textStartX, currentY);
        currentY += 39; // Ajuste de espaciado acorde al nuevo tamaño

        // HP (más grande)
        ctx.fillStyle = "#B22222";
        ctx.font = "bold 18px 'Jersey 10'"; // Aumentado de 16px a 18px
        ctx.fillText(`HP: ${monster.hp}`, textStartX, currentY);
        currentY += 25;

        // Nivel donde aparece (nuevo)
        ctx.fillStyle = "#654321";
        ctx.font = "16px 'Jersey 10'";
        ctx.fillText(`Level: ${monster.level}`, textStartX, currentY);

        // SEGUNDA FILA - 1 columna completa
        const secondRowY = y + firstRowHeight + padding;
        const fullWidth = width - padding * 2;
        currentY = secondRowY;

        // Título "Abilities" (añadido de vuelta)
        ctx.fillStyle = "#4A3728";
        ctx.font = "bold 18px 'Jersey 10'"; // Más grande que antes
        ctx.fillText("Abilities:", x + padding, currentY);
        currentY += 25;

        // Habilidades (más grandes)
        ctx.fillStyle = "#4A3728";
        ctx.font = "16px 'Jersey 10'"; // Aumentado de 14px a 16px

        monster.abilities.forEach((ability) => {
          const abilityLines = wrapTextForCard(ability, fullWidth);
          abilityLines.forEach((line) => {
            ctx.fillText(`• ${line}`, x + padding, currentY);
            currentY += 18; // Aumentado el spacing
          });
        });

        // Espacio entre habilidades y lore
        currentY += 15;

        // Lore/Descripción (más grande)
        ctx.fillStyle = "#654321";
        ctx.font = "15px 'Jersey 10'"; // Aumentado de 13px a 15px
        const descLines = wrapTextForCard(monster.description, fullWidth);
        descLines.forEach((line) => {
          ctx.fillText(line, x + padding, currentY);
          currentY += 17; // Aumentado el spacing
        });
      }

      function wrapTextForCard(text, maxWidth) {
        const words = text.split(" ");
        const lines = [];
        let currentLine = "";

        for (let word of words) {
          const testLine = currentLine + (currentLine ? " " : "") + word;
          const metrics = ctx.measureText(testLine);

          if (metrics.width > maxWidth && currentLine) {
            lines.push(currentLine);
            currentLine = word;
          } else {
            currentLine = testLine;
          }
        }

        if (currentLine) {
          lines.push(currentLine);
        }

        return lines;
      }

      // Función auxiliar para envolver texto
      function wrapText(text, maxWidth) {
        const words = text.split(" ");
        const lines = [];
        let currentLine = "";

        for (let word of words) {
          const testLine = currentLine + (currentLine ? " " : "") + word;
          const metrics = ctx.measureText(testLine);

          if (metrics.width > maxWidth && currentLine) {
            lines.push(currentLine);
            currentLine = word;
          } else {
            currentLine = testLine;
          }
        }

        if (currentLine) {
          lines.push(currentLine);
        }

        return lines;
      }

      // Función para dibujar la pantalla de guía
      function drawGuide() {
        // Dibujar fondo usando la misma textura que el book
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(bookBackgroundImg, 0, 0, designWidth, designHeight);

        // Configuración de layout
        const headerHeight = 50;
        const footerHeight = 60;
        const contentAreaHeight = designHeight - headerHeight - footerHeight;

        // Título principal (más grande para móviles)
        ctx.fillStyle = "#4A3728";
        ctx.font = "bold 32px 'Jacquard 24'"; // Misma fuente que Monster Codex
        ctx.textAlign = "center";
        ctx.fillText("Game Guide", designWidth / 2, 35);

        // Contenido de la guía
        const guideContent = [
          {
            title: "🌀 Turn & Charge System",
            content:
              "Combat is turn-based through a shared charge queue. When a hero's bar fills, they may use ANY of their abilities (no individual energy costs). After using one, their bar resets. Enemies act the same way, one at a time.",
          },
          {
            title: "⏳ Status Durations",
            content:
              "Effects advance only on turn starts. Shadows: damages each turn (+1 per extra stack). Poison: 2 +1 per extra stack each turn. Regrowth: heals all allies 4–5 HP per turn (5 turns). Agony: +30% party defense (10 turns). Dark Protection: +20% enemy defense then +5% per extra stack.",
          },
          {
            title: "🏹 Enemy Attacks",
            content:
              "Enemies act when their charge bar fills. Bosses often prepare powerful specials after a set number of basic attacks—watch their patterns.",
          },
          {
            title: "💀 Special Abilities",
            content:
              "Some enemies prepare specials after a fixed number of actions (e.g., 3 attacks). Others (like bombs) only charge to unleash an explosion. The Abyss King summons after 3 Abyss Strikes. Plan around these timers.",
          },
          {
            title: "📈 Difficulty Progression",
            content:
              "Each level increases in difficulty with stronger enemies and more challenging encounters.",
          },
          {
            title: "🧠 Strategic Combat",
            content:
              "Use abilities at the right moment: finish low HP targets, stack Shadows/Poison efficiently, and time heals before enemy bursts.",
          },
          {
            title: "🧪 Debuffs & Effects",
            content: "", // Se renderiza como lista con iconos
          },
          {
            title: "⚔️ Hero Abilities",
            content: "",
          },
        ];

        // Hero abilities detailed info
        const heroAbilities = [
          {
            hero: "Mage",
            abilities: [
              "Fireblast: High single-target damage (never hits allies)",
              "Combustion: Increases critical chance for the NEXT damage ability only, then the buff is consumed",
              "Inferno: Lower single-target damage than Fireblast but hits ALL enemies (never allies)",
            ],
          },
          {
            hero: "Warlock",
            abilities: [
              "Dark Slash: Damage + applies 'Shadows' (damage every turn, +1 damage per extra stack)",
              "Agony: Grants party defense for 10 turns (no damage reflection)",
              "Immolation: Massive damage to all enemies but removes 60% of Warlock HP",
            ],
          },
          {
            hero: "Priest",
            abilities: [
              "Holy Wave: Strong single-target heal",
              "Smite: Moderate damage to one enemy",
              "Regrowth: Heals all allies 4–5 HP each turn for 5 turns",
            ],
          },
        ];

        // Calcular altura total del contenido
        const sectionSpacing = 25;
        const lineHeight = 20;
        const titleHeight = 30;
        let totalContentHeight = 0;

        // Simular el renderizado para calcular altura real
        ctx.font = "16px 'Jersey 10'"; // Establecer fuente para medición

        guideContent.forEach((section) => {
          totalContentHeight += titleHeight + 10;
          if (section.title === "🧪 Debuffs & Effects") {
            // Calcular dinámicamente las líneas de cada debuff (sin Protection eliminada)
            const debuffsList = [
              "Combustion: next damage ability high crit (consumed).",
              "Berseker: +3% attack per stack (max 30%).",
              "Shadows: stacking DoT (1 + extra per stack, 10 turns).",
              "Poison: 2 +1 per extra stack each turn (10 turns).",
              "Regrowth: heals all allies 4–5 HP/turn (5 turns).",
              "Agony: +30% party defense (10 turns).",
              "Dark Protection: +20% defense then +5% per stack (10 turns, enemies).",
              "Healing (icon): instant heal sources (no duration).",
            ];
            const textWidth = 280 - (20 + 8); // ancho restante tras icono
            debuffsList.forEach((t) => {
              const lines = wrapGuideText(t, textWidth);
              totalContentHeight += lines.length * lineHeight + 4; // gap
            });
            totalContentHeight += sectionSpacing;
          } else if (section.content) {
            const lines = wrapGuideText(section.content, 280);
            totalContentHeight += lines.length * lineHeight + sectionSpacing;
          }
        });

        // Añadir altura para las habilidades de héroes (cálculo más preciso)
        heroAbilities.forEach((hero) => {
          totalContentHeight += titleHeight + 10; // Título del héroe
          hero.abilities.forEach((ability) => {
            const lines = wrapGuideText(`• ${ability}`, 260);
            totalContentHeight += lines.length * lineHeight + 5;
          });
          totalContentHeight += sectionSpacing;
        });

        // Añadir padding extra al final para asegurar que se pueda hacer scroll hasta el final
        totalContentHeight += 40;

        const maxScrollY = Math.max(0, totalContentHeight - contentAreaHeight);
        guideScrollY = Math.max(0, Math.min(guideScrollY, maxScrollY));

        // Área de contenido con scroll
        ctx.save();
        ctx.beginPath();
        ctx.rect(0, headerHeight, designWidth, contentAreaHeight);
        ctx.clip();

        let currentY = headerHeight + 20 - guideScrollY;
        const contentX = 20;

        // Renderizar contenido de la guía
        guideContent.forEach((section) => {
          ctx.fillStyle = "#4A3728";
          ctx.font = "bold 22px 'Jersey 10'";
          ctx.textAlign = "left";
          ctx.fillText(section.title, contentX, currentY);
          currentY += titleHeight + 10;

          if (section.title === "🧪 Debuffs & Effects") {
            const debuffsList = [
              {
                icon: combustionDebuffImg,
                text: "Combustion: next damage ability high crit (consumed).",
              },
              {
                icon: bersekerDebuffImg,
                text: "Berseker: +3% attack per stack (max 30%).",
              },
              {
                icon: shadowsDebuffImg,
                text: "Shadows: stacking DoT (1 + extra per stack, 10 turns).",
              },
              {
                icon: poisonDebuffImg,
                text: "Poison: 2 +1 per extra stack each turn (10 turns).",
              },
              {
                icon: healingDebuffImg,
                text: "Regrowth: heals all allies 4–5 HP/turn (5 turns).",
              },
              {
                icon: agonyDebuffImg,
                text: "Agony: +30% party defense (10 turns).",
              },
              {
                icon: darkProtectionDebuffImg,
                text: "Dark Protection: +20% defense then +5% per stack (10 turns).",
              },
            ];
            const iconSize = 20;
            const textOffset = iconSize + 8;
            ctx.font = "16px 'Jersey 10'";
            ctx.fillStyle = "#654321";
            debuffsList.forEach((d) => {
              if (d.icon && d.icon.complete) {
                ctx.drawImage(
                  d.icon,
                  contentX + 5,
                  currentY - 16,
                  iconSize,
                  iconSize
                );
              }
              const lines = wrapGuideText(d.text, 280 - textOffset);
              lines.forEach((line, idx) => {
                ctx.fillText(line, contentX + 5 + textOffset, currentY);
                currentY += lineHeight;
              });
              currentY += 4;
            });
            currentY += sectionSpacing;
          } else if (section.content) {
            ctx.fillStyle = "#654321";
            ctx.font = "16px 'Jersey 10'";
            const lines = wrapGuideText(section.content, 280);
            lines.forEach((line) => {
              ctx.fillText(line, contentX + 15, currentY);
              currentY += lineHeight;
            });
            currentY += sectionSpacing;
          } else {
            currentY += sectionSpacing;
          }
        });

        // Renderizar habilidades de héroes
        heroAbilities.forEach((hero) => {
          ctx.fillStyle = "#4A3728";
          ctx.font = "bold 22px 'Jersey 10'"; // Mismo estilo que títulos de sección
          ctx.fillText(`${hero.hero}:`, contentX + 15, currentY);
          currentY += titleHeight;

          hero.abilities.forEach((ability) => {
            ctx.fillStyle = "#654321"; // Mismo color que el contenido
            ctx.font = "16px 'Jersey 10'"; // Misma fuente
            const lines = wrapGuideText(`• ${ability}`, 260);
            lines.forEach((line) => {
              ctx.fillText(line, contentX + 30, currentY);
              currentY += lineHeight;
            });
            currentY += 5;
          });
          currentY += sectionSpacing;
        });

        ctx.restore();

        // FOOTER con el mismo estilo que el Book
        const footerY = designHeight - footerHeight;

        // Fondo del footer usando la misma textura
        ctx.drawImage(
          bookBackgroundImg,
          0,
          footerY,
          designWidth,
          footerHeight,
          0,
          footerY,
          designWidth,
          footerHeight
        );

        // Botón Back centrado en el footer
        const backButtonWidth = 120;
        const backButtonHeight = 40;
        const backButtonX = (designWidth - backButtonWidth) / 2;
        const backButtonY = footerY + 10;

        ctx.drawImage(
          buttonLongBeigeImg,
          backButtonX,
          backButtonY,
          backButtonWidth,
          backButtonHeight
        );

        ctx.fillStyle = "#4A3728";
        ctx.font = "bold 16px 'Jersey 10'";
        ctx.textAlign = "center";
        ctx.fillText(
          "Back",
          backButtonX + backButtonWidth / 2,
          backButtonY + 25
        );

        // Indicador de scroll si es necesario
        if (maxScrollY > 0) {
          const scrollBarHeight = contentAreaHeight - 40;
          const scrollBarX = designWidth - 15;
          const scrollBarY = headerHeight + 20;
          const scrollPosition =
            (guideScrollY / maxScrollY) * (scrollBarHeight - 20);

          // Barra de scroll de fondo
          ctx.fillStyle = "rgba(74, 55, 40, 0.3)";
          ctx.fillRect(scrollBarX, scrollBarY, 8, scrollBarHeight);

          // Indicador de posición
          ctx.fillStyle = "#4A3728";
          ctx.fillRect(scrollBarX, scrollBarY + scrollPosition, 8, 20);
        }
      }

      // Función auxiliar para envolver texto en la guía
      function wrapGuideText(text, maxWidth) {
        const words = text.split(" ");
        const lines = [];
        let currentLine = "";

        for (let word of words) {
          const testLine = currentLine + (currentLine ? " " : "") + word;
          const metrics = ctx.measureText(testLine);

          if (metrics.width > maxWidth && currentLine) {
            lines.push(currentLine);
            currentLine = word;
          } else {
            currentLine = testLine;
          }
        }

        if (currentLine) {
          lines.push(currentLine);
        }

        return lines;
      }

      /* =============================
      INPUT: Canvas Events
      ============================= */
      canvas.addEventListener("touchstart", handleInput);
      canvas.addEventListener("touchmove", handleTouchMove);
      canvas.addEventListener("touchend", handleTouchEnd);
      canvas.addEventListener("click", handleInput);
      canvas.addEventListener("wheel", handleWheel);

      function handleTouchMove(e) {
        e.preventDefault();
        if (state === "book" && isDragging) {
          const rect = canvas.getBoundingClientRect();
          const touchY =
            (e.touches[0].clientY - rect.top) * (designHeight / rect.height);

          const deltaY = lastTouchY - touchY;
          const monstersCount = 11;
          const cardHeight = 280;
          const cardSpacing = 15;
          const totalHeight = monstersCount * (cardHeight + cardSpacing);
          const headerHeight = 50;
          const footerHeight = 60;
          const contentAreaHeight = designHeight - headerHeight - footerHeight;
          const maxScrollY = Math.max(0, totalHeight - contentAreaHeight);

          bookScrollY = Math.max(0, Math.min(maxScrollY, bookScrollY + deltaY));
          lastTouchY = touchY;
        }

        if (state === "guide" && isDragging) {
          const rect = canvas.getBoundingClientRect();
          const touchY =
            (e.touches[0].clientY - rect.top) * (designHeight / rect.height);
          const deltaY = lastTouchY - touchY;
          // Recalcular contenido real usando las mismas estructuras que drawGuide
          const sectionSpacing = 25;
          const lineHeight = 20;
          const titleHeight = 30;
          // Reconstruir arrays mínimos (títulos y contenido) para medir
          const guideContentLocal = [
            { title: "🌀 Turn & Charge System" },
            { title: "⏳ Status Durations" },
            { title: "🏹 Enemy Attacks" },
            { title: "💀 Special Abilities" },
            { title: "📈 Difficulty Progression" },
            { title: "🧠 Strategic Combat" },
            { title: "🧪 Debuffs & Effects" },
            { title: "⚔️ Hero Abilities" },
          ];
          // Calcular altura de secciones (excepto debuffs tratada aparte)
          let totalContentHeight = 0;
          ctx.font = "16px 'Jersey 10'";
          guideContentLocal.forEach((sec) => {
            totalContentHeight += titleHeight + 10; // título
            if (sec.title === "🧪 Debuffs & Effects") {
              const debuffTexts = [
                "Combustion: next damage ability high crit (consumed).",
                "+3% attack per stack (Berseker, max 30%).",
                "Shadows: stacking DoT (1 + extra per stack, 10 turns).",
                "Poison: 2 +1 per extra stack each turn (10 turns).",
                "Regrowth: heals all allies 4–5 HP/turn (5 turns).",
                "Agony: +30% party defense (10 turns).",
                "Dark Protection: +20% then +5% per stack (10 turns).",
                "Healing: instant heal (no duration).",
              ];
              const textWidth = 280 - (20 + 8);
              debuffTexts.forEach((t) => {
                const lines = wrapGuideText(t, textWidth);
                totalContentHeight += lines.length * lineHeight + 4;
              });
              totalContentHeight += sectionSpacing;
            } else if (sec.title !== "⚔️ Hero Abilities") {
              // Aproximar líneas de cada sección (volver a usar wrapGuideText copiando texto real sería mejor, pero mantenemos estimación ligera)
              // Para asegurar scroll suficiente añadimos margen generoso.
              totalContentHeight += 5 * lineHeight + sectionSpacing; // colchón
            } else {
              // se manejarán habilidades abajo
            }
          });
          // Habilidades de héroes (medir real con nombres y 3 abilities)
          const heroAbilitiesLocal = [
            ["Fireblast", "Combustion", "Inferno"],
            ["Dark Slash", "Agony", "Immolation"],
            ["Holy Wave", "Smite", "Regrowth"],
          ];
          heroAbilitiesLocal.forEach((list) => {
            totalContentHeight += titleHeight + 10; // título héroe
            list.forEach((name) => {
              const lines = wrapGuideText(`• ${name}`, 260);
              totalContentHeight += lines.length * lineHeight + 5;
            });
            totalContentHeight += sectionSpacing;
          });
          totalContentHeight += 80; // padding extra para asegurar llegada al final
          const headerHeight = 50;
          const footerHeight = 60;
          const contentAreaHeight = designHeight - headerHeight - footerHeight;
          const maxScrollY = Math.max(
            0,
            totalContentHeight - contentAreaHeight
          );
          guideScrollY = Math.max(
            0,
            Math.min(maxScrollY, guideScrollY + deltaY)
          );
          lastTouchY = touchY;
        }
      }

      function handleTouchEnd(e) {
        e.preventDefault();
        isDragging = false;
      }

      function handleWheel(e) {
        e.preventDefault();
        if (state === "book") {
          const monstersCount = 11; // Total de monstruos (mantener sincronizado con monstersData)
          const startY = 60; // Mismo offset usado en drawMonsterBook
          const cardHeight = 310; // Altura actualizada de la carta
          const cardSpacing = 15; // Espaciado entre cartas
          // Altura total real incluyendo offset inicial y sin sumar spacing al final
          const totalHeight =
            startY + monstersCount * (cardHeight + cardSpacing) - cardSpacing;
          const headerHeight = 50;
          const footerHeight = 60;
          const contentAreaHeight = designHeight - headerHeight - footerHeight;
          const maxScrollY = Math.max(0, totalHeight - contentAreaHeight);

          if (e.deltaY > 0) {
            // Scroll hacia abajo
            bookScrollY = Math.min(maxScrollY, bookScrollY + bookScrollSpeed);
          } else {
            // Scroll hacia arriba
            bookScrollY = Math.max(0, bookScrollY - bookScrollSpeed);
          }
        }

        if (state === "guide") {
          const sectionSpacing = 25;
          const lineHeight = 20;
          const titleHeight = 30;
          const debuffTexts = [
            "Combustion: next damage ability high crit (consumed).",
            "+3% attack per stack (Berseker, max 30%).",
            "Shadows: stacking DoT (1 + extra per stack, 10 turns).",
            "Poison: 2 +1 per extra stack each turn (10 turns).",
            "Regrowth: heals all allies 4–5 HP/turn (5 turns).",
            "Agony: +30% party defense (10 turns).",
            "Dark Protection: +20% then +5% per stack (10 turns).",
            "Healing: instant heal (no duration).",
          ];
          ctx.font = "16px 'Jersey 10'";
          let totalContentHeight = 0;
          // Secciones fijas (6 normales + debuffs + hero header)
          const normalSections = 6;
          for (let i = 0; i < normalSections; i++) {
            totalContentHeight +=
              titleHeight + 10 + 5 * lineHeight + sectionSpacing; // colchón
          }
          // Debuffs
          totalContentHeight += titleHeight + 10; // título debuffs
          const textWidth = 280 - (20 + 8);
          debuffTexts.forEach((t) => {
            const lines = wrapGuideText(t, textWidth);
            totalContentHeight += lines.length * lineHeight + 4;
          });
          totalContentHeight += sectionSpacing;
          // Hero abilities header
          totalContentHeight += titleHeight + 10;
          const heroAbilityNames = [
            ["Fireblast", "Combustion", "Inferno"],
            ["Dark Slash", "Agony", "Immolation"],
            ["Holy Wave", "Smite", "Regrowth"],
          ];
          heroAbilityNames.forEach((list) => {
            totalContentHeight += titleHeight + 10;
            list.forEach((n) => {
              const lines = wrapGuideText(`• ${n}`, 260);
              totalContentHeight += lines.length * lineHeight + 5;
            });
            totalContentHeight += sectionSpacing;
          });
          totalContentHeight += 80; // padding extra
          const headerHeight = 50;
          const footerHeight = 60;
          const contentAreaHeight = designHeight - headerHeight - footerHeight;
          const maxScrollY = Math.max(
            0,
            totalContentHeight - contentAreaHeight
          );
          if (e.deltaY > 0) {
            guideScrollY = Math.min(maxScrollY, guideScrollY + bookScrollSpeed);
          } else {
            guideScrollY = Math.max(0, guideScrollY - bookScrollSpeed);
          }
        }
      }

      function handleInput(e) {
        e.preventDefault();

        // Inicializar audio en el primer clic del usuario
        initializeAudio();

        const rect = canvas.getBoundingClientRect();
        let clientX, clientY;

        if (e.type === "touchstart") {
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
        } else {
          clientX = e.clientX;
          clientY = e.clientY;
        }

        const touchX = (clientX - rect.left) * (designWidth / rect.width);
        const touchY = (clientY - rect.top) * (designHeight / rect.height);

        // Manejar clics en el menú principal
        if (state === "main_menu") {
          // NO reproducir música en el menú principal

          // Coordenadas de los nuevos botones estilo habilidades
          const buttonWidth = 200;
          const buttonHeight = 40;
          const buttonSpacing = 20;
          const startY = 350;
          const buttonX = (designWidth - buttonWidth) / 2;

          // Verificar clic en botón Start
          const startButtonY = startY;
          if (
            touchX >= buttonX &&
            touchX <= buttonX + buttonWidth &&
            touchY >= startButtonY &&
            touchY <= startButtonY + buttonHeight
          ) {
            console.log("Start button clicked");
            startGame();
            return;
          }

          // Verificar clic en botón Guide
          const guideButtonY = startY + buttonHeight + buttonSpacing;
          if (
            touchX >= buttonX &&
            touchX <= buttonX + buttonWidth &&
            touchY >= guideButtonY &&
            touchY <= guideButtonY + buttonHeight
          ) {
            console.log("Guide button clicked");
            state = "guide";
            guideScrollY = 0; // Reset scroll al abrir la guía
            // Mantener música del menú para Guide
            return;
          }

          // Verificar clic en botón Book
          const bookButtonY = startY + 2 * (buttonHeight + buttonSpacing);
          if (
            touchX >= buttonX &&
            touchX <= buttonX + buttonWidth &&
            touchY >= bookButtonY &&
            touchY <= bookButtonY + buttonHeight
          ) {
            console.log("Book button clicked");
            state = "book";
            bookScrollY = 0; // Resetear scroll al abrir el libro
            // Mantener música del menú para Book
            return;
          }

          // Botón Dev L4 eliminado
        }

        // Manejar clics en la pantalla de información de nivel
        if (state === "level_info") {
          const buttonY = 420;
          const buttonWidth = 200;
          const buttonHeight = 40;
          const buttonX = (designWidth - buttonWidth) / 2;

          // Verificar clic en botón "Enter the Dungeon"
          if (
            touchX >= buttonX &&
            touchX <= buttonX + buttonWidth &&
            touchY >= buttonY &&
            touchY <= buttonY + buttonHeight
          ) {
            console.log("Enter the Dungeon button clicked");
            // Asegurar que el modal anterior no reaparezca
            if (levelCompletionModal.show) {
              levelCompletionModal.show = false;
            }
            // Seguridad: si venimos del nivel 3 y currentLevel es 4, garantizar wave múltiplo de 3
            if (currentLevel === 4 && wave % 3 !== 0) {
              // Forzar a 9 (justo antes de iniciar wave 1 de nivel 4) sin retroceder puntuación
              wave = 9;
            }
            state = "select_hero";
            startWave(); // Empezar la primera wave del nivel
            return;
          }
        }

        // Manejar clics en modal de fin de nivel
        if (state === "level_completion" && levelCompletionModal.show) {
          const modalW = 300;
          const modalH = 200;
          const modalX = (designWidth - modalW) / 2;
          const modalY = (designHeight - modalH) / 2 - 40;
          const btnW = 120;
          const btnH = 36;
          // Debe coincidir con la posición usada al dibujar (modalY + modalH - 50)
          const btnY = modalY + modalH - 50;
          const continueX = designWidth / 2 - btnW - 10;
          const surrenderX = designWidth / 2 + 10;

          // Click en Continue
          if (
            touchX >= continueX &&
            touchX <= continueX + btnW &&
            touchY >= btnY &&
            touchY <= btnY + btnH
          ) {
            console.log("Continue clicked -> next level info");
            // Preparar pantalla de información del siguiente nivel
            currentLevel = levelCompletionModal.level + 1;
            state = "level_info";
            levelCompletionModal.show = false;
            pendingLevelInfo = false; // Ya vamos directamente a la pantalla
            return;
          }

          // Click en Surrender
          if (
            touchX >= surrenderX &&
            touchX <= surrenderX + btnW &&
            touchY >= btnY &&
            touchY <= btnY + btnH
          ) {
            console.log("Surrender clicked -> game over");
            handleGameOver();
            return;
          }
        }

        // Manejar clics en la pantalla del libro de monstruos
        if (state === "book") {
          // NO reproducir música en book

          // Inicializar drag para scroll táctil
          if (e.type === "touchstart") {
            isDragging = true;
            lastTouchY = touchY;
          }

          // Botón de volver (centrado en el footer)
          const backButtonWidth = 120;
          const backButtonHeight = 40;
          const footerHeight = 60;
          const backButtonX = (designWidth - backButtonWidth) / 2;
          const backButtonY = designHeight - footerHeight + 10;

          if (
            touchX >= backButtonX &&
            touchX <= backButtonX + backButtonWidth &&
            touchY >= backButtonY &&
            touchY <= backButtonY + backButtonHeight
          ) {
            console.log("Back button clicked");
            state = "main_menu";
            isDragging = false; // Cancelar drag al hacer clic en botón
            return;
          }

          return;
        }

        // Manejar clics en la pantalla de guía
        if (state === "guide") {
          // NO reproducir música en guide

          // Inicializar drag para scroll táctil
          if (e.type === "touchstart") {
            isDragging = true;
            lastTouchY = touchY;
          }

          // Botón de volver (centrado en el footer)
          const backButtonWidth = 120;
          const backButtonHeight = 40;
          const footerHeight = 60;
          const backButtonX = (designWidth - backButtonWidth) / 2;
          const backButtonY = designHeight - footerHeight + 10;

          if (
            touchX >= backButtonX &&
            touchX <= backButtonX + backButtonWidth &&
            touchY >= backButtonY &&
            touchY <= backButtonY + backButtonHeight
          ) {
            console.log("Guide Back button clicked");
            state = "main_menu";
            isDragging = false; // Cancelar drag al hacer clic en botón
            return;
          }

          // Manejo de scroll vertical (tocar arriba o abajo de la pantalla)
          const scrollZoneHeight = 100;
          if (touchY < scrollZoneHeight) {
            // Scroll hacia arriba
            bookScrollY = Math.max(0, bookScrollY - bookScrollSpeed);
          } else if (touchY > designHeight - scrollZoneHeight) {
            // Scroll hacia abajo
            const monstersCount = 11; // Total de monstruos
            const cardHeight = 280; // Actualizado al nuevo tamaño
            const cardSpacing = 15; // Actualizado al nuevo spacing
            const totalHeight = monstersCount * (cardHeight + cardSpacing);
            const headerHeight = 50;
            const footerHeight = 60;
            const contentAreaHeight =
              designHeight - headerHeight - footerHeight;
            const maxScrollY = Math.max(0, totalHeight - contentAreaHeight);
            bookScrollY = Math.min(maxScrollY, bookScrollY + bookScrollSpeed);
          }
          return;
        }

        // Interacciones de modal de fin de nivel deshabilitadas (SDK)
        if (state === "level_completion" && levelCompletionModal.show) return;

        // Detección botón NEXT (puede estar por encima de 520)
        if (state === "select_hero") {
          const warlock = heroes.find((h) => h.clazz === "warlock");
          if (warlock && warlock.nextTurnButton) {
            const nb = warlock.nextTurnButton;
            if (
              touchX >= nb.x &&
              touchX <= nb.x + nb.w &&
              touchY >= nb.y &&
              touchY <= nb.y + nb.h
            ) {
              if (!heroInputLocked && !waveTransition.active) {
                forceAdvanceTurn();
              }
              return;
            }
          }
        }

        // Footer buttons zona principal
        if (touchY >= 520 && state === "select_hero") {
          if (
            heroInputLocked ||
            waveTransition.active ||
            enemies.every((e) => e.hp <= 0)
          ) {
            // Ignorar input de habilidades durante transición / spawn / wave completada
            return;
          }
          // Actualizado de 540 a 520
          const columnWidth = designWidth / 3;
          const heroOrder = ["mage", "warlock", "priest"];

          heroOrder.forEach((heroClass, heroIndex) => {
            const hero = heroes.find((h) => h.clazz === heroClass);
            if (!hero || hero.hp <= 0) return;

            const actions = Object.keys(classActions[hero.clazz]);
            const columnX = heroIndex * columnWidth;

            // Configuración de botones para coincidir con drawFooter
            const panelWidth = columnWidth - 5; // Actualizado
            const panelX = columnX + 2.5; // Actualizado
            const buttonWidth = panelWidth - 14;
            const buttonHeight = 25; // Actualizado de 23 a 25
            const buttonX = panelX + 7;
            const buttonSpacing = 2; // Actualizado de 1 a 2

            // Botón habilidad principal (1 carga)
            const primaryY = 550; // Actualizado de 567 a 550
            if (
              touchX >= buttonX &&
              touchX <= buttonX + buttonWidth &&
              touchY >= primaryY &&
              touchY <= primaryY + buttonHeight
            ) {
              const action = actions[0];
              const actionData = classActions[hero.clazz][action];
              const canUse =
                hero.charge >= actionData.reqCharge &&
                hero.hp > 0 &&
                turnQueue.length > 0 &&
                turnQueue[0] === hero &&
                !enemies.every((e) => e.hp <= 0); // No permitir acciones si todos los enemigos están muertos

              if (canUse) {
                selectedHero = hero;
                selectedAction = action;

                const actionType = actionData.type;
                if (actionType === "single_enemy") {
                  state = "select_target_enemy";
                } else if (actionType === "single_ally") {
                  state = "select_target_ally";
                } else if (actionType === "all_enemy") {
                  if (
                    executeAction(
                      selectedHero,
                      action,
                      enemies.filter((e) => e.hp > 0)
                    )
                  ) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                } else if (actionType === "all_ally") {
                  if (
                    executeAction(
                      selectedHero,
                      action,
                      heroes.filter((h) => h.hp > 0)
                    )
                  ) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                } else if (actionType === "self") {
                  if (executeAction(selectedHero, action, selectedHero)) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                }
              }
            }

            // Botón habilidad secundaria (2 cargas)
            const secondaryY = primaryY + buttonHeight + buttonSpacing;
            if (
              touchX >= buttonX &&
              touchX <= buttonX + buttonWidth &&
              touchY >= secondaryY &&
              touchY <= secondaryY + buttonHeight
            ) {
              const action = actions[1];
              const actionData = classActions[hero.clazz][action];
              const canUse =
                hero.charge >= actionData.reqCharge &&
                hero.hp > 0 &&
                turnQueue.length > 0 &&
                turnQueue[0] === hero &&
                !enemies.every((e) => e.hp <= 0); // No permitir acciones si todos los enemigos están muertos

              if (canUse) {
                selectedHero = hero;
                selectedAction = action;

                const actionType = actionData.type;
                if (actionType === "single_enemy") {
                  state = "select_target_enemy";
                } else if (actionType === "single_ally") {
                  state = "select_target_ally";
                } else if (actionType === "all_enemy") {
                  if (
                    executeAction(
                      selectedHero,
                      action,
                      enemies.filter((e) => e.hp > 0)
                    )
                  ) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                } else if (actionType === "all_ally") {
                  if (
                    executeAction(
                      selectedHero,
                      action,
                      heroes.filter((h) => h.hp > 0)
                    )
                  ) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                } else if (actionType === "self") {
                  if (executeAction(selectedHero, action, selectedHero)) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                }
              }
            }

            // Botón habilidad terciaria (3 cargas)
            const tertiaryY = secondaryY + buttonHeight + buttonSpacing;
            if (
              touchX >= buttonX &&
              touchX <= buttonX + buttonWidth &&
              touchY >= tertiaryY &&
              touchY <= tertiaryY + buttonHeight
            ) {
              const action = actions[2];
              const actionData = classActions[hero.clazz][action];
              const canUse =
                hero.charge >= actionData.reqCharge &&
                hero.hp > 0 &&
                turnQueue.length > 0 &&
                turnQueue[0] === hero &&
                !enemies.every((e) => e.hp <= 0); // No permitir acciones si todos los enemigos están muertos

              if (canUse) {
                selectedHero = hero;
                selectedAction = action;

                const actionType = actionData.type;
                if (actionType === "single_enemy") {
                  state = "select_target_enemy";
                } else if (actionType === "single_ally") {
                  state = "select_target_ally";
                } else if (actionType === "all_enemy") {
                  if (
                    executeAction(
                      selectedHero,
                      action,
                      enemies.filter((e) => e.hp > 0)
                    )
                  ) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                } else if (actionType === "all_ally") {
                  if (
                    executeAction(
                      selectedHero,
                      action,
                      heroes.filter((h) => h.hp > 0)
                    )
                  ) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                } else if (actionType === "self") {
                  if (executeAction(selectedHero, action, selectedHero)) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                }
              }
            }
          });
          return;
        }

        if (state === "select_hero") {
          heroes.forEach((h) => {
            if (
              h.hp > 0 &&
              Math.abs(touchX - h.posx) < 40 &&
              Math.abs(touchY - h.posy) < 40
            ) {
              // No necesitamos cambiar el estado aquí, solo usamos los botones del footer
              console.log("Hero clicked:", h.clazz);
            }
          });
        } else if (state === "select_target_enemy") {
          let targetClicked = false;
          enemies.forEach((e) => {
            const size = e.size || 80;
            if (
              e.hp > 0 &&
              Math.abs(touchX - e.posx) < size / 2 &&
              Math.abs(touchY - e.posy) < size / 2
            ) {
              if (executeAction(selectedHero, selectedAction, e)) {
                // No resetear selectedHero aquí, se resetea en applyEffect
                // NO cambiar estado a "animate" para permitir clicks rápidos
                // state = "animate";
              }
              targetClicked = true;
            }
          });

          // Si no se hizo clic en ningún enemigo, cerrar el modal
          if (!targetClicked) {
            state = "select_hero";
            if (selectedHero) {
              selectedHero.anim = "idle";
              selectedHero.frame = 0;
              selectedHero.animTime = 0;
            }
            selectedHero = null;
            selectedAction = null;
          }
        } else if (state === "select_target_ally") {
          let targetClicked = false;
          heroes.forEach((h) => {
            if (
              Math.abs(touchX - h.posx) < 40 &&
              Math.abs(touchY - h.posy) < 40
            ) {
              if (executeAction(selectedHero, selectedAction, h)) {
                // No resetear selectedHero aquí, se resetea en applyEffect
                // NO cambiar estado a "animate" para permitir clicks rápidos
                // state = "animate";
              }
              targetClicked = true;
            }
          });

          // Si no se hizo clic en ningún aliado, cerrar el modal
          if (!targetClicked) {
            state = "select_hero";
            if (selectedHero) {
              selectedHero.anim = "idle";
              selectedHero.frame = 0;
              selectedHero.animTime = 0;
            }
            selectedHero = null;
            selectedAction = null;
          }
        }
      }

      function resetGame() {
        state = "main_menu";
        currentLevel = 1;
        wave = 0;
        score = 0;
        levelCompletionModal = { show: false, level: 0, boss: "", timer: 0 };
        selectedHero = null;
        selectedAction = null;
        heroes = [];
        enemies = [];
        hitNumbers = [];
        visualEffects = [];
        pendingSounds = []; // Limpiar sonidos pendientes
        // La música se maneja en handleInput cuando se cambia a main_menu
      }

      // ================================
      // FARCADE SDK HELPER FUNCTIONS
      // ================================

      function triggerHapticFeedback() {
        if (window.FarcadeSDK) {
          window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
        }
      }

      // ================================
      // FARCADE SDK INTEGRATION
      // ================================

      // Manejar solicitudes de "play again" desde Farcade
      if (window.FarcadeSDK) {
        window.FarcadeSDK.on("play_again", () => {
          resetGame();
        });

        // Manejar mute/unmute desde Farcade
        window.FarcadeSDK.on("toggle_mute", (data) => {
          if (data.isMuted) {
            // Pausar toda la música
            [menuMusic, level1Music, level2Music, level3Music].forEach(
              (music) => {
                music.muted = true;
              }
            );
          } else {
            // Reanudar la música
            [menuMusic, level1Music, level2Music, level3Music].forEach(
              (music) => {
                music.muted = false;
              }
            );
          }
        });
      }

      Promise.all([
        new Promise((r) => (backgroundImg.onload = r)),
        new Promise((r) => (backgroundLevel2Img.onload = r)),
        new Promise((r) => (mageImg.onload = r)),
        new Promise((r) => (priestImg.onload = r)),
        new Promise((r) => (warlockImg.onload = r)),
        new Promise((r) => (demonBatIdleImg.onload = r)),
        new Promise((r) => (demonBatDeathImg.onload = r)),
        new Promise((r) => (demonBatAttackImg.onload = r)),
        new Promise((r) => (wormIdleImg.onload = r)),
        new Promise((r) => (wormDeathImg.onload = r)),
        new Promise((r) => (wormAttackImg.onload = r)),
        new Promise((r) => (bossBatIdleImg.onload = r)),
        new Promise((r) => (bossBatDeathImg.onload = r)),
        new Promise((r) => (bossBatAttackImg.onload = r)),
        new Promise((r) => (mushroomIdleImg.onload = r)),
        new Promise((r) => (mushroomDeathImg.onload = r)),
        new Promise((r) => (dreadwingIdleImg.onload = r)),
        new Promise((r) => (dreadwingDeathImg.onload = r)),
        new Promise((r) => (swampGorgonIdleImg.onload = r)),
        new Promise((r) => (swampGorgonAttackImg.onload = r)),
        new Promise((r) => (swampGorgonSpecialAttackImg.onload = r)),
        new Promise((r) => (swampGorgonDeathImg.onload = r)),
        new Promise((r) => (bloodSplatImg.onload = r)),
        new Promise((r) => (enemyImg.onload = r)),
        new Promise((r) => (goblinIdleImg.onload = r)),
        new Promise((r) => (goblinDieImg.onload = r)),
        new Promise((r) => (effectsImg.onload = r)),
        new Promise((r) => (purpleEffectsImg.onload = r)),
        new Promise((r) => (healingEffectsImg.onload = r)),
        new Promise((r) => (lightningEffectsImg.onload = r)),
        new Promise((r) => (darkBoltEffectsImg.onload = r)),
        new Promise((r) => (bloodSplatEffectsImg.onload = r)),
        new Promise((r) => (bloodStormEffectsImg.onload = r)),
        new Promise((r) => (priestSmiteEffectsImg.onload = r)),
        new Promise((r) => (priestHolyWaveEffectsImg.onload = r)),
        new Promise((r) => (priestRegrowthEffectsImg.onload = r)),
        new Promise((r) => (minotaurSmashEffectsImg.onload = r)),
        new Promise((r) => (minotaurLifeStealEffectsImg.onload = r)),
        new Promise((r) => (combustionEffectsImg.onload = r)),
        new Promise((r) => (cthuluMainEffectsImg.onload = r)),
        new Promise((r) => (cthuluSpecialEffectsImg.onload = r)),
        new Promise((r) => (healingDebuffImg.onload = r)),
        new Promise((r) => (protectionDebuffImg.onload = r)),
        new Promise((r) => (combustionDebuffImg.onload = r)),
        new Promise((r) => (bersekerDebuffImg.onload = r)),
        new Promise((r) => (poisonDebuffImg.onload = r)),
        new Promise((r) => (shadowsDebuffImg.onload = r)),
        new Promise((r) => (agonyDebuffImg.onload = r)),
        new Promise((r) => (darkProtectionDebuffImg.onload = r)),
        new Promise((r) => (panelBrownImg.onload = r)),
        new Promise((r) => (panelBeigeImg.onload = r)),
        new Promise((r) => (buttonLongBeigeImg.onload = r)),
        new Promise((r) => (buttonLongBrownImg.onload = r)),
        new Promise((r) => (buttonRoundBeigeImg.onload = r)),
        new Promise((r) => (iconCrossBrownImg.onload = r)),
        new Promise((r) => (mainMenuImg.onload = r)),
        new Promise((r) => (bookBackgroundImg.onload = r)),
        new Promise((r) => (level1InfoBg.onload = r)),
        new Promise((r) => (level2InfoBg.onload = r)),
        new Promise((r) => (level3InfoBg.onload = r)),
        new Promise((r) => (backgroundLevel4Img.onload = r)),
        new Promise((r) => (level4InfoBg.onload = r)),
      ]).then(() => {
        // Asegurar que empezamos en el menú principal
        state = "main_menu";
        // NO reproducir música al cargar - solo al pulsar START

        // Notificar al SDK de Farcade que el juego está listo
        if (window.FarcadeSDK) {
          window.FarcadeSDK.singlePlayer.actions.ready();
        }

        requestAnimationFrame(loop);
      });
    </script>
  </body>
</html>
