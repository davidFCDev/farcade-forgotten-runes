<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width,             img: priestImg,
            animations: animationsPriest,
            frameW: 44,
            frameH: 64,
            size: 100,al-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>RPG Battle Game</title>
    <script src="https://cdn.jsdelivr.net/npm/@farcade/game-sdk@latest/dist/index.min.js"></script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Jacquard+24&family=Jersey+10&display=swap");

      body {
        margin: 0;
        padding: 0;
        background: black;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        font-family: "Press Start 2P", monospace;
        overflow: hidden; /* Evitar scrollbars */
      }
      canvas {
        display: block;
        image-rendering: pixelated;
        max-width: 100vw;
        max-height: 100vh;
        width: auto;
        height: auto;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const designWidth = 360;
      const designHeight = 640;
      const screenCenterX = designWidth / 2; // Centro exacto de pantalla: 180px

      // Constantes de layout para áreas fijas
      const HEADER_HEIGHT = 60;
      const FOOTER_HEIGHT = 120;
      const FOOTER_Y = 520;
      const GAME_AREA_Y = HEADER_HEIGHT;
      const GAME_AREA_HEIGHT = FOOTER_Y - HEADER_HEIGHT; // 460px de área de juego

      const dpr = window.devicePixelRatio || 1;

      // Función para calcular el tamaño responsivo del canvas
      function calculateCanvasSize() {
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;

        // Calcular la escala manteniendo la proporción del diseño original (360x640)
        const designAspectRatio = designWidth / designHeight;
        const windowAspectRatio = windowWidth / windowHeight;

        let canvasWidth, canvasHeight;

        if (windowAspectRatio > designAspectRatio) {
          // La ventana es más ancha que el diseño, escalar por altura
          canvasHeight = Math.min(windowHeight * 0.95, designHeight); // 95% de la altura de la ventana
          canvasWidth = canvasHeight * designAspectRatio;
        } else {
          // La ventana es más alta que el diseño, escalar por anchura
          canvasWidth = Math.min(windowWidth * 0.95, designWidth); // 95% del ancho de la ventana
          canvasHeight = canvasWidth / designAspectRatio;
        }

        return { width: canvasWidth, height: canvasHeight };
      }

      // Función para redimensionar el canvas
      function resizeCanvas() {
        const size = calculateCanvasSize();

        canvas.width = designWidth * dpr;
        canvas.height = designHeight * dpr;
        ctx.scale(dpr, dpr);
        canvas.style.width = size.width + "px";
        canvas.style.height = size.height + "px";
      }

      // Configurar tamaño inicial del canvas
      resizeCanvas();

      // Redimensionar cuando cambie el tamaño de la ventana
      window.addEventListener("resize", resizeCanvas);

      // Load images
      const backgroundImg = new Image();
      backgroundImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ChatGPT%20Image%2010%20ago%202025%2C%2001_31_21-11GclhftpsCG06vNEd4ri4gVBVUY8o.png?aymA";

      // Background para nivel 2
      const backgroundLevel2Img = new Image();
      backgroundLevel2Img.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/red_dunes-elmz1XktqRUANSNvvj8jYAoxXZsMkt.png?t9TH";

      // Background para nivel 3
      const backgroundLevel3Img = new Image();
      backgroundLevel3Img.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/dark_swamp-eMmE7CgLp4Bx3xpLSgXlriVLfXN325.png?opu2";

      // Background para pantallas de información de nivel
      const levelInfoBackgroundImg = new Image();
      levelInfoBackgroundImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/crypt-PNZ7duhJjKjlUmf5WnW33JBy22gVjQ.png?OGU6"; // Default level 1

      // Backgrounds específicos para cada nivel de información
      const level1InfoBg = new Image();
      level1InfoBg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/crypt-PNZ7duhJjKjlUmf5WnW33JBy22gVjQ.png?OGU6";

      const level2InfoBg = new Image();
      level2InfoBg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/dunes-xdPuf2QdTX1Om2RDjw8ZE5iXg0Hfi2.png?j2E8";

      const level3InfoBg = new Image();
      level3InfoBg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/swamp-KN7CGHBBios5G8hfhno211L3BQpjao.png?Cv7i";

      // Background para pantalla de inicio
      const mainMenuImg = new Image();
      mainMenuImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/fondo_start-8ed4QcpKSo1dG5ASd0fGjy1p66Cwll.png?Ouaf";

      // Background para el Book
      const bookBackgroundImg = new Image();
      bookBackgroundImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/fondo_book-AN2QslDiEGnJY1esoB29QQ8JlzX3Uq.png?6KnD";

      // Background dinámico que cambia según el nivel
      let currentBackgroundImg = backgroundImg; // Empezar con The Crypt (nivel 1)
      const mageImg = new Image();
      mageImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/mage-TnWuIwL8nfQgfspUHLdQb117UZpBR3.png?ddSR";
      const priestImg = new Image();
      priestImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/priest-DZKVrCXOeqMuQCe0Rid7DctIkoe4m0.png?XbMV";
      const warlockImg = new Image();
      warlockImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/warlock-ufYIrOZWd5mtgudqtQ8Yd34rteekHt.png?6IzB";

      // Enemy sprites - Demon Bat (Level 1)
      const demonBatIdleImg = new Image();
      demonBatIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/IDLE-V90NoEl8WQxdfu93X92hoipQtHfW7y.png?O0Ak";
      const demonBatDeathImg = new Image();
      demonBatDeathImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/DEATH-r9w4VgFSi93NjgHhRKFPjbBK3x4XYS.png?VLXN";
      const demonBatAttackImg = new Image();
      demonBatAttackImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ATTACK-ZCinJufJA25jik8Qm2R3DSZEdfIHez.png?iCFX";

      // Enemy sprites - Worm (Level 2)
      const wormIdleImg = new Image();
      wormIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/worm_idle-vJDVrN0IWXKWwxGqO3oaeE5VfdeiHx.png?rwdu";
      const wormDeathImg = new Image();
      wormDeathImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/worm_dead-fjt1PKqQPfa4Ql1iEJn92utXSHg48b.png?8dpt";
      const wormAttackImg = new Image();
      wormAttackImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/worm_attack-Lh6J61U6HqA0OHAbOC558yTFytcB58.png?yXF1";

      // Boss Minotaur sprites (Level 2 Boss) - Todas las animaciones en un solo sprite sheet
      const minotaurAllStatesImg = new Image();
      minotaurAllStatesImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/minotaur-sheet-Bv1KHH5UMJznTKr0gBV7kf6WUmOwZr.png?ZYdW";

      // Enemy sprites - Crab Bomb (Red Dunes special enemy)
      const crabBombIdleImg = new Image();
      crabBombIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ExplodingCrab%20Idle%2080x80-0xtADn8zveaJ99wQ8iQ0n4ilSjdiE9.png?UHf2";
      const crabBombDeathImg = new Image();
      crabBombDeathImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ExplodingCrab%20Death%2080x80-zDqZ4Ap4lWpensLHh3Lc2duYTtJCbG.png?1H5H";
      const crabBombExplodeImg = new Image();
      crabBombExplodeImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ExplodingCrab%20Explosion%2080x80-s3lRsNv4geuEqgjeWnasKtj6ibp1Iq.png?2GI8";

      // Enemy sprites - Mushroom (Dark Swamp normal enemy)
      const mushroomIdleImg = new Image();
      mushroomIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Mushroom-Idle-EbLaNtWreU7hEFwLThlVXyUUJUJbai.png?F111";
      const mushroomDeathImg = new Image();
      mushroomDeathImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Mushroom-Die-7HLapaD04zcX4shcBLZ3Wou2eClQCS.png?woNV";

      // Enemy sprites - Dreadwing (Dark Swamp flying enemy)
      const dreadwingIdleImg = new Image();
      dreadwingIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/swamp1_idle-ptG3GPSMeKcPxFdkhF4wXppEuKuIa8.png?XaXC";
      const dreadwingDeathImg = new Image();
      dreadwingDeathImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/swamp1_die-DP89ewxMkNaTGlxgh0HvP1gMsBdALz.png?AIEw";

      // Boss Swamp Gorgon sprites (Level 3 Boss) - Sprites individuales
      const swampGorgonIdleImg = new Image();
      swampGorgonIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Idle-2lKYMS7BBvm0cmpt5PyeU5VHN6g9Wj.png?gXER";

      const swampGorgonAttackImg = new Image();
      swampGorgonAttackImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Attack_2-nIg5G4WQX6MvAqgvOZEvC7jqkPlirE.png?t6rx";

      const swampGorgonSpecialAttackImg = new Image();
      swampGorgonSpecialAttackImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Attack_1-ORaqcWCCsweJHmdryjOSJqMYt9F9v2.png?XGn6";

      const swampGorgonDeathImg = new Image();
      swampGorgonDeathImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Dead-iRXzEKgppuyOurS2Ss4otFen8wiy1N.png?xC4K";

      // Boss Bat sprites (Level 1 Boss)
      const bossBatIdleImg = new Image();
      bossBatIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/IDLE_BOSS_1-N75RUTJp8bkxCSPZuvUWDye1KogjOS.png?C7Ns";
      const bossBatDeathImg = new Image();
      bossBatDeathImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/DEATH_BOSS_1-gjjAV8gTr6DBjZQ94xcwKAM8y63w2h.png?2Akf";
      const bossBatAttackImg = new Image();
      bossBatAttackImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ATTACK_BOSS_1-FArHbCZ2DrOKLJj2YyFvpSztZ5Ryq9.png?SSuQ";

      // Boss special ability effect
      const bloodSplatImg = new Image();
      bloodSplatImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Blood%20Splat-0zg8BGvPxZDBDQds5ZQiTgB7o5ebiC.png?59te";

      // Mantener sprites antiguos para compatibilidad temporal
      const enemyImg = new Image();
      enemyImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/beast_gigasChad-jHhAfiqtBGKuiIHRZJ0MkWs0W5uFQ5.png?9LBT";
      const goblinIdleImg = new Image();
      goblinIdleImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/IDLE-V90NoEl8WQxdfu93X92hoipQtHfW7y.png?O0Ak";
      const goblinDieImg = new Image();
      goblinDieImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/DEATH-r9w4VgFSi93NjgHhRKFPjbBK3x4XYS.png?VLXN";

      // Sprites de efectos de habilidades
      const effectsImg = new Image();
      effectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Red%20Effect%20Bullet%20Impact%20Explosion%2032x32-NnvGEsfH13xUZuEqmJAXk2oelYwGoV.png?b5e9";

      // Sprites de efectos púrpura para warlock
      const purpleEffectsImg = new Image();
      purpleEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Purple%20Effect%20Bullet%20Impact%20Explosion%2032x32-tBftQaSwItblEIfJStK8fGzQZEaFvQ.png?7m6v";

      // Sprite de efectos de curación
      const healingEffectsImg = new Image();
      healingEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Regen-IsFeOv1fkkRBrdZ1wZqoyhE5DrXPmz.png?22AH";

      // Sprite de efectos de rayo para Smite
      const lightningEffectsImg = new Image();
      lightningEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Lightning-JDFXQsYo47LoZYiuRiYJRnGOxeYgZc.png?8HcK";

      // Sprite de efectos de Dark Bolt para Inmolation
      const darkBoltEffectsImg = new Image();
      darkBoltEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/Dark-Bolt-XsHZlOlUknjRLKGCm3oDIfLlJimYCf.png?Lpbv";

      // Sprite de efectos de Blood Splat para Boss Bat (habilidad principal - un solo aliado)
      const bloodSplatEffectsImg = new Image();
      bloodSplatEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/sprite-sheet2-fpBxr82a3zc37rRAF6S573qRmIXtGU.png?ANvP";

      // Sprite de efectos de Blood Storm para Boss Bat (habilidad especial - todos los aliados)
      const bloodStormEffectsImg = new Image();
      bloodStormEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/sprite-sheet-F3tkTJhh68R3ZU2T2GrvwFXwEamfaf.png?pJmM";

      // Sprites mejorados para habilidades del Priest
      const priestSmiteEffectsImg = new Image();
      priestSmiteEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/smite-Bjk86Soi2Gf9vFJBLWIvzPGFBp44Hf.png?WXvo";

      // ================================
      // SISTEMA DE AUDIO
      // ================================

      // Música de fondo
      const menuMusic = new Audio();
      menuMusic.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/inicio-MQDiXSPNvWEeB155H9x56e222bHZLS.mp3?make";
      menuMusic.loop = true;
      menuMusic.volume = 0.4; // Volumen inicial

      const level1Music = new Audio();
      level1Music.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/crypt-LZN8TdnXRiyblZvvzcWPzT7uoQYwz7.mp3?Hg5w";
      level1Music.loop = true;
      level1Music.volume = 0.2; // Volumen reducido para niveles

      const level2Music = new Audio();
      level2Music.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/dunes-ru73QsoLV35gEZQ55A3rk09T8uleBr.mp3?tVGO";
      level2Music.loop = true;
      level2Music.volume = 0.2; // Volumen reducido para niveles

      const level3Music = new Audio();
      level3Music.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/swamp-UzVNiCOnEhv4JAiX6bpWBSjdpSQ3HR.mp3?fyCd";
      level3Music.loop = true;
      level3Music.volume = 0.2; // Volumen reducido para niveles

      // Efectos de sonido para hechizos
      const mageSpellSound = new Audio();
      mageSpellSound.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/fire-4xwSm7LSlrGc8FWd3CFstxoWINubeG.mp3?7yyv";
      mageSpellSound.volume = 0.6;

      const healSound = new Audio();
      healSound.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/heal-TiCdRKJwwC3qIRZnJFOVVBl2QcQlcO.mp3?ZSQJ";
      healSound.volume = 0.6;

      const smiteSound = new Audio();
      smiteSound.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/smite-ZK5nk41gDDoOYphPE6NCGNtBM9KeUl.mp3?Wkvu";
      smiteSound.volume = 0.6;

      const slashSound = new Audio();
      slashSound.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/slash-ODPOGnjPy7ZKZtYaiES5z2YFTjcZ8r.mp3?M7FY";
      slashSound.volume = 0.6;

      const inmolationSound = new Audio();
      inmolationSound.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/inmolation-mVevlPxJHzaIYbV1pteo7O80Ve5UsI.mp3?O3PH";
      inmolationSound.volume = 0.6;

      const agonySound = new Audio();
      agonySound.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/agony-Un5jNoMJYl7yaAjjPGr1FfZoqeue0N.mp3?xV6m";
      agonySound.volume = 0.6;

      // Variables para control de música
      let currentMusic = null;
      let pendingSounds = []; // Array para manejar sonidos con delay
      let audioInitialized = false; // Para manejar el autoplay de navegadores
      let userHasInteracted = false; // Para rastrear si el usuario ha interactuado
      let pendingMusicToPlay = null; // Música que se debe reproducir cuando el usuario interactúe

      // Funciones de control de audio
      function initializeAudio() {
        if (!audioInitialized && userHasInteracted) {
          console.log("Initializing audio after user interaction...");

          // Inicializar contexto de audio de forma más simple
          const initAudio = new Audio();
          initAudio.volume = 0;
          initAudio.src =
            "data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwgAztw0O7ZkUcQFE2c6+OmWRYSVZPl7K1NDQxRneftuGMeAztp1etqx6s4AAAq"; // Wav silencioso

          initAudio
            .play()
            .then(() => {
              initAudio.pause();
              audioInitialized = true;

              // Reproducir música pendiente si la hay después de un pequeño delay
              if (pendingMusicToPlay) {
                console.log("Playing pending music...");
                setTimeout(() => {
                  playMusicNow(pendingMusicToPlay);
                  pendingMusicToPlay = null;
                }, 100);
              }
            })
            .catch((e) => {
              console.log("Audio initialization failed:", e);
              // Aún así marcar como inicializado para intentar reproducir música
              audioInitialized = true;
              if (pendingMusicToPlay) {
                setTimeout(() => {
                  playMusicNow(pendingMusicToPlay);
                  pendingMusicToPlay = null;
                }, 100);
              }
            });
        }
      }

      function playMusicNow(audioElement) {
        // Detener música actual si existe
        if (currentMusic && currentMusic !== audioElement) {
          currentMusic.pause();
          currentMusic.currentTime = 0;
        }

        currentMusic = audioElement;

        // Reproducir nueva música con manejo robusto
        audioElement.currentTime = 0;
        const playPromise = audioElement.play();

        if (playPromise !== undefined) {
          playPromise.catch((e) => {
            console.log("No se pudo reproducir la música:", e);
            // Intentar de nuevo después de un breve delay
            setTimeout(() => {
              console.log("Reintentando reproducción de música...");
              audioElement.currentTime = 0;
              audioElement.play().catch((e2) => {
                console.log("Segundo intento de reproducción falló:", e2);
              });
            }, 300);
          });
        }
      }

      function playMusic(audioElement) {
        if (!userHasInteracted) {
          // Si el usuario no ha interactuado, guardar la música para reproducir después
          pendingMusicToPlay = audioElement;
          console.log("Music queued for after user interaction");
          return;
        }

        initializeAudio();
        playMusicNow(audioElement);
      }

      function stopAllMusic() {
        [menuMusic, level1Music, level2Music, level3Music].forEach((music) => {
          music.pause();
          music.currentTime = 0;
        });
        currentMusic = null;
      }

      // Función para manejar la primera interacción del usuario
      function handleFirstInteraction() {
        if (!userHasInteracted) {
          console.log("First user interaction detected");
          userHasInteracted = true;
          initializeAudio();

          // Remover los listeners después de la primera interacción
          document.removeEventListener("click", handleFirstInteraction, true);
          document.removeEventListener(
            "touchstart",
            handleFirstInteraction,
            true
          );
          document.removeEventListener("keydown", handleFirstInteraction, true);
        }
      }

      // Agregar listeners para detectar la primera interacción (useCapture = true para asegurar que se ejecute)
      document.addEventListener("click", handleFirstInteraction, true);
      document.addEventListener("touchstart", handleFirstInteraction, true);
      document.addEventListener("keydown", handleFirstInteraction, true);

      function playSpellSound(spellName, delay = 0) {
        if (!userHasInteracted) {
          console.log("Spell sound queued - waiting for user interaction");
          return;
        }

        initializeAudio();

        let soundToPlay = null;

        // Determinar qué sonido reproducir según el hechizo
        switch (spellName) {
          case "fireblast":
          case "combustion":
          case "inferno":
            soundToPlay = mageSpellSound;
            break;
          case "holywave":
          case "regrowth":
            soundToPlay = healSound;
            break;
          case "smite":
            soundToPlay = smiteSound;
            break;
          case "darkslash":
            soundToPlay = slashSound;
            break;
          case "inmolation":
            soundToPlay = inmolationSound;
            break;
          case "agony":
            soundToPlay = agonySound;
            break;
          default:
            return; // No hay sonido para este hechizo
        }

        if (delay > 0) {
          // Programar el sonido para más tarde
          pendingSounds.push({
            sound: soundToPlay,
            time: currentTime + delay,
          });
        } else {
          // Reproducir inmediatamente
          soundToPlay.currentTime = 0;
          soundToPlay.play().catch((e) => {
            console.log("No se pudo reproducir el sonido:", e);
          });
        }
      }

      function updatePendingSounds() {
        // Verificar si hay sonidos pendientes que deben reproducirse
        for (let i = pendingSounds.length - 1; i >= 0; i--) {
          const pendingSound = pendingSounds[i];
          if (currentTime >= pendingSound.time) {
            pendingSound.sound.currentTime = 0;
            pendingSound.sound.play().catch((e) => {
              console.log("No se pudo reproducir el sonido pendiente:", e);
            });
            pendingSounds.splice(i, 1);
          }
        }
      }

      const priestHolyWaveEffectsImg = new Image();
      priestHolyWaveEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/heal-3Xw84tzIf6iA8iM9A7ATJFLffNucdb.png?VXbc";

      const priestRegrowthEffectsImg = new Image();
      priestRegrowthEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/regrowth-jwXtVqqCJVlVmtGbVon46zD1y7zmbJ.png?YYsp";

      // Minotaur effects sprites
      const minotaurSmashEffectsImg = new Image();
      minotaurSmashEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/minotaur_normal-3TLpHMzhlYcUnC1CBuUC2d2VRA3DpS.png?n1Bm";

      const minotaurLifeStealEffectsImg = new Image();
      minotaurLifeStealEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/minotaur_special-zBxxGSBFlpUHDEVfULo1Qk6KuB00K6.png?uuJE";

      // Nuevos efectos mejorados
      const combustionEffectsImg = new Image();
      combustionEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/combustion-0ifHizZSGTiojCA9n7UpSkfkqn6qM5.png?18TW";

      const cthuluMainEffectsImg = new Image();
      cthuluMainEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/poison_main-vaefYRxX0tC5YTqWpWFboyItMAK9sC.png?tqGw";

      const cthuluSpecialEffectsImg = new Image();
      cthuluSpecialEffectsImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/poison_special-6DGH6sKHmuBlpk3clAxyhJ1fDcCcpy.png?tmXd";

      // Debuff/Buff Icons
      // Debuffs - Iconos individuales mejorados
      const healingDebuffImg = new Image();
      healingDebuffImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/healing-YGKWqqGrTxhH9nhj77jIaH3ezS2vvi.png?oHcR";

      const protectionDebuffImg = new Image();
      protectionDebuffImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/protec-X9cTS5hoFr9md7Ltog9G5yC5SKScv4.png?zi1r";

      const combustionDebuffImg = new Image();
      combustionDebuffImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/combustion-POS1UpYARnaioLsfaKNCqSob1xs0gl.png?8CXB";

      const bersekerDebuffImg = new Image();
      bersekerDebuffImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/berseker-Pxtuppp6McZnp7KQKIrlZMwIYgNxi4.png?mdnk";

      const poisonDebuffImg = new Image();
      poisonDebuffImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/poison-y1X2h1bNJlxnP7MA15GtrUyaYio8dQ.png?joqy";

      const shadowsDebuffImg = new Image();
      shadowsDebuffImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/shadows-kVBYwJqd1hX0tXr4EdjP2EA7NWo0ub.png?6D0w";

      // Configuración de niveles - CORREGIDO PARA DARK SWAMP LEVEL 3
      const levelConfig = {
        1: {
          name: "The Crypt",
          background:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/ChatGPT%20Image%2010%20ago%202025%2C%2001_31_21-11GclhftpsCG06vNEd4ri4gVBVUY8o.png?aymA",
          enemies: {
            normal: {
              name: "Demon Bat",
              hp: 80, // Según especificaciones
              sprites: {
                idle: demonBatIdleImg,
                death: demonBatDeathImg,
                attack: demonBatAttackImg,
              },
              frameWidth: 81,
              frameHeight: 71,
              idleFrames: 4,
              deathFrames: 6,
              attackFrames: 8,
              chargeSpeed: 40, // Aumentado (+2 rating)
              chargeSpeedRating: 8, // Subido de 6 a 8
              size: 80,
              isFlying: true, // Volador según especificaciones
              mainAbility: "basic_attack", // Habilidad básica que hace daño bajo/intermedio a héroe aleatorio
            },
            boss: {
              name: "Noctebane", // Boss renombrado según especificaciones
              hp: 200, // Según especificaciones
              sprites: {
                idle: bossBatIdleImg,
                death: bossBatDeathImg,
                attack: bossBatAttackImg,
              },
              frameWidth: 81,
              frameHeight: 71,
              idleFrames: 4,
              deathFrames: 6,
              attackFrames: 8,
              chargeSpeed: 30, // 6/10 velocidad según especificaciones
              chargeSpeedRating: 6, // 6/10 velocidad según especificaciones
              size: 120,
              specialAttackCounter: 3, // 3 esferas para habilidad especial
              mainAbility: "blood_splat", // Blood Splat: daño normal a héroe aleatorio
              specialAbility: "blood_storm", // Blood Storm: daña a todos los héroes
              isFlying: true, // Volador según especificaciones
            },
          },
        },
        3: {
          name: "Dark Swamp",
          background:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/dark_swamp-eMmE7CgLp4Bx3xpLSgXlriVLfXN325.png?opu2",
          enemies: {
            normal: {
              name: "Mushroom",
              hp: 100, // ✅ Correcto según especificaciones
              sprites: {
                idle: mushroomIdleImg,
                death: mushroomDeathImg,
                attack: mushroomIdleImg, // Usar idle para attack por ahora
              },
              frameWidth: 80, // 560px / 7 frames = 80px por frame
              frameHeight: 64,
              idleFrames: 7, // 7 frames en row para IDLE
              deathFrames: 15, // 15 frames en row para DIE
              attackFrames: 7, // Mismo que idle
              chargeSpeed: 30, // Corregido para 6/10 velocidad
              chargeSpeedRating: 6, // Corregido: 6/10 velocidad según especificaciones
              size: 120, // Aumentado de 100 a 120
              isFlying: false, // Terrestre
              mainAbility: "poison_attack", // Ataque con veneno
            },
            flying: {
              name: "Dreadwing",
              hp: 90, // Corregido: era 80, ahora 90 según especificaciones
              sprites: {
                idle: dreadwingIdleImg,
                death: dreadwingDeathImg,
                attack: dreadwingIdleImg, // Usar idle para attack por ahora
              },
              frameWidth: 64,
              frameHeight: 64,
              idleFrames: 8,
              deathFrames: 17,
              attackFrames: 8, // Mismo que idle
              chargeSpeed: 25, // Corregido para 5/10 velocidad
              chargeSpeedRating: 5, // Corregido: 5/10 velocidad según especificaciones
              size: 90,
              isFlying: true, // Volador
              mainAbility: "double_strike", // Ataque doble
            },
            boss: {
              name: "Gorgon",
              hp: 400, // Corregido: era 350, ahora 400 según especificaciones
              sprites: {
                idle: swampGorgonIdleImg,
                death: swampGorgonDeathImg,
                attack: swampGorgonAttackImg,
                specialAttack: swampGorgonSpecialAttackImg,
              },
              frameWidth: 128, // 128x128 cada frame
              frameHeight: 128,
              idleFrames: 7, // 7 frames para IDLE
              deathFrames: 3, // 3 frames para DIE
              attackFrames: 7, // 7 frames para NORMAL_ATTACK
              specialAttackFrames: 16, // 16 frames para SPECIAL_ATTACK
              chargeSpeed: 30, // Corregido para 6/10 velocidad
              chargeSpeedRating: 6, // Corregido: 6/10 velocidad según especificaciones
              size: 180, // Tamaño reducido para mejor proporción
              specialAttackCounter: 3,
              mainAbility: "poison_strike", // Corregido: nombre según especificaciones
              specialAbility: "toxic_horror", // Mantener la misma habilidad especial
              isFlying: false, // Terrestre
            },
          },
        },
        2: {
          name: "Red Dunes",
          background:
            "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/red_dunes-elmz1XktqRUANSNvvj8jYAoxXZsMkt.png?t9TH",
          enemies: {
            normal: {
              name: "Fire Worm",
              hp: 80, // Según especificaciones
              sprites: {
                idle: wormIdleImg,
                death: wormDeathImg,
                attack: wormAttackImg,
              },
              frameWidth: 90,
              frameHeight: 90,
              idleFrames: 9,
              deathFrames: 8,
              attackFrames: 16,
              chargeSpeed: 30, // 6/10 velocidad según especificaciones
              chargeSpeedRating: 6, // 6/10 velocidad según especificaciones
              size: 130,
              isFlying: false, // Terrestre
              mainAbility: "basic_attack", // Ataque básico intermedio
            },
            special: {
              name: "Crab Bomb",
              hp: 150, // Según especificaciones
              sprites: {
                idle: crabBombIdleImg,
                death: crabBombDeathImg,
                attack: crabBombIdleImg, // Usar idle como fallback
                explode: crabBombExplodeImg, // Sprite especial para explosión
              },
              frameWidth: 80, // 80x80 según especificaciones
              frameHeight: 80,
              idleFrames: 13, // 1040px / 80px = 13 frames
              deathFrames: 6, // 480px / 80px = 6 frames
              explodeFrames: 23, // 1840px / 80px = 23 frames
              chargeSpeed: 25, // 5/10 velocidad según especificaciones
              chargeSpeedRating: 5, // 5/10 velocidad según especificaciones
              size: 120,
              isFlying: false, // Terrestre
              mainAbility: "explode", // Habilidad especial de explosión
              specialAttackCounter: 5, // 5 esferas como especificado
              noBasicAttack: true, // No tiene habilidad básica
            },
            boss: {
              name: "Minotaur",
              hp: 300, // Según especificaciones
              sprites: {
                idle: minotaurAllStatesImg,
                death: minotaurAllStatesImg,
                attack: minotaurAllStatesImg,
              },
              frameWidth: 288,
              frameHeight: 160,
              idleFrames: 16, // Primera fila: IDLE 16 frames
              deathFrames: 16, // No hay animación de muerte, usar idle/attack para transición
              attackFrames: 16, // Segunda fila: ATTACK 16 frames
              chargeSpeed: 25, // Empieza en 5/10 velocidad según especificaciones
              chargeSpeedRating: 5, // Empieza en 5/10 y va subiendo
              size: 320,
              specialAttackCounter: 3, // Contador para ataque especial
              mainAbility: "smash", // Nombre correcto según especificaciones
              specialAbility: "life_steal", // Nombre correcto según especificaciones
              isFlying: false, // Terrestre
            },
          },
        },
        // Aquí se añadirán más niveles en el futuro
      };

      // UI Elements - Solo los elementos que se usan
      const panelBrownImg = new Image();
      panelBrownImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/panel_brown-49f4SM1AoKwCYlEq9piZiXmfxdEC0G.png?ZpjN";

      const panelBeigeImg = new Image();
      panelBeigeImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/panel_beige-S87wunV71Sxq5QTxONuar0vD9W1LrV.png?sZSO";

      const buttonLongBeigeImg = new Image();
      buttonLongBeigeImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/buttonLong_beige-AkYz3mfJrwayHOsnKfj3J2cFcEajGT.png?vtgY";

      const buttonLongBrownImg = new Image();
      buttonLongBrownImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/buttonLong_brown-oof3pI0kehlONOYt1I39gi6TcPr2Jm.png?KInj";

      const buttonRoundBeigeImg = new Image();
      buttonRoundBeigeImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/buttonRound_beige-cnUh8OwyVlFjAjg2lpGBuVJKnmwV4m.png?wzPo";

      const iconCrossBrownImg = new Image();
      iconCrossBrownImg.src =
        "https://lqy3lriiybxcejon.public.blob.vercel-storage.com/74a152a9-f7b9-4583-9d0d-f2480d681702/iconCross_brown-vkY074tDvp0pjArcKTQ6CYMIcBKwGO.png?V1qv";

      // Animations - actualizadas con nuevas habilidades
      const animationsMage = {
        selected: { row: 0, frames: 6, duration: 0.6 },
        idle: { row: 1, frames: 6, duration: 0.6 },
        fireblast: { row: 2, frames: 7, duration: 1 },
        combustion: { row: 4, frames: 6, duration: 1 }, // Usar la misma fila que inferno
        inferno: { row: 4, frames: 6, duration: 1 },
      };
      const animationsPriest = {
        selected: { row: 0, frames: 6, duration: 0.6 },
        idle: { row: 1, frames: 6, duration: 0.6 },
        holywave: { row: 2, frames: 7, duration: 1 },
        smite: { row: 3, frames: 6, duration: 1 },
        regrowth: { row: 4, frames: 6, duration: 1 },
      };
      const animationsWarlock = {
        selected: { row: 0, frames: 6, duration: 0.6 },
        idle: { row: 1, frames: 6, duration: 0.6 },
        darkslash: { row: 2, frames: 7, duration: 1 },
        agony: { row: 3, frames: 6, duration: 0.5 }, // Instantáneo
        inmolation: { row: 4, frames: 7, duration: 1 },
      };

      let score = 0;
      let wave = 0;
      let heroes = [];
      let enemies = [];
      let state = "main_menu";
      let selectedHero = null;
      let selectedAction = null;
      let turnPhase = "player";
      let currentEnemyIndex = 0;
      let slashStreak = 0;
      let currentTime = 0;
      let hitNumbers = []; // Array para almacenar los números de golpe flotantes
      let visualEffects = []; // Array para efectos visuales especiales
      let levelCompletionModal = { show: false, level: 0, boss: "", timer: 0 }; // Modal de finalización de nivel
      let currentLevel = 1; // Nivel actual del juego (1, 2, 3)
      // Sistema de turnos por cola
      let turnQueue = []; // Contendrá referencias directas a héroes o enemigos cuyo charge llegó a 100 en orden de llegada
      let activeAction = null; // Acción en curso (animación/delay) bloquea inicio de la siguiente
      let actionDelayTimer = 0; // Pequeño retardo antes de ejecutar el efecto de ataque enemigo
      // Sistema de turnos para debuffs turn-based
      let lastTurnEntity = null;
      let globalTurnCounter = 0; // Cuenta turnos globales (cada entidad que comienza turno)
      // Transición entre waves
      let waveTransition = { active: false, timer: 0, delay: 1.2 }; // 1.2s de margen
      // Flag para mostrar pantalla de información del siguiente nivel tras transición
      let pendingLevelInfo = false;

      function processTurnStart(activeEntity) {
        if (!activeEntity) return;
        globalTurnCounter++;
        const allHeroes = heroes || [];
        const allEnemies = enemies || [];

        // Procesar buffs turn-based en héroes
        allHeroes.forEach((h) => {
          if (!h.buffs) h.buffs = [];
          if (h.hp <= 0) return;
          h.buffs = h.buffs.filter((b) => {
            switch (b.type) {
              case "regrowth": {
                // Curación por turno ajustada (4-5) reducida
                const healAmount = 4 + Math.floor(Math.random() * 2);
                h.hp = Math.min(h.maxhp, h.hp + healAmount);
                validateHP(h);
                playHealingAnim(h, "regrowth");
                showHitNumber(h.posx, h.posy - 20, healAmount, true);
                if (b.remainingTurns !== undefined) {
                  b.remainingTurns--;
                  if (b.remainingTurns <= 0) {
                    removeDebuff(h, "healing");
                    return false;
                  }
                }
                return true;
              }
              case "agony": {
                if (b.remainingTurns !== undefined) {
                  b.remainingTurns--;
                  if (b.remainingTurns <= 0) {
                    removeDebuff(h, "protection");
                    return false;
                  }
                }
                return true;
              }
              case "poison": {
                // Poison: daño base reducido (aprox 2/3 del anterior 3) => 2 + 1 por cada stack adicional
                const stacks = b.stacks || 1;
                const dmg = 2 + (stacks - 1) * 1; // base 2, +1 por stack extra
                h.hp = Math.max(0, h.hp - dmg);
                showHitNumber(h.posx, h.posy - 20, dmg, false, false);
                if (h.hp <= 0) {
                  console.log(h.clazz, "died from poison (turn system)");
                }
                if (b.remainingTurns !== undefined) {
                  b.remainingTurns--;
                  if (b.remainingTurns <= 0) {
                    removeDebuff(h, "poison");
                    return false;
                  }
                }
                return true;
              }
              default:
                return true; // Otros buffs sin cambio
            }
          });

          // Procesar debuffs (shadows/poison) si se aplicaran a héroes via h.debuffs
          if (h.debuffs && h.debuffs.length > 0 && h.hp > 0) {
            h.debuffs = h.debuffs.filter((d) => {
              if (d.type === "shadows") {
                const dmg = d.damagePerTick || 2;
                h.hp = Math.max(0, h.hp - dmg);
                showHitNumber(h.posx, h.posy - 20, dmg, false, false);
                if (h.hp <= 0) {
                  console.log(h.clazz + " died from shadows (turn system)");
                }
                if (d.remainingTurns !== undefined) {
                  d.remainingTurns--;
                  if (d.remainingTurns <= 0) return false;
                }
                return true;
              } else if (d.type === "poison") {
                const stacks = d.stacks || 1;
                const dmg = 2 + (stacks - 1) * 1;
                h.hp = Math.max(0, h.hp - dmg);
                showHitNumber(h.posx, h.posy - 20, dmg, false, false);
                if (h.hp <= 0)
                  console.log(h.clazz + " died from poison (turn debuff)");
                if (d.remainingTurns !== undefined) {
                  d.remainingTurns--;
                  if (d.remainingTurns <= 0) return false;
                }
                return true;
              }
              return true;
            });
          }
        });

        // Procesar debuffs turn-based en enemigos (shadows, poison futuro)
        allEnemies.forEach((e) => {
          if (!e.debuffs) e.debuffs = [];
          if (e.hp <= 0) return;
          e.debuffs = e.debuffs.filter((d) => {
            switch (d.type) {
              case "shadows": {
                const dmg = d.damagePerTick || 2;
                e.hp = Math.max(0, e.hp - dmg);
                showHitNumber(e.posx, e.posy - 20, dmg, false, false);
                if (e.hp <= 0) {
                  console.log(
                    (e.type || e.name) + " died from shadows (turn system)"
                  );
                  e.isDying = true;
                  e.anim = "die";
                  e.frame = 0;
                  e.animStartTime = currentTime;
                  triggerHapticFeedback();
                }
                if (d.remainingTurns !== undefined) {
                  d.remainingTurns--;
                  if (d.remainingTurns <= 0) {
                    return false;
                  }
                }
                return true;
              }
              case "poison": {
                const stacks = d.stacks || 1;
                const dmg = 2 + (stacks - 1) * 1;
                e.hp = Math.max(0, e.hp - dmg);
                showHitNumber(e.posx, e.posy - 20, dmg, false, false);
                if (e.hp <= 0) {
                  console.log(
                    (e.type || e.name) + " died from poison (turn system)"
                  );
                  e.isDying = true;
                  e.anim = "die";
                  e.frame = 0;
                  e.animStartTime = currentTime;
                  triggerHapticFeedback();
                }
                if (d.remainingTurns !== undefined) {
                  d.remainingTurns--;
                  if (d.remainingTurns <= 0) return false;
                }
                return true;
              }
              default:
                return true;
            }
          });
        });
      }

      // Variables para el Book
      let bookScrollY = 0; // Posición del scroll vertical
      let guideScrollY = 0; // Posición del scroll vertical para la guía
      const bookScrollSpeed = 30; // Velocidad del scroll

      // Variables para scroll táctil
      let isDragging = false;
      let lastTouchY = 0;

      // Información de los niveles
      const levelInfo = {
        1: {
          name: "The Forgotten Crypt",
          lore: "The mages ventured into the ancient crypt in search of the lost arcane artifacts. Dark creatures await in the shadows...",
          boss: "Shadow Bat Lord",
          background: "#1a0d0a", // Color de fondo marrón oscuro para la cripta
        },
        2: {
          name: "The Red Dunes",
          lore: "Beyond the crypt lies a cursed desert where the crimson sands conceal deadly predators beneath their surface...",
          boss: "Minotaur Guardian",
          background: "#3d2012", // Color de fondo marrón rojizo para el desierto
        },
        3: {
          name: "The Dark Swamp",
          lore: "In the deepest marshlands, ancient evils stir. The final challenge awaits those brave enough to face the swamp's master...",
          boss: "Swamp Gorgon",
          background: "#0d2818", // Color de fondo verde oscuro para el pantano
        },
      };

      function init() {
        heroes = [
          {
            clazz: "mage",
            hp: 100,
            maxhp: 100,
            def: 3, // Poca defensa
            charge: 0, // Start empty
            maxcharge: 100,
            chargeSpeedRating: 4, // Velocidad media-baja (1-10 scale)
            posx: 80, // Posición original
            posy: 415, // Movido 20px arriba (era 450)
            anim: "idle",
            frame: 0,
            animTime: 0,
            acted: false,
            buffs: [],
            debuffs: [], // Array para iconos de debuffs/buffs
            targets: [],
            action: null,
            img: mageImg,
            animations: animationsMage,
            frameW: 100, // Nuevo tamaño de frame
            frameH: 100, // Nuevo tamaño de frame
            size: 90,
          },
          {
            clazz: "warlock",
            hp: 100,
            maxhp: 100,
            def: 15, // Buena defensa
            charge: 0, // Start empty
            maxcharge: 100,
            chargeSpeedRating: 6, // Velocidad media-alta (tanque equilibrado)
            posx: 180, // Posición original
            posy: 380, // Movido 20px abajo para mejor alineación visual
            anim: "idle",
            frame: 0,
            animTime: 0,
            acted: false,
            buffs: [],
            debuffs: [], // Array para iconos de debuffs/buffs
            targets: [],
            action: null,
            img: warlockImg,
            animations: animationsWarlock,
            frameW: 100, // Nuevo tamaño de frame
            frameH: 100, // Nuevo tamaño de frame
            size: 90,
          },
          {
            clazz: "priest",
            hp: 100,
            maxhp: 100,
            def: 3, // Poca defensa
            charge: 0, // Start empty
            maxcharge: 100,
            chargeSpeedRating: 5, // Velocidad media (soporte equilibrado)
            posx: 280, // Posición original
            posy: 415, // Movido 20px arriba (era 450)
            anim: "idle",
            frame: 0,
            animTime: 0,
            acted: false,
            buffs: [],
            debuffs: [], // Array para iconos de debuffs/buffs
            targets: [],
            action: null,
            img: priestImg,
            animations: animationsPriest,
            frameW: 100, // Nuevo tamaño de frame
            frameH: 100, // Nuevo tamaño de frame
            size: 90,
          },
        ];
        enemies = [];
        activeAction = null;
        actionDelayTimer = 0;
        score = 0;
        wave = 0;
        currentLevel = 1;
        state = "level_info"; // Empezar mostrando info del nivel 1
        turnPhase = "player";
        slashStreak = 0;
        currentBackgroundImg = backgroundImg; // The Crypt es nivel 1
        levelCompletionModal = { show: false, level: 0, boss: "", timer: 0 };
        pendingLevelInfo = false;

        // Reproducir música del nivel 1 al inicio del juego
        playMusic(level1Music);

        // No llamar startWave() aquí - se llamará cuando se pulse "Enter" en level_info
      }

      function startGame() {
        console.log("Starting game...");
        // Inicializar el juego
        init();
        // El estado ya se establece como "level_info" en init()
      }

      function startWave() {
        console.log("Starting wave", wave + 1);

        // Limpiar enemigos de la wave anterior
        enemies = [];

        // Verificar si empezamos un nuevo nivel (cada 3 waves)
        const previousLevel = Math.floor((wave - 1) / 3) + 1;
        const nextLevel = Math.floor(wave / 3) + 1;
        currentLevel = nextLevel;

        // Actualizar background según el nivel actual
        if (currentLevel === 1) {
          currentBackgroundImg = backgroundImg; // The Crypt
        } else if (currentLevel === 2) {
          currentBackgroundImg = backgroundLevel2Img; // Red Dunes
        } else if (currentLevel === 3) {
          currentBackgroundImg = backgroundLevel3Img; // Dark Swamp
        } else {
          currentBackgroundImg = backgroundImg; // Default para niveles posteriores
        }

        // Cambiar música según el nivel cuando se inicia una nueva wave
        if (currentLevel === 1) {
          if (currentMusic !== level1Music) {
            playMusic(level1Music);
          }
        } else if (currentLevel === 2) {
          if (currentMusic !== level2Music) {
            playMusic(level2Music);
          }
        } else if (currentLevel === 3) {
          if (currentMusic !== level3Music) {
            playMusic(level3Music);
          }
        }

        // Revivir héroes cuando se detecta inicio de un nuevo nivel (justo después de haber terminado una wave múltiplo de 3)
        if (nextLevel > previousLevel && wave % 3 === 0) {
          console.log(
            `Starting new level ${nextLevel}! Reviving all heroes with full health (after previous level completion).`
          );
          heroes.forEach((hero) => {
            hero.hp = hero.maxhp;
            validateHP(hero);
            hero.charge = 0; // Resetear carga también
            hero.anim = "idle"; // Asegurar que estén en animación idle
            hero.frame = 0;
            // Limpiar buffs al empezar nuevo nivel
            hero.buffs = [];
          });
        } else {
          console.log(
            `Continuing level ${currentLevel}, wave ${
              ((wave - 1) % 3) + 1
            }/3 - heroes maintain their current state (dead heroes stay dead)`
          );
        }

        let enemyPositions = [];
        const currentLevelConfig =
          levelConfig[Math.floor(wave / 3) + 1] || levelConfig[1]; // Fallback al nivel 1 (The Crypt)
        const normalHP = currentLevelConfig.enemies.normal.hp;
        const flyingHP = currentLevelConfig.enemies.flying
          ? currentLevelConfig.enemies.flying.hp
          : normalHP;
        const specialHP = currentLevelConfig.enemies.special
          ? currentLevelConfig.enemies.special.hp
          : normalHP;
        const bossHP = currentLevelConfig.enemies.boss.hp;

        // Determinar el nivel actual para configurar waves específicas
        const actualLevel = Math.floor(wave / 3) + 1;

        if (wave % 3 === 0) {
          // Wave 1/3 para cada nivel
          if (actualLevel === 1) {
            // The Crypt Wave 1: 2 Demon Bat
            enemies = [
              createEnemy(120, 200, normalHP, "normal"), // Demon Bat izquierda
              createEnemy(240, 200, normalHP, "normal"), // Demon Bat derecha
            ];
          } else if (actualLevel === 2) {
            // Red Dunes Wave 1: 1 Fire Worm + 1 Crab Bomb
            enemies = [
              createEnemy(120, 200, normalHP, "normal"), // Fire Worm
              createEnemy(240, 200, specialHP, "special"), // Crab Bomb
            ];
          } else if (actualLevel === 3) {
            // Dark Swamp Wave 1: 1 Mushroom + 1 Dreadwing
            enemies = [
              createEnemy(120, 200, normalHP, "normal"), // Mushroom
              createEnemy(240, 200, flyingHP, "flying"), // Dreadwing
            ];
          } else {
            // Otros niveles mantienen la configuración original (2 enemigos normales)
            enemies = [
              createEnemy(100, 200, normalHP, "normal"),
              createEnemy(260, 200, normalHP, "normal"),
            ];
          }
        } else if (wave % 3 === 1) {
          // Wave 2/3 para cada nivel
          if (actualLevel === 1) {
            // The Crypt Wave 2: 3 Demon Bat
            enemies = [
              createEnemy(80, 200, normalHP, "normal"), // Demon Bat izquierda
              createEnemy(180, 200, normalHP, "normal"), // Demon Bat centro
              createEnemy(280, 200, normalHP, "normal"), // Demon Bat derecha
            ];
          } else if (actualLevel === 2) {
            // Red Dunes Wave 2: 1 Fire Worm + 1 Crab Bomb + 1 Fire Worm
            enemies = [
              createEnemy(80, 200, normalHP, "normal"), // Fire Worm izquierda
              createEnemy(180, 200, specialHP, "special"), // Crab Bomb centro
              createEnemy(280, 200, normalHP, "normal"), // Fire Worm derecha
            ];
          } else if (actualLevel === 3) {
            // Dark Swamp Wave 2: 1 Dreadwing + 1 Mushroom + 1 Dreadwing
            enemies = [
              createEnemy(80, 200, flyingHP, "flying"), // Dreadwing izquierda
              createEnemy(180, 200, normalHP, "normal"), // Mushroom centro
              createEnemy(280, 200, flyingHP, "flying"), // Dreadwing derecha
            ];
          } else {
            // Otros niveles mantienen la configuración original (3 enemigos normales)
            enemies = [
              createEnemy(80, 200, normalHP, "normal"),
              createEnemy(180, 200, normalHP, "normal"),
              createEnemy(280, 200, normalHP, "normal"),
            ];
          }
        } else {
          // Wave 3/3: boss para todos los niveles - centrado exacto en pantalla
          enemies = [createEnemy(screenCenterX, 200, bossHP, "boss")]; // Centro exacto: 180px
        }
        wave++;
        console.log("Wave", wave, "started with", enemies.length, "enemies");
        heroes.forEach((h) => (h.acted = false));
        // Reiniciar cola de turnos al iniciar wave
        turnQueue = [];
      }

      function createEnemy(x, y, hp, type) {
        const currentLevel = Math.floor(wave / 3) + 1;
        const currentLevelConfig = levelConfig[currentLevel] || levelConfig[1]; // Fallback al nivel 1

        let enemyConfig;
        if (type === "boss") {
          enemyConfig = currentLevelConfig.enemies.boss;
        } else if (type === "flying") {
          // Para Dark Swamp, usar el enemigo volador (Dreadwing)
          enemyConfig =
            currentLevelConfig.enemies.flying ||
            currentLevelConfig.enemies.normal;
        } else if (type === "special") {
          // Para Red Dunes, usar el enemigo especial (Crab Bomb)
          enemyConfig =
            currentLevelConfig.enemies.special ||
            currentLevelConfig.enemies.normal;
        } else {
          // Tipo normal o por defecto
          enemyConfig = currentLevelConfig.enemies.normal;
        }

        // Determinar posición Y según si es volador o terrestre
        let adjustedY = y;
        if (enemyConfig.isFlying) {
          adjustedY = y - 10; // Voladores más arriba
        } else {
          adjustedY = y + 20; // Terrestres más abajo
        }

        return {
          hp,
          maxhp: hp,
          charge: 0,
          maxcharge: 100,
          posx: x,
          posy: adjustedY,
          type,
          animTime: 0,
          def: type === "boss" ? 10 : 5,
          size: enemyConfig.size || (type === "boss" ? 140 : 110), // Usar tamaño específico o fallback
          anim: "idle",
          frame: 0,
          animStartTime: 0,
          isDying: false,
          deathAnimComplete: false,
          spawnFadeProgress: 0, // 0 -> 1 aparición suave
          debuffs: [], // Array para iconos de debuffs/buffs
          name: enemyConfig.name,
          sprites: enemyConfig.sprites,
          frameWidth: enemyConfig.frameWidth,
          frameHeight: enemyConfig.frameHeight,
          idleFrames: enemyConfig.idleFrames,
          deathFrames: enemyConfig.deathFrames,
          attackFrames: enemyConfig.attackFrames,
          explodeFrames: enemyConfig.explodeFrames, // Para Crab Bomb
          chargeSpeed: enemyConfig.chargeSpeed,
          isFlying: enemyConfig.isFlying, // Añadir propiedad isFlying al enemigo
          mainAbility: enemyConfig.mainAbility, // Habilidad principal del enemigo
          noBasicAttack: enemyConfig.noBasicAttack, // Para Crab Bomb que no tiene ataque básico
          // Propiedades específicas del boss y Crab Bomb
          specialAttackCounter:
            type === "boss" || type === "special"
              ? enemyConfig.specialAttackCounter
              : null,
          specialAbility: type === "boss" ? enemyConfig.specialAbility : null,
          attacksUntilSpecial:
            type === "boss" ? enemyConfig.specialAttackCounter : null,
          sphereCharges: type === "special" ? 0 : null, // Para sistema de esferas del Crab Bomb
          maxSphereCharges:
            type === "special" ? enemyConfig.specialAttackCounter : null,
          damageMultiplier: 1, // Para pasivas de escalado (Noctebane)
        };

        // Validar que HP y maxHP sean números válidos para evitar NaN
        if (isNaN(enemy.hp) || enemy.hp === undefined) {
          enemy.hp = hp;
        }
        if (isNaN(enemy.maxhp) || enemy.maxhp === undefined) {
          enemy.maxhp = hp;
        }

        return enemy;
      }

      // Función para validar y corregir valores de HP
      function validateHP(target) {
        const wasAlive = target.hp > 0; // Recordar si estaba vivo antes

        if (isNaN(target.hp) || target.hp === undefined || target.hp === null) {
          target.hp = target.maxhp || 1;
        }
        if (
          isNaN(target.maxhp) ||
          target.maxhp === undefined ||
          target.maxhp === null
        ) {
          target.maxhp = target.hp || 1;
        }
        target.hp = Math.max(0, target.hp);
        target.maxhp = Math.max(1, target.maxhp);

        // Si el héroe acaba de morir (tenía hp > 0 y ahora hp <= 0), limpiar efectos
        if (wasAlive && target.hp <= 0 && target.clazz) {
          // Solo para héroes (tienen clazz)
          clearAllEffectsOnDeath(target);
        }
      }

      // Función para calcular si un golpe es crítico
      function calculateCritical(baseDamage, customCritChance = 15) {
        const criticalChance = customCritChance / 100; // Convertir porcentaje a decimal
        const isCritical = Math.random() < criticalChance;
        const finalDamage = isCritical
          ? Math.floor(baseDamage * 1.5)
          : baseDamage;

        return {
          damage: finalDamage,
          isCritical: isCritical,
        };
      }

      // Función para calcular valores aleatorios en un rango
      function calculateRandomValue(baseValue, variationPercent = 20) {
        const variation = Math.floor(baseValue * (variationPercent / 100));
        const minValue = baseValue - variation;
        const maxValue = baseValue + variation;
        return minValue + Math.floor(Math.random() * (maxValue - minValue + 1));
      }

      // Función para convertir el rating de velocidad de carga (1-10) a velocidad real
      function getChargeSpeedFromRating(rating) {
        // Rating 1 = velocidad 5 (más lento)
        // Rating 10 = velocidad 50 (más rápido)
        // Escala lineal: velocidad = rating * 5
        return Math.max(1, Math.min(50, rating * 5));
      }

      // Función para aplicar bonificador de velocidad de carga
      function applyChargeSpeedBonus(character, multiplier) {
        if (character.chargeSpeedRating) {
          // Para el nuevo sistema, aumentar el rating pero mantener límites
          character.chargeSpeedRating = Math.min(
            10,
            character.chargeSpeedRating * multiplier
          );
        } else {
          // Compatibilidad con el sistema legacy
          character.chargeSpeed = (character.chargeSpeed || 20) * multiplier;
        }
      }

      // Función para obtener la velocidad de carga actual (para debugging)
      function getCurrentChargeSpeed(character) {
        let base = character.chargeSpeedRating
          ? getChargeSpeedFromRating(character.chargeSpeedRating)
          : character.chargeSpeed || 20;
        // Bonus berseker: +3% por stack hasta 10 stacks (30%)
        if (character.debuffs) {
          const bers = character.debuffs.find((d) => d.type === "berseker");
          if (bers && bers.stacks) {
            const bonusPct = Math.min(bers.stacks * 3, 30);
            base *= 1 + bonusPct / 100;
          }
        }
        return base;
      }

      const classActions = {
        mage: {
          fireblast: {
            name: "Fireblast",
            reqCharge: 100, // Todas las habilidades requieren barra completa
            type: "single_enemy",
            damage: 35,
            anim: "fireblast",
          },
          combustion: {
            name: "Combustion",
            reqCharge: 100, // Todas las habilidades requieren barra completa
            type: "self",
            critBonus: 80, // Gran porcentaje de crítico para el próximo ataque
            anim: "combustion",
          },
          inferno: {
            name: "Inferno",
            reqCharge: 100, // Todas las habilidades requieren barra completa
            type: "all_enemy",
            damage: 22, // Menos que fireblast pero a todos los enemigos
            anim: "inferno",
          },
        },
        priest: {
          holywave: {
            name: "Holy Wave",
            reqCharge: 100, // Todas las habilidades requieren barra completa
            type: "single_ally",
            heal: 50,
            anim: "holywave",
          },
          smite: {
            name: "Smite",
            reqCharge: 100, // Todas las habilidades requieren barra completa
            type: "single_enemy",
            damage: 20, // Poco daño
            anim: "smite",
          },
          regrowth: {
            name: "Regrowth",
            reqCharge: 100, // Todas las habilidades requieren barra completa
            type: "all_ally",
            heal: 8, // Base para rango 7-9
            ticks: 10, // 10 segundos de duración
            anim: "regrowth",
          },
        },
        warlock: {
          darkslash: {
            name: "Dark Slash",
            reqCharge: 100, // Todas las habilidades requieren barra completa
            type: "single_enemy",
            damage: 5,
            anim: "darkslash",
            shadowsDamage: 2, // Daño base por tick de Shadows
            shadowsDuration: 15, // 15 segundos
            shadowsInterval: 5, // Cada 5 segundos
            stackDamageIncrease: 1, // +1 daño por stack
          },
          agony: {
            name: "Agony",
            reqCharge: 100, // Todas las habilidades requieren barra completa
            type: "all_ally",
            // (Turn-based) ahora otorga +20% DEF temporal (defBonus se calcula al aplicar)
            duration: 20, // Conservado por si otras partes usan duración base (segundos original no usado ya)
            anim: "agony",
          },
          inmolation: {
            name: "Inmolation",
            reqCharge: 100, // Todas las habilidades requieren barra completa
            type: "all_enemy",
            damage: 35, // Mucho daño
            selfDamage: 50, // 60% de su vida
            anim: "inmolation",
          },
        },
      };

      // ================================
      // GAME OVER HANDLING
      // ================================

      function handleGameOver() {
        // Enviar score al SDK de Farcade (única acción en game over)
        if (window.FarcadeSDK) {
          window.FarcadeSDK.singlePlayer.actions.gameOver({ score: score });
        }
      }

      function checkGameOver() {
        if (heroes.every((h) => h.hp <= 0)) {
          handleGameOver();
          return true;
        }
        return false;
      }
      function checkWaveCleared() {
        // Si ya estamos en transición, no volver a dispararla
        if (waveTransition.active) return false;
        // Si ya mostramos modal de fin de nivel, no repetir
        if (state === "level_completion") return false;
        if (enemies.every((e) => e.hp <= 0)) {
          // Verificar si todos los enemigos han completado su animación de muerte
          const allDeathAnimationsComplete = enemies.every(
            (e) => e.hp > 0 || e.deathAnimComplete
          );

          if (allDeathAnimationsComplete) {
            console.log("Wave cleared! Preparing transition...");

            // Bonificación por enemigos eliminados
            enemies.forEach((e) => {
              score += e.type === "boss" ? 10 : 1;
            });

            // Bonificación extra por wave completada
            const waveBonus = wave * 50; // 50 puntos por wave, escalando
            score += waveBonus;
            console.log(`Wave ${wave} completed! Bonus: ${waveBonus} points`);

            // Verificar si hemos completado un nivel (wave 3, 6, 9...)
            if (wave % 3 === 0) {
              const completedLevel = Math.floor(wave / 3);
              const levelData = levelInfo[completedLevel];

              // Validar que tenemos datos del nivel (si falta, continuar igualmente)
              if (!levelData) {
                console.error(
                  "Level data not found for level:",
                  completedLevel
                );
              }

              if (completedLevel === 3) {
                // Juego completado: el SDK se encarga; no iniciar más waves
                console.log("Game completion handled by SDK");
              } else {
                console.log(
                  `Level ${completedLevel} completed -> showing completion modal`
                );
                levelCompletionModal.show = true;
                levelCompletionModal.level = completedLevel;
                levelCompletionModal.boss = levelData ? levelData.boss : "";
                state = "level_completion";
              }
            } else {
              // Continuar con la siguiente wave del mismo nivel mediante transición suave
              beginWaveTransition();
            }
            return true;
          }
        }
        return false;
      }

      function beginWaveTransition() {
        // Limpiar efectos visuales residuales y números de golpe
        hitNumbers = [];
        visualEffects = visualEffects.filter((fx) => fx.persistent); // Opcional: mantener solo persistentes si existieran
        waveTransition.active = true;
        waveTransition.timer = waveTransition.delay;
      }

      // NOTA: advanceTurn() removida - ya no se usa sistema de turnos

      // Función para cancelar automáticamente la selección de objetivo si el héroe muere
      function checkAndCancelDeadHeroAction() {
        if (selectedHero && selectedHero.hp <= 0) {
          // Si el héroe seleccionado está muerto y estamos en modo de selección de objetivo
          if (
            state === "select_target_enemy" ||
            state === "select_target_ally"
          ) {
            console.log(
              `${selectedHero.clazz} died during target selection. Canceling action: ${selectedAction}`
            );

            // Resetear todas las variables de selección
            selectedHero = null;
            selectedAction = null;
            state = "select_hero";

            console.log("Action canceled. Returning to hero selection.");
          }
        }
      }

      function executeAction(hero, action, targets) {
        const actionData = classActions[hero.clazz][action];

        // Solo puede actuar si es su turno (primero en la cola) en modo de turnos
        if (turnQueue.length === 0 || turnQueue[0] !== hero) {
          return false;
        }

        // Check if we have enough charge before executing
        let requiredCharge = actionData.reqCharge;

        if (hero.charge < requiredCharge) {
          console.log(
            "Not enough charge for action:",
            action,
            "Required:",
            requiredCharge,
            "Current:",
            hero.charge
          );
          return false;
        }

        // Always reset charge to 0 when using any ability
        hero.charge = 0;
        // Retirar de la cola (ya consumió su turno)
        if (turnQueue[0] === hero) {
          turnQueue.shift();
        } else {
          // Seguridad por si estuviera más adelante (no debería ocurrir)
          turnQueue = turnQueue.filter((e) => e !== hero);
        }

        hero.anim = actionData.anim;
        hero.frame = 0;
        hero.animTime = 0;
        // Limpiar targets anteriores antes de asignar nuevos
        hero.targets = [];
        hero.targets = Array.isArray(targets) ? targets : [targets];
        hero.action = action;
        // NO cambiar estado a "animate" para permitir clicks rápidos
        // state = "animate";

        console.log(
          "Executing action:",
          action,
          "for hero:",
          hero.clazz,
          "with targets:",
          hero.targets.length,
          "charge reset to 0"
        );
        return true;
      }

      function applyEffect(hero, action, targets) {
        // Validar que tenemos todos los datos necesarios
        if (
          !action ||
          !hero.clazz ||
          !classActions[hero.clazz] ||
          !classActions[hero.clazz][action]
        ) {
          console.error("ERROR: Datos inválidos para applyEffect", {
            hero: hero.clazz,
            action: action,
            hasClassActions: !!classActions[hero.clazz],
            hasAction: !!(
              classActions[hero.clazz] && classActions[hero.clazz][action]
            ),
          });
          return;
        }

        const actionData = classActions[hero.clazz][action];
        console.log(
          "Applying effect:",
          action,
          "from hero:",
          hero.clazz,
          "to targets:",
          targets.length,
          "action type:",
          actionData.type
        );

        // Reproducir sonido del hechizo inmediatamente
        playSpellSound(action, 0);

        // Feedback háptico al usar un hechizo
        triggerHapticFeedback();

        // Validación adicional para prevenir contaminación de targets
        if (actionData.type.includes("enemy") && targets.some((t) => t.clazz)) {
          console.error(
            "ERROR: Acción de enemigo aplicada a héroes!",
            action,
            targets
          );
          return;
        }
        if (actionData.type.includes("ally") && targets.some((t) => !t.clazz)) {
          console.error(
            "ERROR: Acción de aliado aplicada a enemigos!",
            action,
            targets
          );
          return;
        }

        // Nuevas mecánicas específicas por habilidad
        if (action === "combustion") {
          // Combustion: buff de críticos para el próximo ataque
          hero.buffs.push({
            type: "combustion",
            critBonus: actionData.critBonus,
            usesRemaining: 1, // Solo para el próximo ataque
          });
          // Agregar icono de combustion debuff
          addDebuff(hero, "combustion", 1);
          console.log(
            "Combustion buff applied to",
            hero.clazz,
            "- next attack will have high critical chance"
          );
          // Agregar efecto visual de combustion en el propio mago
          addCombustionEffect(hero.posx, hero.posy);
        } else if (action === "agony") {
          // Agony: reducción de daño del 20% a todos los aliados
          targets.forEach((target) => {
            if (target.hp > 0) {
              // Nuevo sistema: +20% defensa base durante 10 turnos globales
              const defBonus = Math.round((target.def || 0) * 0.2);
              target.buffs.push({
                type: "agony",
                remainingTurns: 10,
                defBonus,
              });
              addDebuff(target, "protection", 1); // Icono existente reutilizado
              console.log(
                "Agony (turn-based) aplicado a",
                target.clazz,
                "defBonus:",
                defBonus
              );
              addProtectionEffect([target]);
            }
          });
        } else if (action === "inmolation") {
          // Inmolation: daño a todos los enemigos + auto-daño al warlock
          targets.forEach((target) => {
            if (target.hp > 0) {
              let damage = actionData.damage;
              const criticalResult = calculateCritical(damage);
              const finalDamage = criticalResult.damage;
              const isCritical = criticalResult.isCritical;
              const effectiveDamage = Math.max(1, finalDamage - target.def);

              target.anim = "hurt";
              target.frame = 0;
              target.animStartTime = currentTime;
              target.hp = Math.max(0, target.hp - effectiveDamage);
              validateHP(target);

              // Sumar puntos por daño hecho a enemigos
              score += effectiveDamage;

              if (target.hp <= 0) {
                target.isDying = true;
                target.anim = "die";
                target.frame = 0;
                target.animStartTime = currentTime;
              }

              showHitNumber(
                target.posx,
                target.posy - 20,
                effectiveDamage,
                false,
                isCritical
              );
              clearEffectsByTypeAndPosition(
                "inmolation",
                target.posx,
                target.posy
              );
              addInmolationEffect(target.posx, target.posy);
            }
          });

          // Auto-daño al warlock (60% de su vida)
          const selfDamage = Math.floor(
            hero.maxhp * (actionData.selfDamage / 100)
          );
          hero.hp = Math.max(0, hero.hp - selfDamage); // Puede autodestruirse
          validateHP(hero);
          showHitNumber(hero.posx, hero.posy - 20, selfDamage, false, false);
          console.log("Inmolation self-damage:", selfDamage, "to", hero.clazz);
        } else if (action === "regrowth") {
          // Regrowth: curación por ticks a todos los aliados
          targets.forEach((target) => {
            if (target.hp > 0) {
              target.buffs.push({
                type: "regrowth",
                remainingTurns: 5, // 5 turnos globales
              });
              // Mostrar icono 'healing' (según nueva definición)
              addDebuff(target, "healing", 1);
              playHealingAnim(target, "regrowth");
              console.log("Regrowth (turn-based) aplicado a", target.clazz);
            }
          });
        } else if (action === "darkslash") {
          // Dark Slash: daño normal + aplicar/stackear debuff Shadows
          targets.forEach((target) => {
            if (target.hp > 0) {
              // Aplicar daño normal primero
              let damage = calculateRandomValue(actionData.damage, 20);
              let criticalChance = 15;

              const criticalResult = calculateCritical(damage, criticalChance);
              const finalDamage = criticalResult.damage;
              const isCritical = criticalResult.isCritical;

              target.hp = Math.max(0, target.hp - finalDamage);
              validateHP(target);

              showHitNumber(
                target.posx,
                target.posy - 20,
                finalDamage,
                false,
                isCritical
              );

              // Aplicar o stackear debuff Shadows
              const existingShadows = target.debuffs.find(
                (d) => d.type === "shadows"
              );
              if (existingShadows) {
                existingShadows.stacks = (existingShadows.stacks || 1) + 1;
                existingShadows.remainingTurns = 10; // Reinicia duración en turnos
                existingShadows.damagePerTick =
                  (existingShadows.damagePerTick || 2) + 1; // +1 daño por stack
                if (!existingShadows.icon)
                  existingShadows.icon = getDebuffIcon("shadows");
                console.log(
                  `Shadows stack (${existingShadows.stacks}) en ${
                    target.type || target.clazz
                  }. Daño por tick: ${existingShadows.damagePerTick}`
                );
              } else {
                target.debuffs.push({
                  type: "shadows",
                  remainingTurns: 10,
                  damagePerTick: 2 + Math.floor(Math.random() * 2), // 2-3
                  stacks: 1,
                  icon: getDebuffIcon("shadows"),
                });
                console.log(
                  `Shadows aplicado a ${target.type || target.clazz}`
                );
              }

              // Efectos visuales
              clearEffectsByTypeAndPosition("slash", target.posx, target.posy);
              addSlashEffect(target.posx, target.posy);

              if (target.hp <= 0) {
                target.isDying = true;
                target.anim = "die";
                target.frame = 0;
                target.animStartTime = currentTime;
                // Trigger haptic feedback when enemy dies
                triggerHapticFeedback();
              }
            }
          });
        } else if (actionData.type.includes("enemy")) {
          // Habilidades de daño normales
          targets.forEach((target) => {
            if (target.hp > 0) {
              // Aplicar variación aleatoria al daño base
              let damage = calculateRandomValue(actionData.damage, 20); // ±20% de variación

              // Aplicar buff de combustion si existe
              let criticalChance = 15; // Base 15%
              const combustionBuff = hero.buffs.find(
                (b) => b.type === "combustion"
              );
              if (combustionBuff) {
                criticalChance += combustionBuff.critBonus;
                // Consumir el buff después de usarlo
                combustionBuff.usesRemaining--;
                if (combustionBuff.usesRemaining <= 0) {
                  // Marcar para eliminación
                  combustionBuff.toRemove = true;
                }
              }

              const criticalResult = calculateCritical(damage, criticalChance);
              const finalDamage = criticalResult.damage;
              const isCritical = criticalResult.isCritical;
              const effectiveDamage = Math.max(1, finalDamage - target.def);

              target.anim = "hurt";
              target.frame = 0;
              target.animStartTime = currentTime;
              target.hp = Math.max(0, target.hp - effectiveDamage);
              validateHP(target);

              // Sumar puntos por daño hecho a enemigos
              score += effectiveDamage;

              if (target.hp <= 0) {
                target.isDying = true;
                target.anim = "die";
                target.frame = 0;
                target.animStartTime = currentTime;
              }

              showHitNumber(
                target.posx,
                target.posy - 20,
                effectiveDamage,
                false,
                isCritical
              );

              // Efectos visuales específicos por habilidad
              if (action === "fireblast") {
                clearEffectsByTypeAndPosition(
                  "fireblast",
                  target.posx,
                  target.posy
                );
                addFireblastEffect(target.posx, target.posy);
              } else if (action === "inferno") {
                clearEffectsByTypeAndPosition(
                  "conflagration",
                  target.posx,
                  target.posy
                );
                addConflagrationEffect(target.posx, target.posy);
              } else if (action === "darkslash") {
                clearEffectsByTypeAndPosition(
                  "slash",
                  target.posx,
                  target.posy
                );
                addSlashEffect(target.posx, target.posy);
              } else if (action === "smite") {
                clearEffectsByTypeAndPosition(
                  "smite",
                  target.posx,
                  target.posy
                );
                addSmiteEffect(target.posx, target.posy);
              }
            }
          });
        } else if (
          actionData.type.includes("ally") ||
          actionData.type === "self"
        ) {
          // Habilidades de curación normales
          targets.forEach((target) => {
            // Verificar si el objetivo puede recibir curación
            // Solo bloquear si tiene debuff de regrowth Y estamos aplicando regrowth
            const hasRegrowthDebuff =
              target.debuffs &&
              target.debuffs.some((d) => d.type === "regrowth");
            const isRegrowthAction = action === "regrowth";
            const shouldBlockHealing = hasRegrowthDebuff && isRegrowthAction;

            if (actionData.heal && !shouldBlockHealing) {
              // Verificar si el objetivo está vivo AL MOMENTO de aplicar el efecto
              // (esto permite que la curación falle si el objetivo muere durante la animación)
              if (target.hp > 0) {
                // Aplicar variación aleatoria a la curación
                const healAmount = calculateRandomValue(actionData.heal, 20); // ±20% de variación
                target.hp = Math.min(target.maxhp, target.hp + healAmount);
                validateHP(target);

                // Determinar tipo de curación para el efecto visual correcto
                const healType = action === "holywave" ? "holywave" : "healing";
                playHealingAnim(target, healType);

                showHitNumber(target.posx, target.posy - 20, healAmount, true);
                console.log(
                  "Healing",
                  healAmount,
                  "to",
                  target.clazz || "target"
                );
              } else if (target.hp <= 0) {
                // Revivir al héroe muerto con la cantidad de curación
                const healAmount = calculateRandomValue(actionData.heal, 20); // ±20% de variación
                target.hp = Math.min(target.maxhp, healAmount);
                validateHP(target);

                // Determinar tipo de curación para el efecto visual correcto
                const healType = action === "holywave" ? "holywave" : "healing";
                playHealingAnim(target, healType);

                showHitNumber(target.posx, target.posy - 20, healAmount, true);
                console.log(
                  "Reviving and healing",
                  healAmount,
                  "to",
                  target.clazz || "target"
                );
              }
            } else if (hasHealingDebuff) {
              console.log(
                `${target.clazz} cannot be healed due to healing debuff.`
              );
            }
          });
        }

        checkWaveCleared();
        checkGameOver();

        // Limpiar buffs de combustion consumidos
        hero.buffs = hero.buffs.filter((b) => {
          if (b.toRemove && b.type === "combustion") {
            // Remover también el debuff visual
            removeDebuff(hero, "combustion");
            console.log(
              "Combustion buff consumed and removed from",
              hero.clazz
            );
            return false;
          }
          return true;
        });

        // Resetear selección después de aplicar efectos
        selectedHero = null;
        selectedAction = null;
      }

      function playHealingAnim(target, healType = "healing") {
        // En lugar de cambiar la animación del héroe, crear un efecto visual separado
        console.log(
          "Creando efecto visual de curación para",
          target.clazz,
          "tipo:",
          healType
        );

        if (healType === "holywave") {
          addHolyWaveEffect(target.posx, target.posy);
        } else if (healType === "regrowth") {
          addRegrowthEffect(target.posx, target.posy);
        } else {
          addHealingEffect(target.posx, target.posy);
        }
      }

      function showHitNumber(
        x,
        y,
        value,
        isHealing = false,
        isCritical = false
      ) {
        hitNumbers.push({
          x: x,
          y: y,
          value: value,
          isHealing: isHealing,
          isCritical: isCritical,
          opacity: 1.0,
          startTime: currentTime,
          duration: 1.5, // duración en segundos
        });
      }

      function clearEffectsByTypeAndPosition(effectType, x, y) {
        // Eliminar solo los efectos del tipo especificado en la posición específica (mismo enemigo)
        const initialCount = visualEffects.length;
        for (let i = visualEffects.length - 1; i >= 0; i--) {
          const effect = visualEffects[i];
          if (
            effect.type === effectType &&
            Math.abs(effect.x - x) < 10 &&
            Math.abs(effect.y - y) < 10
          ) {
            visualEffects.splice(i, 1);
          }
        }
        const removedCount = initialCount - visualEffects.length;
        if (removedCount > 0) {
          console.log(
            `Eliminados ${removedCount} efectos de tipo ${effectType} en posición ${x},${y}`
          );
        }
      }

      function addFireblastEffect(x, y) {
        visualEffects.push({
          type: "fireblast",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.4, // Duración original
          frame: 0,
          frameCount: 4,
          frameWidth: 32,
          frameHeight: 32,
          size: 64, // Tamaño más grande
          repeat: 0, // Contador de repeticiones
          maxRepeats: 2, // Se repetirá 2 veces (total 3 reproducciones)
          endTime: currentTime + 0.4 * 3, // Tiempo absoluto de finalización (3 repeticiones)
        });
      }

      function addConflagrationEffect(x, y) {
        visualEffects.push({
          type: "conflagration",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.4, // Duración original
          frame: 0,
          frameCount: 4,
          frameWidth: 32,
          frameHeight: 32,
          size: 64, // Tamaño más grande
          repeat: 0, // Contador de repeticiones
          maxRepeats: 2, // Se repetirá 2 veces (total 3 reproducciones)
          endTime: currentTime + 0.4 * 3, // Tiempo absoluto de finalización (3 repeticiones)
        });
      }

      function addSlashEffect(x, y) {
        console.log("Añadiendo efecto slash en posición", x, y);
        visualEffects.push({
          type: "slash",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.4, // Duración original
          frame: 0,
          frameCount: 4, // Frames 17, 18, 19, 20
          frameWidth: 32,
          frameHeight: 32,
          size: 64, // Tamaño más grande
          repeat: 0, // Contador de repeticiones
          maxRepeats: 2, // Se repetirá 2 veces (total 3 reproducciones)
          endTime: currentTime + 0.4 * 3, // Tiempo absoluto de finalización (3 repeticiones)
        });
      }

      function addHealingEffect(x, y) {
        console.log("Añadiendo efecto visual de curación en posición", x, y);
        visualEffects.push({
          type: "healing",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.0, // Duración más larga para aprovechar todos los frames
          frame: 0,
          frameCount: 7, // 7 frames totales (5 en primera fila + 2 en segunda)
          frameWidth: 96, // Nuevo tamaño de frame
          frameHeight: 96, // Nuevo tamaño de frame
          size: 120, // Tamaño renderizado más grande para mejor visibilidad
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 1.0,
        });
      }

      function addHolyWaveEffect(x, y) {
        console.log("Añadiendo efecto visual de Holy Wave en posición", x, y);
        visualEffects.push({
          type: "holy_wave",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.8, // Duración reducida para animación más fluida (era 1.6)
          frame: 0,
          frameCount: 11, // 11 frames en total (3 filas: 5+5+1)
          frameWidth: 128, // 640px / 5 frames por fila
          frameHeight: 128, // 384px / 3 filas
          size: 130, // Tamaño más grande para mejor visibilidad
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 0.8,
        });
      }

      function addRegrowthEffect(x, y) {
        console.log("Añadiendo efecto visual de Regrowth en posición", x, y);
        visualEffects.push({
          type: "regrowth_new",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.9, // Duración reducida para animación más fluida (era 1.8)
          frame: 0,
          frameCount: 12, // 12 frames en total (3 filas: 5+5+2)
          frameWidth: 128, // 640px / 5 frames por fila
          frameHeight: 128, // 384px / 3 filas
          size: 125, // Tamaño apropiado para regeneración
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 0.9,
        });
      }

      function addCombustionEffect(x, y) {
        console.log("Añadiendo efecto visual de combustion en posición", x, y);
        visualEffects.push({
          type: "combustion",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.8, // Duración reducida para animación más rápida (era 1.3s)
          frame: 0,
          frameCount: 26, // 26 frames en total
          frameWidth: 96, // 96x96 cada frame
          frameHeight: 96,
          size: 120, // Tamaño apropiado para el nuevo sprite
          repeat: 0,
          maxRepeats: 0, // Solo una reproducción
          endTime: currentTime + 0.8, // Tiempo absoluto de finalización actualizado
        });
      }

      function addSmiteEffect(x, y) {
        console.log("Añadiendo efecto visual de smite en posición", x, y);
        visualEffects.push({
          type: "smite",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.75, // Duración reducida para animación más fluida (era 1.5)
          frame: 0,
          frameCount: 10, // 10 frames en total (2 filas de 5 cada una)
          frameWidth: 128, // 640px / 5 frames por fila (asumiendo 640px total)
          frameHeight: 128, // 256px / 2 filas (asumiendo 256px total)
          size: 120, // Tamaño más grande para mejor impacto visual
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 0.75,
        });
      }

      function addInmolationEffect(x, y) {
        console.log("Añadiendo efecto visual de inmolation en posición", x, y);
        visualEffects.push({
          type: "inmolation",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.1, // Duración para 11 frames
          frame: 0,
          frameCount: 11, // 11 frames de dark bolt
          frameWidth: 64,
          frameHeight: 88,
          size: 90, // Tamaño apropiado para el efecto de dark bolt
          repeat: 0,
          maxRepeats: 1, // Se repite una vez (total 2 reproducciones)
          endTime: currentTime + 1.1 * 2, // Tiempo absoluto de finalización
        });
      }

      function addBloodSplatEffect(x, y) {
        console.log("Añadiendo efecto visual de Blood Splat en posición", x, y);
        visualEffects.push({
          type: "blood_splat",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.5, // Duración aumentada para 10 frames
          frame: 0,
          frameCount: 10, // 10 frames en total (2 filas de 5 cada una)
          frameWidth: 128, // 640px / 5 frames por fila
          frameHeight: 128, // 256px / 2 filas
          size: 140, // Tamaño más grande para mejor impacto visual
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 1.5,
        });
      }

      function addBloodStormEffect(x, y) {
        console.log("Añadiendo efecto visual de Blood Storm en posición", x, y);
        visualEffects.push({
          type: "blood_storm",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.2, // Duración para 9 frames
          frame: 0,
          frameCount: 9, // 9 frames en total (2 filas: 5+4)
          frameWidth: 192, // 960px / 5 frames por fila
          frameHeight: 128, // 256px / 2 filas
          size: 150, // Tamaño más grande para AoE
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 1.2,
        });
      }

      function addMinotaurSmashEffect(x, y) {
        console.log(
          "Añadiendo efecto visual de Minotaur Smash en posición",
          x,
          y
        );
        visualEffects.push({
          type: "minotaur_smash",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.8, // Duración reducida para animación más fluida (era 1.6)
          frame: 0,
          frameCount: 8, // 8 frames en total (4 filas, 2 columnas)
          frameWidth: 128, // 256px / 2 columnas
          frameHeight: 160, // 640px / 4 filas
          size: 160, // Tamaño grande para impacto
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 0.8,
        });
      }

      function addMinotaurLifeStealEffect(x, y) {
        console.log(
          "Añadiendo efecto visual de Minotaur Life Steal en posición",
          x,
          y
        );
        visualEffects.push({
          type: "minotaur_life_steal",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 0.8, // Duración reducida para animación más fluida (era 1.6)
          frame: 0,
          frameCount: 8, // 8 frames en total (4 filas, 2 columnas)
          frameWidth: 128, // 256px / 2 columnas
          frameHeight: 128, // 512px / 4 filas
          size: 150, // Tamaño apropiado para AoE
          repeat: 0,
          maxRepeats: 0, // Solo se reproduce una vez
          endTime: currentTime + 0.8,
        });
      }

      function addLavaEffect(x, y) {
        visualEffects.push({
          type: "lava",
          x: x,
          y: y + 30, // Debajo del enemigo
          startTime: currentTime,
          duration: 0.5, // 1/2 segundo
          particles: [],
        });
      }

      function addProtectionEffect(heroes) {
        heroes.forEach((hero) => {
          if (hero.hp > 0) {
            visualEffects.push({
              type: "protection",
              x: hero.posx,
              y: hero.posy,
              startTime: currentTime,
              duration: 1.0, // 1 segundo
              radius: 0,
            });
          }
        });
      }

      function addPoisonEffect(x, y) {
        console.log("Añadiendo efecto visual de veneno en posición", x, y);
        visualEffects.push({
          type: "poison",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 2.0, // 2 segundos para mejor visibilidad
          radius: 0,
          particles: [],
        });
      }

      function addPoisonMainEffect(x, y) {
        console.log("Añadiendo efecto visual de Poison Main en posición", x, y);
        visualEffects.push({
          type: "poison_main",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.0, // 1 segundo de duración
          frame: 0,
          frameWidth: 96, // Ancho de cada frame
          frameHeight: 96, // Alto de cada frame
          totalFrames: 31, // 31 frames en el sprite
          frameRate: 30, // 30 fps para animación rápida
        });
      }

      function addCosmicHorrorEffect(x, y) {
        console.log(
          "Añadiendo efecto visual de Cosmic Horror en posición",
          x,
          y
        );
        visualEffects.push({
          type: "cosmic_horror",
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.5, // 1.5 segundos de duración
          radius: 0,
          particles: [],
          intensity: 1.0,
        });
      }

      function addTentacleStrikeEffect(x, y) {
        console.log(
          "Añadiendo efecto visual de Tentacle Strike en posición",
          x,
          y
        );
        visualEffects.push({
          type: "cthulu_main", // Usar nuevo efecto específico
          x: x,
          y: y,
          startTime: currentTime,
          duration: 1.0, // Duración reducida para animación más rápida (era 1.55s)
          frame: 0,
          frameCount: 31, // 31 frames en total
          frameWidth: 96, // 96x96 cada frame
          frameHeight: 96,
          size: 120, // Tamaño apropiado
        });
      }

      function addToxicHorrorEffect(x, y) {
        console.log(
          "Añadiendo efecto visual de Toxic Horror para todos los aliados"
        );
        // Crear efecto en cada héroe vivo
        heroes.forEach((hero) => {
          if (hero.hp > 0) {
            visualEffects.push({
              type: "cthulu_special", // Usar nuevo efecto específico
              x: hero.posx,
              y: hero.posy,
              startTime: currentTime,
              duration: 1.2, // Duración reducida para animación más rápida (era 2.0s)
              frame: 0,
              frameCount: 40, // 40 frames en total
              frameWidth: 96, // 96x96 cada frame
              frameHeight: 96,
              size: 120, // Tamaño apropiado
            });
          }
        });
      }

      function addMeteorEffect(x, y) {
        visualEffects.push({
          type: "meteor",
          x: x,
          y: y - 150, // Empezar desde arriba
          targetX: x,
          targetY: y,
          startTime: currentTime,
          duration: 0.8, // 0.8 segundos para caer
          trail: [], // Estela del meteorito
          impacted: false,
        });
      }

      function updateHitNumbers(dt) {
        for (let i = hitNumbers.length - 1; i >= 0; i--) {
          const hitNum = hitNumbers[i];
          const elapsed = currentTime - hitNum.startTime;

          // Mover hacia arriba
          hitNum.y -= 30 * dt;

          // Fade out
          hitNum.opacity = Math.max(0, 1 - elapsed / hitNum.duration);

          // Eliminar cuando termine la animación
          if (elapsed >= hitNum.duration) {
            hitNumbers.splice(i, 1);
          }
        }
      }

      function updateVisualEffects(dt) {
        for (let i = visualEffects.length - 1; i >= 0; i--) {
          const effect = visualEffects[i];
          const elapsed = currentTime - effect.startTime;

          if (effect.type === "fireblast") {
            // Actualizar frame del efecto de fireblast con repeticiones
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Si completó una animación, resetear para repetir
            if (effect.frame >= effect.frameCount) {
              if (effect.repeat < effect.maxRepeats) {
                effect.repeat++;
                effect.startTime = currentTime; // Reiniciar tiempo
                effect.frame = 0;
              }
            }
          } else if (effect.type === "conflagration") {
            // Actualizar frame del efecto de conflagration con repeticiones
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Si completó una animación, resetear para repetir
            if (effect.frame >= effect.frameCount) {
              if (effect.repeat < effect.maxRepeats) {
                effect.repeat++;
                effect.startTime = currentTime; // Reiniciar tiempo
                effect.frame = 0;
              }
            }
          } else if (effect.type === "slash") {
            // Actualizar frame del efecto de slash con repeticiones
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Si completó una animación, resetear para repetir
            if (effect.frame >= effect.frameCount) {
              if (effect.repeat < effect.maxRepeats) {
                effect.repeat++;
                effect.startTime = currentTime; // Reiniciar tiempo
                effect.frame = 0;
              }
            }
          } else if (effect.type === "healing") {
            // Actualizar frame del efecto de curación
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "holy_wave") {
            // Actualizar frame del efecto de Holy Wave
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "regrowth_new") {
            // Actualizar frame del efecto de Regrowth mejorado
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "combustion") {
            // Actualizar frame del efecto de combustion (nueva versión sin repeticiones)
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);
          } else if (effect.type === "cthulu_main") {
            // Actualizar frame del efecto principal de Cthulhu
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);
          } else if (effect.type === "poison_main") {
            // Actualizar frame del efecto principal de veneno del Gorgon
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.totalFrames;
            effect.frame = Math.floor(elapsed / frameDuration);
          } else if (effect.type === "cthulu_special") {
            // Actualizar frame del efecto especial de Cthulhu
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);
          } else if (effect.type === "smite") {
            // Actualizar frame del efecto de smite
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "inmolation") {
            // Actualizar frame del efecto de inmolation con repeticiones
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Si completó una animación, resetear para repetir
            if (effect.frame >= effect.frameCount) {
              if (effect.repeat < effect.maxRepeats) {
                effect.repeat++;
                effect.startTime = currentTime; // Reiniciar tiempo
                effect.frame = 0;
              }
            }
          } else if (effect.type === "blood_splat") {
            // Actualizar frame del efecto de Blood Splat
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "blood_storm") {
            // Actualizar frame del efecto de Blood Storm
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "minotaur_smash") {
            // Actualizar frame del efecto de Minotaur Smash
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "minotaur_life_steal") {
            // Actualizar frame del efecto de Minotaur Life Steal
            const elapsed = currentTime - effect.startTime;
            const frameDuration = effect.duration / effect.frameCount;
            effect.frame = Math.floor(elapsed / frameDuration);

            // Mantener en el último frame si se completa
            if (effect.frame >= effect.frameCount) {
              effect.frame = effect.frameCount - 1;
            }
          } else if (effect.type === "lava") {
            // Generar más partículas de lava (más intenso)
            if (Math.random() < 0.6) {
              // Era 0.3, ahora es 0.6
              effect.particles.push({
                x: effect.x + (Math.random() - 0.5) * 80, // Área más grande
                y: effect.y,
                vy: -40 - Math.random() * 50, // Velocidad más alta
                life: 0.5 + Math.random() * 0.4, // Vida más larga
                maxLife: 0.5 + Math.random() * 0.4,
              });
            }

            // Actualizar partículas
            for (let j = effect.particles.length - 1; j >= 0; j--) {
              const particle = effect.particles[j];
              particle.y += particle.vy * dt;
              particle.life -= dt;
              if (particle.life <= 0) {
                effect.particles.splice(j, 1);
              }
            }
          } else if (effect.type === "protection") {
            // Expandir el escudo
            effect.radius = (elapsed / effect.duration) * 50;
          } else if (effect.type === "poison") {
            // Expandir el efecto de veneno y generar partículas tóxicas
            effect.radius = (elapsed / effect.duration) * 40;

            // Generar partículas de veneno
            if (Math.random() < 0.4) {
              effect.particles.push({
                x: effect.x + (Math.random() - 0.5) * 60,
                y: effect.y + (Math.random() - 0.5) * 60,
                vy: -20 - Math.random() * 30,
                life: 0.8 + Math.random() * 0.6,
                maxLife: 0.8 + Math.random() * 0.6,
              });
            }

            // Actualizar partículas de veneno
            for (let j = effect.particles.length - 1; j >= 0; j--) {
              const particle = effect.particles[j];
              particle.y += particle.vy * dt;
              particle.life -= dt;
              if (particle.life <= 0) {
                effect.particles.splice(j, 1);
              }
            }
          } else if (effect.type === "cosmic_horror") {
            // Efecto de Horror Cósmico - ondas expansivas y distorsión
            effect.radius = (elapsed / effect.duration) * 80;
            effect.intensity = 1 - elapsed / effect.duration;

            // Generar partículas de energía cósmica
            if (Math.random() < 0.6) {
              effect.particles.push({
                x: effect.x + (Math.random() - 0.5) * 100,
                y: effect.y + (Math.random() - 0.5) * 100,
                vy: -30 - Math.random() * 40,
                vx: (Math.random() - 0.5) * 60,
                life: 1.0 + Math.random() * 0.5,
                maxLife: 1.0 + Math.random() * 0.5,
              });
            }

            // Actualizar partículas cósmicas
            for (let j = effect.particles.length - 1; j >= 0; j--) {
              const particle = effect.particles[j];
              particle.x += particle.vx * dt;
              particle.y += particle.vy * dt;
              particle.life -= dt;
              if (particle.life <= 0) {
                effect.particles.splice(j, 1);
              }
            }
          } else if (effect.type === "tentacle_strike") {
            // Efecto de Golpe de Tentáculo - tentáculos serpenteantes
            effect.radius = (elapsed / effect.duration) * 60;

            // Generar partículas de tentáculos
            if (Math.random() < 0.5) {
              effect.particles.push({
                x: effect.x + (Math.random() - 0.5) * 80,
                y: effect.y + (Math.random() - 0.5) * 80,
                vy: -25 - Math.random() * 35,
                vx: (Math.random() - 0.5) * 50,
                life: 0.8 + Math.random() * 0.4,
                maxLife: 0.8 + Math.random() * 0.4,
              });
            }

            // Actualizar partículas de tentáculos
            for (let j = effect.particles.length - 1; j >= 0; j--) {
              const particle = effect.particles[j];
              particle.x += particle.vx * dt;
              particle.y += particle.vy * dt;
              particle.life -= dt;
              if (particle.life <= 0) {
                effect.particles.splice(j, 1);
              }
            }
          } else if (effect.type === "meteor") {
            // Animación del meteorito cayendo
            const progress = Math.min(elapsed / effect.duration, 1);
            const easeProgress = 1 - Math.pow(1 - progress, 3); // Easing para aceleración

            effect.x = effect.targetX;
            effect.y = effect.targetY - 150 + 150 * easeProgress;

            // Agregar punto a la estela
            effect.trail.push({ x: effect.x, y: effect.y, life: 0.3 });

            // Actualizar estela
            for (let j = effect.trail.length - 1; j >= 0; j--) {
              effect.trail[j].life -= dt;
              if (effect.trail[j].life <= 0) {
                effect.trail.splice(j, 1);
              }
            }

            // Impacto al llegar al suelo
            if (progress >= 1 && !effect.impacted) {
              effect.impacted = true;
              // Crear efecto de explosión
              for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                effect.trail.push({
                  x: effect.targetX + Math.cos(angle) * 20,
                  y: effect.targetY + Math.sin(angle) * 20,
                  life: 0.5,
                });
              }
            }
          }

          // Eliminar efecto cuando termine (considerando repeticiones)
          if (
            effect.type === "fireblast" ||
            effect.type === "conflagration" ||
            effect.type === "slash" ||
            effect.type === "combustion" ||
            effect.type === "inmolation" ||
            effect.type === "blood_splat" ||
            effect.type === "blood_storm" ||
            effect.type === "minotaur_smash" ||
            effect.type === "minotaur_life_steal"
          ) {
            // Para efectos con repeticiones, eliminar cuando se haya superado el tiempo absoluto de finalización
            if (currentTime >= effect.endTime) {
              visualEffects.splice(i, 1);
            }
          } else if (elapsed >= effect.duration) {
            // Para otros efectos (healing, holy_wave, regrowth_new, smite, lava, protection, meteor), eliminar normalmente
            visualEffects.splice(i, 1);
          }
        }
      }

      function renderHitNumbers() {
        ctx.save();
        ctx.textAlign = "center";

        hitNumbers.forEach((hitNum) => {
          ctx.globalAlpha = hitNum.opacity;

          // Configurar estilo según el tipo de hit
          if (hitNum.isCritical) {
            ctx.font = "bold 22px monospace"; // Reducido de 28px a 22px
            ctx.fillStyle = "#FFD700"; // Amarillo dorado para críticos
            ctx.lineWidth = 4;
          } else if (hitNum.isHealing) {
            ctx.font = "bold 20px monospace";
            ctx.fillStyle = "#00ff00"; // Verde para curación
            ctx.lineWidth = 3;
          } else {
            ctx.font = "bold 20px monospace";
            ctx.fillStyle = "#ff0000"; // Rojo para daño normal
            ctx.lineWidth = 3;
          }

          // Sombra para mejor visibilidad
          ctx.strokeStyle = "#000000";

          let text;
          if (hitNum.isCritical) {
            text = `CRIT! -${hitNum.value}`;
          } else if (hitNum.isHealing) {
            text = `+${hitNum.value}`;
          } else {
            text = `-${hitNum.value}`;
          }

          ctx.strokeText(text, hitNum.x, hitNum.y);
          ctx.fillText(text, hitNum.x, hitNum.y);
        });

        ctx.restore();
      }

      function renderVisualEffects() {
        ctx.save();

        visualEffects.forEach((effect) => {
          const elapsed = currentTime - effect.startTime;
          const progress = elapsed / effect.duration;

          if (effect.type === "fireblast") {
            // Renderizar efecto de fireblast usando sprites - más grande
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = (7 + effect.frame) * effect.frameWidth; // Frames 8,9,10,11 (posiciones 7,8,9,10)
              const sy = 15 * effect.frameHeight; // Fila 15 (empezando desde 0)

              const renderSize = effect.size || 64;
              ctx.drawImage(
                effectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "conflagration") {
            // Renderizar efecto de conflagration usando sprites - más grande
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = (6 + effect.frame) * effect.frameWidth; // Frames 6,7,8,9 (posiciones 6,7,8,9)
              const sy = 0 * effect.frameHeight; // Fila 0 (empezando desde 0)

              const renderSize = effect.size || 64;
              ctx.drawImage(
                effectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "slash") {
            // Renderizar efecto de slash usando sprites púrpura - más grande
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = (17 + effect.frame) * effect.frameWidth; // Frames 17,18,19,20 (posiciones 17,18,19,20)
              const sy = 11 * effect.frameHeight; // Fila 11 (empezando desde 0)

              const renderSize = effect.size || 64;
              ctx.drawImage(
                purpleEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "healing") {
            // Renderizar efecto de curación usando el nuevo sprite específico
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame: 5 frames en primera fila, 2 en segunda
              let sx, sy;
              if (effect.frame < 5) {
                // Primera fila (frames 0-4)
                sx = effect.frame * effect.frameWidth;
                sy = 0;
              } else {
                // Segunda fila (frames 5-6)
                sx = (effect.frame - 5) * effect.frameWidth;
                sy = effect.frameHeight;
              }

              const renderSize = effect.size || 120; // Tamaño por defecto más grande
              ctx.drawImage(
                healingEffectsImg, // Usar el nuevo sprite de curación
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "combustion") {
            // Renderizar efecto de combustion usando el nuevo sprite mejorado
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = effect.frame * effect.frameWidth; // 26 frames en una sola fila
              const sy = 0; // Solo una fila

              const renderSize = effect.size || 120;
              ctx.drawImage(
                combustionEffectsImg, // Usar la nueva imagen
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "smite") {
            // Renderizar efecto de smite usando el nuevo sprite mejorado
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame: 5 frames en primera fila, 5 en segunda
              let sx, sy;
              if (effect.frame < 5) {
                // Primera fila (frames 0-4)
                sx = effect.frame * effect.frameWidth;
                sy = 0;
              } else {
                // Segunda fila (frames 5-9)
                sx = (effect.frame - 5) * effect.frameWidth;
                sy = effect.frameHeight;
              }

              const renderSize = effect.size || 120;
              ctx.drawImage(
                priestSmiteEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "holy_wave") {
            // Renderizar efecto de Holy Wave
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame: 5 frames en primera fila, 5 en segunda, 1 en tercera
              let sx, sy;
              if (effect.frame < 5) {
                // Primera fila (frames 0-4)
                sx = effect.frame * effect.frameWidth;
                sy = 0;
              } else if (effect.frame < 10) {
                // Segunda fila (frames 5-9)
                sx = (effect.frame - 5) * effect.frameWidth;
                sy = effect.frameHeight;
              } else {
                // Tercera fila (frame 10)
                sx = (effect.frame - 10) * effect.frameWidth;
                sy = effect.frameHeight * 2;
              }

              const renderSize = effect.size || 130;
              ctx.drawImage(
                priestHolyWaveEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "regrowth_new") {
            // Renderizar efecto de Regrowth mejorado
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame: 5 frames en primera fila, 5 en segunda, 2 en tercera
              let sx, sy;
              if (effect.frame < 5) {
                // Primera fila (frames 0-4)
                sx = effect.frame * effect.frameWidth;
                sy = 0;
              } else if (effect.frame < 10) {
                // Segunda fila (frames 5-9)
                sx = (effect.frame - 5) * effect.frameWidth;
                sy = effect.frameHeight;
              } else {
                // Tercera fila (frames 10-11)
                sx = (effect.frame - 10) * effect.frameWidth;
                sy = effect.frameHeight * 2;
              }

              const renderSize = effect.size || 125;
              ctx.drawImage(
                priestRegrowthEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "inmolation") {
            // Renderizar efecto de inmolation usando sprite de dark bolt
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = effect.frame * effect.frameWidth; // Frames 0-10
              const sy = 0; // Solo una fila

              const renderSize = effect.size || 90;
              ctx.drawImage(
                darkBoltEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "lava") {
            // Renderizar partículas de lava
            effect.particles.forEach((particle) => {
              const alpha = particle.life / particle.maxLife;
              ctx.globalAlpha = alpha;

              // Gradiente de colores más intenso: rojo-naranja-amarillo-blanco
              const colors = [
                "#ff0000",
                "#ff2200",
                "#ff4500",
                "#ff6600",
                "#ffa500",
                "#ffcc00",
                "#ffff00",
                "#ffffff",
              ];
              const colorIndex = Math.floor((1 - alpha) * (colors.length - 1));
              ctx.fillStyle = colors[colorIndex];

              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 4, 0, Math.PI * 2); // Partículas más grandes
              ctx.fill();

              // Brillo adicional
              ctx.globalAlpha = alpha * 0.5;
              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 6, 0, Math.PI * 2);
              ctx.fill();
            });

            // Base de lava burbujeante más intensa
            ctx.globalAlpha = 1 - progress;
            ctx.fillStyle = "#ff2200";
            for (let i = 0; i < 8; i++) {
              // Más burbujas
              const bubbleX = effect.x + (Math.random() - 0.5) * 70; // Área más grande
              const bubbleY = effect.y + Math.random() * 15;
              const bubbleSize = 3 + Math.random() * 6; // Burbujas más grandes
              ctx.beginPath();
              ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
              ctx.fill();
            }

            // Resplandor de base
            ctx.globalAlpha = (1 - progress) * 0.3;
            ctx.fillStyle = "#ff4500";
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, 30, 0, Math.PI * 2);
            ctx.fill();
          } else if (effect.type === "protection") {
            // Renderizar escudo de protección
            ctx.globalAlpha = Math.max(0, 1 - progress);
            ctx.strokeStyle = "#8A2BE2"; // Púrpura neón
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.stroke();

            // Brillo interior
            ctx.globalAlpha = Math.max(0, (1 - progress) * 0.3);
            ctx.fillStyle = "#9370DB"; // Púrpura más claro para el interior
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.fill();
          } else if (effect.type === "poison") {
            // Renderizar partículas de veneno
            effect.particles.forEach((particle) => {
              const alpha = particle.life / particle.maxLife;
              ctx.globalAlpha = alpha;

              // Colores tóxicos: verde ácido
              const colors = ["#00ff00", "#32cd32", "#adff2f", "#7fff00"];
              const colorIndex = Math.floor((1 - alpha) * (colors.length - 1));
              ctx.fillStyle = colors[colorIndex];

              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
              ctx.fill();

              // Brillo tóxico
              ctx.globalAlpha = alpha * 0.6;
              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 5, 0, Math.PI * 2);
              ctx.fill();
            });

            // Base de veneno burbujeante
            ctx.globalAlpha = Math.max(0, 1 - progress);
            ctx.strokeStyle = "#00ff00"; // Verde tóxico
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.stroke();

            // Resplandor interior venenoso
            ctx.globalAlpha = Math.max(0, (1 - progress) * 0.4);
            ctx.fillStyle = "#32cd32"; // Verde lima para el interior
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.fill();
          } else if (effect.type === "cosmic_horror") {
            // Renderizar efecto de Horror Cósmico
            const progress = (currentTime - effect.startTime) / effect.duration;

            // Renderizar partículas de energía cósmica
            effect.particles.forEach((particle) => {
              const alpha = particle.life / particle.maxLife;
              ctx.globalAlpha = alpha;

              // Colores cósmicos: púrpura oscuro y azul profundo
              const colors = ["#4B0082", "#8A2BE2", "#9400D3", "#6A0DAD"];
              const colorIndex = Math.floor((1 - alpha) * (colors.length - 1));
              ctx.fillStyle = colors[colorIndex];

              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 4, 0, Math.PI * 2);
              ctx.fill();

              // Resplandor cósmico
              ctx.globalAlpha = alpha * 0.5;
              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 7, 0, Math.PI * 2);
              ctx.fill();
            });

            // Ondas expansivas de horror cósmico
            ctx.globalAlpha = effect.intensity * 0.6;
            ctx.strokeStyle = "#4B0082"; // Púrpura profundo
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.stroke();

            // Distorsión central
            ctx.globalAlpha = effect.intensity * 0.3;
            ctx.fillStyle = "#9400D3"; // Violeta oscuro
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius * 0.5, 0, Math.PI * 2);
            ctx.fill();
          } else if (effect.type === "tentacle_strike") {
            // Renderizar efecto de Golpe de Tentáculo
            const progress = (currentTime - effect.startTime) / effect.duration;

            // Renderizar partículas de tentáculos
            effect.particles.forEach((particle) => {
              const alpha = particle.life / particle.maxLife;
              ctx.globalAlpha = alpha;

              // Colores de tentáculos: verde oscuro y marrón
              const colors = ["#2F4F2F", "#556B2F", "#6B8E23", "#8FBC8F"];
              const colorIndex = Math.floor((1 - alpha) * (colors.length - 1));
              ctx.fillStyle = colors[colorIndex];

              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
              ctx.fill();

              // Brillo de tentáculo
              ctx.globalAlpha = alpha * 0.4;
              ctx.beginPath();
              ctx.arc(particle.x, particle.y, 6, 0, Math.PI * 2);
              ctx.fill();
            });

            // Base de tentáculos serpenteantes
            ctx.globalAlpha = Math.max(0, 1 - progress);
            ctx.strokeStyle = "#2F4F2F"; // Verde oscuro
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
            ctx.stroke();

            // Centro de impacto
            ctx.globalAlpha = Math.max(0, (1 - progress) * 0.5);
            ctx.fillStyle = "#556B2F"; // Verde oliva
            ctx.beginPath();
            ctx.arc(effect.x, effect.y, effect.radius * 0.6, 0, Math.PI * 2);
            ctx.fill();
          } else if (effect.type === "meteor") {
            // Renderizar estela del meteorito
            effect.trail.forEach((point, index) => {
              const alpha = point.life / 0.5;
              ctx.globalAlpha = alpha;
              const size = 2 + alpha * 3;

              // Colores de fuego para la estela
              const colors = ["#ff0000", "#ff4500", "#ffa500", "#ffff00"];
              const colorIndex = Math.floor((1 - alpha) * (colors.length - 1));
              ctx.fillStyle = colors[colorIndex];

              ctx.beginPath();
              ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
              ctx.fill();
            });

            // Renderizar el meteorito en sí
            if (!effect.impacted) {
              ctx.globalAlpha = 1;

              // Núcleo del meteorito
              ctx.fillStyle = "#ffaa00";
              ctx.beginPath();
              ctx.arc(effect.x, effect.y, 8, 0, Math.PI * 2);
              ctx.fill();

              // Brillo exterior
              ctx.fillStyle = "#ff4500";
              ctx.beginPath();
              ctx.arc(effect.x, effect.y, 12, 0, Math.PI * 2);
              ctx.fill();

              // Resplandor
              ctx.globalAlpha = 0.6;
              ctx.fillStyle = "#ff0000";
              ctx.beginPath();
              ctx.arc(effect.x, effect.y, 16, 0, Math.PI * 2);
              ctx.fill();
            }
          } else if (effect.type === "blood_splat") {
            // Renderizar efecto de blood splat usando el nuevo sprite sheet (10 frames en 2 filas)
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame: 5 frames en primera fila, 5 en segunda
              let sx, sy;
              if (effect.frame < 5) {
                // Primera fila (frames 0-4)
                sx = effect.frame * effect.frameWidth;
                sy = 0;
              } else {
                // Segunda fila (frames 5-9)
                sx = (effect.frame - 5) * effect.frameWidth;
                sy = effect.frameHeight;
              }

              const renderSize = effect.size || 140;
              ctx.drawImage(
                bloodSplatEffectsImg, // Usar el nuevo sprite sheet
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "blood_storm") {
            // Renderizar efecto de blood storm (AoE a todos los aliados)
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame: 5 frames en primera fila, 4 en segunda
              let sx, sy;
              if (effect.frame < 5) {
                // Primera fila (frames 0-4)
                sx = effect.frame * effect.frameWidth;
                sy = 0;
              } else {
                // Segunda fila (frames 5-8)
                sx = (effect.frame - 5) * effect.frameWidth;
                sy = effect.frameHeight;
              }

              const renderSize = effect.size || 150;
              ctx.drawImage(
                bloodStormEffectsImg, // Usar el sprite original para AoE
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "minotaur_smash") {
            // Renderizar efecto de Minotaur Smash
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame en grid 4x2 (4 filas, 2 columnas)
              const col = effect.frame % 2; // Columna (0 o 1)
              const row = Math.floor(effect.frame / 2); // Fila (0-3)
              const sx = col * effect.frameWidth;
              const sy = row * effect.frameHeight;

              const renderSize = effect.size || 160;
              ctx.drawImage(
                minotaurSmashEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "minotaur_life_steal") {
            // Renderizar efecto de Minotaur Life Steal
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;

              // Calcular posición del frame en grid 4x2 (4 filas, 2 columnas)
              const col = effect.frame % 2; // Columna (0 o 1)
              const row = Math.floor(effect.frame / 2); // Fila (0-3)
              const sx = col * effect.frameWidth;
              const sy = row * effect.frameHeight;

              const renderSize = effect.size || 150;
              ctx.drawImage(
                minotaurLifeStealEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "cthulu_main") {
            // Renderizar efecto principal de Cthulhu (Tentacle Strike)
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = effect.frame * effect.frameWidth; // 31 frames en una sola fila
              const sy = 0; // Solo una fila

              const renderSize = effect.size || 120;
              ctx.drawImage(
                cthuluMainEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "poison_main") {
            // Renderizar efecto principal de veneno del Gorgon
            if (effect.frame < effect.totalFrames) {
              ctx.globalAlpha = 1;
              const sx = effect.frame * effect.frameWidth; // 31 frames en una sola fila
              const sy = 0; // Solo una fila

              const renderSize = 96; // Tamaño del efecto (96x96)
              ctx.drawImage(
                cthuluMainEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          } else if (effect.type === "cthulu_special") {
            // Renderizar efecto especial de Cthulhu (Toxic Horror)
            if (effect.frame < effect.frameCount) {
              ctx.globalAlpha = 1;
              const sx = effect.frame * effect.frameWidth; // 40 frames en una sola fila
              const sy = 0; // Solo una fila

              const renderSize = effect.size || 120;
              ctx.drawImage(
                cthuluSpecialEffectsImg,
                sx,
                sy,
                effect.frameWidth,
                effect.frameHeight,
                effect.x - renderSize / 2,
                effect.y - renderSize / 2,
                renderSize,
                renderSize
              );
            }
          }
        });

        ctx.restore();
      }

      function getDistance(a, b) {
        const dx = a.posx - b.posx;
        const dy = a.posy - b.posy;
        return Math.sqrt(dx * dx + dy * dy);
      }

      function getClosestHero(enemy, heroes) {
        const aliveHeroes = heroes.filter((h) => h.hp > 0);
        if (aliveHeroes.length === 0) return null;

        let closest = aliveHeroes[0];
        let minDistance = getDistance(enemy, closest);

        for (let i = 1; i < aliveHeroes.length; i++) {
          const distance = getDistance(enemy, aliveHeroes[i]);
          if (distance < minDistance) {
            minDistance = distance;
            closest = aliveHeroes[i];
          }
        }

        return closest;
      }

      function getRandomHero(heroes) {
        const aliveHeroes = heroes.filter((h) => h.hp > 0);
        if (aliveHeroes.length === 0) return null;

        const randomIndex = Math.floor(Math.random() * aliveHeroes.length);
        return aliveHeroes[randomIndex];
      }

      // Funciones para manejo de debuffs/buffs
      function addDebuff(target, type, stacks = 1) {
        // Buscar si ya existe este debuff
        const existingDebuff = target.debuffs.find((d) => d.type === type);

        if (existingDebuff) {
          // Si ya existe, aumentar stacks (máximo según el tipo)
          switch (type) {
            case "berseker":
              existingDebuff.stacks = Math.min(
                existingDebuff.stacks + stacks,
                10
              ); // Máximo 10 stacks (30%)
              break;
            case "poison":
              existingDebuff.stacks += stacks; // Poison es stackeable sin límite
              break;
            case "shadows":
              existingDebuff.stacks += stacks; // Shadows es stackeable sin límite
              break;
            default:
              existingDebuff.stacks = stacks; // Para otros debuffs, reemplazar stacks
              break;
          }
        } else {
          // Si no existe, crear nuevo debuff
          const debuffData = {
            type: type,
            stacks: stacks,
            icon: getDebuffIcon(type), // Usar icon en lugar de iconInfo
          };
          target.debuffs.push(debuffData);
        }
      }

      function removeDebuff(target, type) {
        target.debuffs = target.debuffs.filter((d) => d.type !== type);
      }

      // Función para limpiar todos los debuffs y buffs cuando un héroe muere
      function clearAllEffectsOnDeath(hero) {
        if (hero.hp <= 0) {
          console.log(`${hero.clazz} died. Clearing all debuffs and buffs.`);

          // Limpiar todos los debuffs
          hero.debuffs = [];

          // Limpiar todos los buffs
          hero.buffs = [];

          console.log(`All effects cleared for ${hero.clazz}.`);
        }
      }

      function getDebuffIcon(type) {
        switch (type) {
          case "healing":
            return healingDebuffImg;
          case "regrowth":
            return healingDebuffImg;
          case "protection":
            return protectionDebuffImg;
          case "combustion":
            return combustionDebuffImg;
          case "berseker":
            return bersekerDebuffImg;
          case "poison":
            return poisonDebuffImg;
          case "shadows":
            return shadowsDebuffImg;
          default:
            return null;
        }
      }

      function renderDebuffs(target, baseX, baseY) {
        if (!target.debuffs || target.debuffs.length === 0) return;

        const iconSize = 17; // Aumentado de 16 a 17px para mejor visibilidad
        const startX = baseX - 40; // Empezar desde la izquierda

        target.debuffs.forEach((debuff, index) => {
          const x = startX + index * (iconSize + 2); // Espaciado de 2px entre iconos
          const y = baseY;

          // Renderizar icono del debuff directamente
          if (debuff.icon) {
            ctx.drawImage(debuff.icon, x, y, iconSize, iconSize);

            // Si tiene stacks > 1, mostrar número pequeño
            if (debuff.stacks > 1) {
              ctx.save();
              ctx.fillStyle = "white";
              ctx.strokeStyle = "black";
              ctx.lineWidth = 1;
              ctx.font = "8px Arial";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";

              const text = debuff.stacks.toString();
              const textX = x + iconSize - 4;
              const textY = y + iconSize - 4;

              ctx.strokeText(text, textX, textY);
              ctx.fillText(text, textX, textY);
              ctx.restore();
            }
          }
        });
      }

      // NOTA: enemyAct() removida - ahora se usa sistema de auto-attack en el loop principal

      let lastTime = 0;
      function loop(time) {
        const delta = (time - lastTime) / 1000;
        lastTime = time;
        currentTime += delta;

        // Actualizar sonidos pendientes
        updatePendingSounds();

        // Solo ejecutar lógica del juego si no estamos en el menú principal o pantallas informativas
        if (
          state !== "main_menu" &&
          state !== "level_info" &&
          state !== "book" &&
          state !== "guide"
        ) {
          // No hay timer automático para el modal - se controla por botón
          // Eliminado bloqueo por modal de fin de nivel (SDK lo maneja)
          // Update hit numbers
          updateHitNumbers(delta);

          // Manejo de transición entre waves
          if (waveTransition.active) {
            waveTransition.timer -= delta;
            // No pausar lógica: sólo un fade muy leve, sin texto, permitiendo que animaciones existentes terminen naturalmente
            const t = Math.max(0, waveTransition.timer / waveTransition.delay); // 1 -> 0
            const alpha = 0.25 * t; // se desvanece rápidamente
            // Dibujar más tarde tras draw() principal (se aplica después de actualizar todo)
          }

          // Update visual effects
          updateVisualEffects(delta);

          // Check wave cleared continuously
          checkWaveCleared();

          // Update buffs
          heroes.forEach((h) => {
            h.buffs = h.buffs.filter((b) => {
              // Buffs de combustión no se eliminan por tiempo, solo por uso
              if (b.type === "combustion") {
                return true; // Mantener hasta que se consuma
              }
              // Tipos convertidos a sistema por turnos (no usar tiempos)
              if (["regrowth", "agony", "poison"].includes(b.type)) return true;

              if (b.endTime && b.endTime <= currentTime) {
                return false;
              }

              if (b.type === "rejuvenation" && b.nextTick <= currentTime) {
                // Verificar si el héroe puede recibir curación
                const hasHealingDebuff =
                  h.debuffs && h.debuffs.some((d) => d.type === "healing");

                if (!hasHealingDebuff && h.hp > 0) {
                  h.hp = Math.min(h.maxhp, h.hp + b.heal);
                  validateHP(h);
                  console.log(
                    "Rejuvenation tick para",
                    h.clazz,
                    "- creando efecto visual de curación"
                  );
                  playHealingAnim(h);
                  showHitNumber(h.posx, h.posy - 20, b.heal, true);
                } else if (hasHealingDebuff) {
                  console.log(
                    `${h.clazz} rejuvenation blocked by healing debuff.`
                  );
                }
                b.nextTick += 1;
              }
              return true;
            });
          });

          // Update animations
          heroes.forEach((h) => {
            if (h.hp <= 0) return;
            const animData = h.animations[h.anim];
            h.animTime += delta;
            const frameDuration = animData.duration / animData.frames;
            if (h.animTime >= frameDuration) {
              h.animTime -= frameDuration;
              h.frame = (h.frame + 1) % animData.frames;
              if (h.frame === 0 && h.anim !== "idle" && h.anim !== "selected") {
                // Aplicar efecto si el héroe tiene una acción pendiente (sin depender del estado global)
                if (h.action && h.targets && h.targets.length > 0) {
                  // Marcar acción activa de héroe para bloquear ataques enemigos hasta que se aplique
                  if (!activeAction) activeAction = h;
                  console.log(
                    "Animation completed! Applying effect for hero:",
                    h.clazz,
                    "action:",
                    h.action,
                    "targets:",
                    h.targets ? h.targets.length : 0,
                    "target types:",
                    h.targets
                      ? h.targets.map((t) => t.clazz || "enemy").join(",")
                      : "none"
                  );

                  // Verificar que tenemos una acción válida antes de aplicar efectos
                  if (h.action && h.targets && h.targets.length > 0) {
                    applyEffect(h, h.action, h.targets);

                    // Limpiar propiedades de acción SOLO para este héroe después de aplicar el efecto
                    console.log(
                      "Limpiando propiedades de acción para",
                      h.clazz
                    );
                    h.targets = [];
                    h.action = null;
                    if (activeAction === h) activeAction = null; // liberar acción activa tras aplicar

                    // NO cambiar estado global, mantener "select_hero" para permitir clicks rápidos
                    state = "select_hero";
                  } else {
                    console.warn(
                      "Hero",
                      h.clazz,
                      "has no valid action or targets to apply. Action:",
                      h.action,
                      "Targets length:",
                      h.targets ? h.targets.length : 0
                    );
                  }
                }
                // Cambiar a idle después de aplicar el efecto (ya no dependemos del estado "animate")
                h.anim = "idle";
              }
            }
          });

          // Marcar visualmente al héroe cuyo turno está activo con la animación 'selected'
          // Actualizar timer de delay para secuenciar acciones
          if (actionDelayTimer > 0) {
            actionDelayTimer -= delta;
            if (actionDelayTimer < 0) actionDelayTimer = 0;
          }
          // Limpiar entidades muertas de la cola y asegurar que siempre haya un vivo al frente o quede vacía.
          // Además, no iniciar nueva acción mientras otra está activa o en delay.
          let safety = 0;
          while (turnQueue.length > 0 && safety < 50) {
            safety++;
            const front = turnQueue[0];
            if (!front || front.hp === undefined || front.hp <= 0) {
              turnQueue.shift();
              lastTurnEntity = null;
              continue;
            }
            // Watchdog: si activeAction quedó colgado sobre una entidad muerta o sin animación, liberarlo
            if (
              activeAction &&
              (activeAction.hp <= 0 ||
                (activeAction.anim !== "attack" &&
                  activeAction.anim !== "cast" &&
                  activeAction.animTime <= 0))
            ) {
              activeAction = null;
            }
            // Esperar a que la acción previa termine antes de procesar nuevo turno
            if (
              activeAction &&
              (actionDelayTimer > 0 ||
                (front !== activeAction && activeAction.animTime > 0))
            ) {
              break; // Hay acción en curso, esperamos
            }
            if (front !== lastTurnEntity) {
              processTurnStart(front);
              if (front.hp <= 0) {
                turnQueue.shift();
                lastTurnEntity = null;
                continue;
              }
              // Si tras processTurnStart el frente es enemigo boss listo pero no disparará (p.ej. ataquesUntilSpecial==null), aseguramos que ataquesUntilSpecial exista
              if (front.type === "boss" && front.attacksUntilSpecial == null) {
                front.attacksUntilSpecial = front.specialAttackCounter || 3;
              }
              lastTurnEntity = front;
            }
            break;
          }
          const activeEntity = turnQueue.length > 0 ? turnQueue[0] : null;
          heroes.forEach((h) => {
            if (h.hp <= 0) return;
            if (activeEntity === h) {
              if (h.anim === "idle" || h.anim === "selected") {
                if (h.anim !== "selected") {
                  h.anim = "selected";
                  h.frame = 0;
                  h.animTime = 0;
                }
              }
            } else {
              // Si estaba en selected pero ya no es su turno y no está ejecutando acción, volver a idle
              if (h.anim === "selected" && !h.action) {
                h.anim = "idle";
                h.frame = 0;
                h.animTime = 0;
              }
            }
          });

          // Process debuffs for enemies (Shadows, etc.)
          enemies.forEach((e) => {
            if (e.hp > 0 && e.debuffs) {
              // La lógica de expiración y ticks se maneja en processTurnStart ahora
            }
          });

          // Update enemy charge and check for automatic attacks
          enemies.forEach((e) => {
            // Actualizar animaciones de muerte independientemente del estado
            if (e.anim === "die") {
              const elapsed = currentTime - e.animStartTime;
              const frameDuration = 0.12; // Duración por frame para muerte (más fluido: 0.15 -> 0.12)
              e.frame = Math.floor(elapsed / frameDuration);
              const deathFrames = e.deathFrames || 6; // Usar frames dinámicos o fallback
              if (e.frame >= deathFrames) {
                e.deathAnimComplete = true;
                e.frame = deathFrames - 1; // Mantener en el último frame
              }
            }

            if (e.hp > 0 && !e.isDying) {
              // Use the new charge speed rating system, fallback to legacy chargeSpeed for compatibility
              const chargeSpeed = e.chargeSpeedRating
                ? getChargeSpeedFromRating(e.chargeSpeedRating)
                : e.chargeSpeed || 20;
              e.charge = Math.min(e.maxcharge, e.charge + delta * chargeSpeed);

              // Cuando se llena la barra, añadir a la cola si no está
              if (e.charge >= 100 && !turnQueue.includes(e)) {
                turnQueue.push(e);
              }

              // Procesar ataque solo si es su turno (al frente de la cola)
              if (
                turnQueue.length > 0 &&
                turnQueue[0] === e &&
                e.charge >= 100 &&
                e.animTime <= 0 &&
                (!activeAction || activeAction === e) &&
                actionDelayTimer === 0 &&
                !heroes.some((h) => h.action) // Esperar resolución de acción de héroe
              ) {
                // Lógica especial para Crab Bomb
                if (e.name === "Crab Bomb") {
                  e.charge = 0; // Reset charge

                  // Incrementar esferas de carga
                  e.sphereCharges = (e.sphereCharges || 0) + 1;
                  console.log(
                    `Crab Bomb sphere charge: ${e.sphereCharges}/${e.maxSphereCharges}`
                  );

                  // Si llegó a 5 esferas, explotar
                  if (e.sphereCharges >= e.maxSphereCharges) {
                    console.log("Crab Bomb explodes!");

                    // Cambiar a animación de explosión
                    e.anim = "explode";
                    e.frame = 0;
                    e.animStartTime = currentTime;

                    // Marcar que debe aplicar daño al final de la animación
                    e.explosionDamagePending = true;

                    // No aplicar daño inmediatamente, se aplicará cuando termine la animación
                  }
                  // Consumió su turno (aunque no haya explotado aún)
                  if (turnQueue[0] === e) turnQueue.shift();
                  return; // Salir de la función para evitar el ataque normal
                }

                // Determinar el nivel actual para decidir el targeting
                const currentLevel = Math.floor(wave / 3) + 1;

                // En Red Dunes (nivel 2) los enemigos atacan a un aliado aleatorio
                // En otros niveles atacan al más cercano
                const target =
                  currentLevel === 2
                    ? getRandomHero(heroes)
                    : getClosestHero(e, heroes);

                if (target) {
                  // RANGOS BASE SEGÚN ESPECIFICACIÓN
                  let damage;
                  if (e.name === "Demon Bat") {
                    damage = 25 + Math.floor(Math.random() * 11); // 25-35
                  } else if (e.name === "Fire Worm") {
                    damage = 30 + Math.floor(Math.random() * 11); // 30-40
                  } else if (e.name === "Mushroom") {
                    damage = 10 + Math.floor(Math.random() * 6); // 10-15
                  } else if (e.name === "Dreadwing") {
                    damage = 20 + Math.floor(Math.random() * 6); // 20-25 por golpe (cada uno)
                  } else if (e.name === "Gorgon") {
                    damage = 20 + Math.floor(Math.random() * 6); // 20-25 (main con poison)
                  } else if (e.name === "Noctebane") {
                    damage = 25 + Math.floor(Math.random() * 11); // 25-35 (main/special se reasigna más abajo)
                  } else if (e.name === "Minotaur") {
                    damage = 45 + Math.floor(Math.random() * 11); // 45-55 base (se ajusta igual en main/special)
                  } else if (e.name === "Crab Bomb") {
                    damage = 0; // explosión aparte
                  } else {
                    damage = 25; // fallback
                  }
                  e.charge = 0; // Reset charge
                  e.animTime = 0.5;
                  e.anim = "attack"; // Activar animación de ataque
                  e.frame = 0; // Reiniciar frame
                  e.animStartTime = currentTime; // Tiempo de inicio de la animación
                  activeAction = e; // Marcar acción activa

                  // Consumir turno inmediatamente (permite que el siguiente en cola avance mientras anima)
                  if (turnQueue[0] === e) turnQueue.shift();
                  actionDelayTimer = 0.4; // delay base tras iniciar animación

                  // Manejo de ataques de Boss (Boss Bat y Minotaur)
                  let isSpecialAttack = false;
                  let isMainAbility = false;
                  if (e.type === "boss" && e.attacksUntilSpecial !== null) {
                    e.attacksUntilSpecial--;
                    if (e.attacksUntilSpecial <= 0) {
                      isSpecialAttack = true;
                      e.isSpecialAttack = true; // Marcar el enemigo para renderizado
                      e.attacksUntilSpecial = e.specialAttackCounter; // Reset counter
                      // ESPECIALES
                      if (e.name === "Noctebane") {
                        damage = 25 + Math.floor(Math.random() * 11); // 25-35 AoE
                      } else if (e.name === "Minotaur") {
                        damage = 45 + Math.floor(Math.random() * 11); // 45-55 AoE Life Steal
                      } else if (e.name === "Gorgon") {
                        damage = 30 + Math.floor(Math.random() * 11); // 30-40 AoE Toxic Horror
                      }
                    } else {
                      // Ataques principales/normales
                      isMainAbility = true;
                      if (e.name === "Noctebane") {
                        damage = 25 + Math.floor(Math.random() * 11); // 25-35 Blood Splat
                      } else if (e.name === "Minotaur") {
                        damage = 45 + Math.floor(Math.random() * 11); // 45-55 Smash
                      } else if (e.name === "Gorgon") {
                        damage = 20 + Math.floor(Math.random() * 6); // 20-25 poison main
                      }
                    }
                  }

                  setTimeout(() => {
                    if (isSpecialAttack) {
                      if (e.name === "Noctebane") {
                        // Ataque especial: Blood Storm (daño AoE a todos los héroes)
                        console.log(
                          "Noctebane uses Blood Storm special attack (AoE)!"
                        );
                        heroes.forEach((hero) => {
                          if (hero.hp > 0) {
                            const currentDef =
                              hero.def +
                              hero.buffs.reduce(
                                (sum, b) =>
                                  b.type === "protection"
                                    ? sum + b.defBonus
                                    : sum,
                                0
                              );

                            const criticalResult = calculateCritical(damage);
                            let finalDamage = criticalResult.damage;
                            if (e.name === "Noctebane") {
                              finalDamage = Math.floor(
                                finalDamage * (e.damageMultiplier || 1)
                              );
                            }
                            let effectiveDamage = Math.max(
                              1,
                              finalDamage - currentDef
                            );
                            if (e.name === "Noctebane") {
                              e.damageMultiplier =
                                (e.damageMultiplier || 1) * 1.05; // +5% tras especial
                            }

                            // Agony turn-based: mitigación ya reflejada en currentDef via defBonus.

                            hero.hp = Math.max(0, hero.hp - effectiveDamage);
                            validateHP(hero);

                            console.log(
                              `${
                                hero.clazz || "Hero"
                              } takes ${effectiveDamage} AoE damage from Blood Storm!`
                            );

                            // Mostrar número de daño para cada héroe afectado
                            showHitNumber(
                              hero.posx,
                              hero.posy - 20,
                              effectiveDamage,
                              false,
                              criticalResult.isCritical
                            );

                            // Agregar efecto visual de Blood Storm para cada héroe
                            addBloodStormEffect(hero.posx, hero.posy);
                          }
                        });
                      } else if (e.name === "Minotaur") {
                        // Ataque especial: Life Steal (AoE que roba vida)
                        console.log("Minotaur uses Life Steal special attack!");
                        let totalDamageDealt = 0;

                        heroes.forEach((hero) => {
                          if (hero.hp > 0) {
                            const currentDef =
                              hero.def +
                              hero.buffs.reduce(
                                (sum, b) =>
                                  b.type === "protection"
                                    ? sum + b.defBonus
                                    : sum,
                                0
                              );

                            const criticalResult = calculateCritical(damage);
                            let finalDamage = criticalResult.damage;
                            let effectiveDamage = Math.max(
                              1,
                              finalDamage - currentDef
                            );

                            // Agony turn-based: mitigación ya reflejada en currentDef via defBonus.

                            hero.hp = Math.max(0, hero.hp - effectiveDamage);
                            validateHP(hero);
                            totalDamageDealt += effectiveDamage;

                            console.log(
                              `${
                                hero.clazz || "Hero"
                              } takes ${effectiveDamage} AoE damage from Life Steal!`
                            );

                            // Mostrar número de daño para cada héroe afectado
                            showHitNumber(
                              hero.posx,
                              hero.posy - 20,
                              effectiveDamage,
                              false,
                              criticalResult.isCritical
                            );

                            // Agregar efecto visual de Life Steal para cada héroe
                            addMinotaurLifeStealEffect(hero.posx, hero.posy);
                          }
                        });

                        // El Minotaur roba 5% del daño total realizado
                        const lifeSteal = Math.floor(totalDamageDealt * 0.05);
                        if (lifeSteal > 0 && !isNaN(lifeSteal)) {
                          // Validar que e.hp y e.maxhp sean números válidos
                          e.hp = isNaN(e.hp) ? e.maxhp : e.hp;
                          e.maxhp = isNaN(e.maxhp) ? 400 : e.maxhp;

                          const newHP = e.hp + lifeSteal;
                          e.hp = Math.min(e.maxhp, isNaN(newHP) ? e.hp : newHP);

                          console.log(
                            `Minotaur steals ${lifeSteal} HP from Life Steal attack!`
                          );

                          // Mostrar número de curación para el Minotaur
                          showHitNumber(
                            e.posx,
                            e.posy - 20,
                            lifeSteal,
                            true,
                            false
                          );
                        }

                        // Minotaur: solo velocidad +5%
                        applyChargeSpeedBonus(e, 1.05);

                        console.log(
                          `Minotaur's charge speed increased to ${getCurrentChargeSpeed(
                            e
                          ).toFixed(2)} (rating: ${
                            e.chargeSpeedRating || "legacy"
                          }) after Life Steal attack!`
                        );
                      } else if (e.name === "Gorgon") {
                        // Ataque especial: Toxic Horror (daño a todos + stack poison)
                        console.log("Gorgon uses Toxic Horror special attack!");
                        const aliveHeroes = heroes.filter((h) => h.hp > 0);

                        // Agregar efecto visual para todos los héroes vivos
                        addToxicHorrorEffect();

                        aliveHeroes.forEach((hero) => {
                          const currentDef =
                            hero.def +
                            hero.buffs.reduce(
                              (sum, b) =>
                                b.type === "protection"
                                  ? sum + b.defBonus
                                  : sum,
                              0
                            );

                          // Toxic Horror ajustado: daño 30-40
                          const toxicDamage =
                            30 + Math.floor(Math.random() * 11);
                          let effectiveDamage = Math.max(
                            1,
                            toxicDamage - currentDef
                          );

                          // Agony ahora solo otorga defBonus (ya incluido en currentDef)

                          hero.hp = Math.max(0, hero.hp - effectiveDamage);
                          validateHP(hero);

                          console.log(
                            `${
                              hero.clazz || "Hero"
                            } takes ${effectiveDamage} damage from Toxic Horror!`
                          );

                          // Mostrar número de daño
                          showHitNumber(
                            hero.posx,
                            hero.posy - 20,
                            effectiveDamage,
                            false,
                            false
                          );

                          // Si el héroe tiene poison, aumentar stacks y reiniciar duración
                          const poisonBuff = hero.buffs.find(
                            (b) => b.type === "poison"
                          );
                          if (poisonBuff) {
                            poisonBuff.stacks += 1;
                            poisonBuff.remainingTurns = 10;
                            // +2 daño base por stack adicional
                            poisonBuff.damagePerTick =
                              (poisonBuff.damagePerTick || 3) + 2;
                            addDebuff(hero, "poison", 1);
                            console.log(
                              `${hero.clazz} poison stack -> ${poisonBuff.stacks} daño: ${poisonBuff.damagePerTick}`
                            );
                          } else {
                            // Si no tenía poison, NO se agrega (según especificaciones)
                            console.log(
                              `${hero.clazz} had no poison, so no stack accumulated`
                            );
                          }
                        });
                      }
                    } else if (isMainAbility) {
                      if (e.name === "Noctebane") {
                        // Habilidad principal: Blood Splat (a un solo aliado aleatorio)
                        console.log(
                          "Noctebane uses Blood Splat main ability (single target)!"
                        );
                        const aliveHeroes = heroes.filter((h) => h.hp > 0);
                        if (aliveHeroes.length > 0) {
                          // Seleccionar héroe aleatorio en lugar del más cercano
                          const randomIndex = Math.floor(
                            Math.random() * aliveHeroes.length
                          );
                          const randomTarget = aliveHeroes[randomIndex];

                          // Validar HP antes del cálculo
                          if (
                            isNaN(randomTarget.hp) ||
                            randomTarget.hp === undefined ||
                            randomTarget.hp === null
                          ) {
                            randomTarget.hp = randomTarget.maxhp || 1;
                          }

                          const currentDef =
                            (randomTarget.def || 0) +
                            (randomTarget.buffs || []).reduce(
                              (sum, b) =>
                                b.type === "protection"
                                  ? sum + (b.defBonus || 0)
                                  : sum,
                              0
                            );

                          const criticalResult = calculateCritical(damage);
                          let finalDamage = criticalResult.damage;
                          finalDamage = Math.floor(
                            finalDamage * (e.damageMultiplier || 1)
                          );
                          let effectiveDamage = Math.max(
                            1,
                            finalDamage - currentDef
                          );
                          e.damageMultiplier = (e.damageMultiplier || 1) * 1.05; // +5% tras main

                          // Agony turn-based: defensa ya sumada via defBonus

                          // Validar que el nuevo HP no sea NaN
                          const newHP = randomTarget.hp - effectiveDamage;
                          randomTarget.hp = Math.max(
                            0,
                            isNaN(newHP) ? 0 : newHP
                          );

                          // Validar HP después del ataque
                          validateHP(randomTarget);

                          console.log(
                            `${
                              randomTarget.clazz || "Hero"
                            } takes ${effectiveDamage} damage from Blood Splat!`
                          );

                          // Mostrar número de daño
                          showHitNumber(
                            randomTarget.posx,
                            randomTarget.posy - 20,
                            effectiveDamage,
                            false,
                            criticalResult.isCritical
                          );

                          // Agregar efecto visual de Blood Splat
                          addBloodSplatEffect(
                            randomTarget.posx,
                            randomTarget.posy
                          );
                        }
                      } else if (e.name === "Minotaur") {
                        // Habilidad principal: Smash (ataque devastador a un solo héroe)
                        console.log(
                          "Minotaur uses Smash main ability (single target)!"
                        );
                        const aliveHeroes = heroes.filter((h) => h.hp > 0);
                        if (aliveHeroes.length > 0) {
                          // Seleccionar héroe aleatorio
                          const randomIndex = Math.floor(
                            Math.random() * aliveHeroes.length
                          );
                          const randomTarget = aliveHeroes[randomIndex];

                          // Validar HP antes del cálculo
                          if (
                            isNaN(randomTarget.hp) ||
                            randomTarget.hp === undefined ||
                            randomTarget.hp === null
                          ) {
                            randomTarget.hp = randomTarget.maxhp || 1;
                          }

                          const currentDef =
                            (randomTarget.def || 0) +
                            (randomTarget.buffs || []).reduce(
                              (sum, b) =>
                                b.type === "protection"
                                  ? sum + (b.defBonus || 0)
                                  : sum,
                              0
                            );

                          const criticalResult = calculateCritical(damage);
                          let finalDamage = criticalResult.damage;
                          let effectiveDamage = Math.max(
                            1,
                            finalDamage - currentDef
                          );

                          // Agony turn-based: mitigación ya incorporada en currentDef.

                          // Validar que el nuevo HP no sea NaN
                          const newHP = randomTarget.hp - effectiveDamage;
                          randomTarget.hp = Math.max(
                            0,
                            isNaN(newHP) ? 0 : newHP
                          );

                          // Validar HP después del ataque
                          validateHP(randomTarget);

                          console.log(
                            `${
                              randomTarget.clazz || "Hero"
                            } takes ${effectiveDamage} massive damage from Smash!`
                          );

                          // Mostrar número de daño
                          showHitNumber(
                            randomTarget.posx,
                            randomTarget.posy - 20,
                            effectiveDamage,
                            false,
                            criticalResult.isCritical
                          );

                          // Agregar efecto visual de Smash
                          addMinotaurSmashEffect(
                            randomTarget.posx,
                            randomTarget.posy
                          );

                          // Minotaur: solo velocidad +5%
                          applyChargeSpeedBonus(e, 1.05);

                          console.log(
                            `Minotaur's charge speed increased to ${getCurrentChargeSpeed(
                              e
                            ).toFixed(2)} (rating: ${
                              e.chargeSpeedRating || "legacy"
                            }) after Smash attack!`
                          );
                        }
                      } else if (e.name === "Gorgon") {
                        // Gorgon: Ataque principal (más daño + veneno a héroe aleatorio)
                        console.log("Gorgon uses poison attack!");

                        const aliveHeroes = heroes.filter((h) => h.hp > 0);
                        if (aliveHeroes.length > 0) {
                          // Seleccionar héroe aleatorio
                          const randomIndex = Math.floor(
                            Math.random() * aliveHeroes.length
                          );
                          const randomTarget = aliveHeroes[randomIndex];

                          // Agregar efecto visual del ataque principal del Gorgon
                          addPoisonMainEffect(
                            randomTarget.posx,
                            randomTarget.posy
                          );

                          // Calcular defensa del objetivo
                          const currentDef =
                            (randomTarget.def || 0) +
                            (randomTarget.buffs || []).reduce(
                              (sum, b) =>
                                b.type === "protection" || b.type === "agony"
                                  ? sum + (b.defBonus || 0)
                                  : sum,
                              0
                            );

                          // Ataque principal ajustado: daño 20-30
                          const poisonAttackDamage =
                            20 + Math.floor(Math.random() * 6); // 20-25
                          const criticalResult =
                            calculateCritical(poisonAttackDamage);
                          const finalDamage = criticalResult.damage;
                          let effectiveDamage = Math.max(
                            1,
                            finalDamage - currentDef
                          );

                          // Agony turn-based: mitigación ya incorporada en currentDef.

                          // Aplicar daño
                          randomTarget.hp = Math.max(
                            0,
                            randomTarget.hp - effectiveDamage
                          );
                          validateHP(randomTarget);

                          console.log(
                            `${
                              randomTarget.clazz || "Hero"
                            } takes ${effectiveDamage} damage from Gorgon's poison attack!`
                          );

                          // Mostrar número de daño
                          showHitNumber(
                            randomTarget.posx,
                            randomTarget.posy - 20,
                            effectiveDamage,
                            false,
                            criticalResult.isCritical
                          );

                          // Aplicar veneno al objetivo atacado
                          const existingPoison = randomTarget.buffs.find(
                            (b) => b.type === "poison"
                          );
                          if (!existingPoison) {
                            randomTarget.buffs.push({
                              type: "poison",
                              remainingTurns: 10,
                              stacks: 1,
                            });
                            addDebuff(randomTarget, "poison", 1);
                            console.log(
                              `Gorgon aplica poison a ${randomTarget.clazz}`
                            );
                          } else {
                            existingPoison.stacks += 1;
                            existingPoison.remainingTurns = 10; // Reinicia duración
                            addDebuff(randomTarget, "poison", 1); // Actualiza icono (stacks)
                            console.log(
                              `Poison stack (${existingPoison.stacks}) en ${randomTarget.clazz}`
                            );
                          }
                        }
                      }
                    } else {
                      // Ataque normal a un solo objetivo

                      // Determinar el objetivo: aleatorio para demonios del nivel 1, más cercano para otros
                      let attackTarget;
                      if (e.name === "Demon Bat" || e.name === "Fire Worm") {
                        // Demonios del nivel 1 atacan a héroe aleatorio
                        const aliveHeroes = heroes.filter((h) => h.hp > 0);
                        if (aliveHeroes.length > 0) {
                          const randomIndex = Math.floor(
                            Math.random() * aliveHeroes.length
                          );
                          attackTarget = aliveHeroes[randomIndex];
                          console.log(
                            `${e.name} targets random hero: ${attackTarget.clazz}`
                          );
                        } else {
                          attackTarget = null;
                        }
                      } else {
                        // Otros enemigos atacan al más cercano
                        attackTarget = target;
                      }

                      if (attackTarget && attackTarget.hp > 0) {
                        // Validar propiedades del target antes del cálculo
                        if (
                          isNaN(attackTarget.def) ||
                          attackTarget.def === undefined ||
                          attackTarget.def === null
                        ) {
                          console.error(
                            "Target defense is NaN or invalid, setting to 3"
                          );
                          attackTarget.def = 3; // Valor por defecto
                        }
                        if (
                          isNaN(attackTarget.hp) ||
                          attackTarget.hp === undefined ||
                          attackTarget.hp === null
                        ) {
                          console.error(
                            "Target HP is NaN or invalid, setting to 100"
                          );
                          attackTarget.hp = 100; // Valor por defecto
                        }

                        let currentDef =
                          attackTarget.def +
                          attackTarget.buffs.reduce(
                            (sum, b) =>
                              b.type === "protection" ? sum + b.defBonus : sum,
                            0
                          );

                        // Validar que currentDef sea un número válido
                        if (
                          isNaN(currentDef) ||
                          currentDef === undefined ||
                          currentDef === null
                        ) {
                          console.error(
                            "Current defense is NaN or invalid, setting to 0"
                          );
                          currentDef = 0;
                        }

                        // Validar que damage sea un número válido antes del cálculo crítico
                        if (
                          isNaN(damage) ||
                          damage === undefined ||
                          damage === null
                        ) {
                          console.error(
                            "Damage is NaN or invalid, resetting to default"
                          );
                          damage = e.type === "boss" ? 45 : 25; // Valor por defecto
                        }

                        // Calcular crítico para auto-ataque de enemigo
                        const criticalResult = calculateCritical(damage);
                        let finalDamage = criticalResult.damage;
                        const isCritical = criticalResult.isCritical;

                        // Validar que finalDamage sea un número válido
                        if (
                          isNaN(finalDamage) ||
                          finalDamage === undefined ||
                          finalDamage === null
                        ) {
                          console.error(
                            "Final damage is NaN or invalid, using base damage"
                          );
                          finalDamage = damage;
                        }

                        let effectiveDamage = Math.max(
                          1,
                          finalDamage - currentDef
                        );

                        // Validar que effectiveDamage sea un número válido
                        if (
                          isNaN(effectiveDamage) ||
                          effectiveDamage === undefined ||
                          effectiveDamage === null
                        ) {
                          console.error(
                            "Effective damage is NaN or invalid, setting to 1"
                          );
                          effectiveDamage = 1;
                        }

                        // Agony turn-based: mitigación ya incorporada en currentDef.

                        attackTarget.hp = Math.max(
                          0,
                          attackTarget.hp - effectiveDamage
                        );

                        // Feedback háptico cuando un héroe recibe daño
                        triggerHapticFeedback();

                        // Validar que el HP del héroe no sea NaN después del cálculo
                        validateHP(attackTarget);

                        // Validar que el HP no sea NaN después del cálculo
                        if (isNaN(attackTarget.hp)) {
                          console.error("Hero HP became NaN, resetting to 0");
                          attackTarget.hp = 0;
                        }

                        // Mostrar número de daño del enemigo auto-attack con crítico
                        showHitNumber(
                          attackTarget.posx,
                          attackTarget.posy - 20,
                          effectiveDamage,
                          false,
                          isCritical
                        );

                        // Implementar habilidades específicas de enemigos del Dark Swamp
                        if (e.name === "Mushroom") {
                          // Mushroom: Ataque básico + aplicar Poison
                          console.log("Mushroom uses poison attack!");

                          // Aplicar veneno al objetivo atacado
                          const existingPoison = attackTarget.buffs.find(
                            (b) => b.type === "poison"
                          );
                          if (!existingPoison) {
                            attackTarget.buffs.push({
                              type: "poison",
                              remainingTurns: 10,
                              stacks: 1,
                            });
                            addDebuff(attackTarget, "poison", 1);
                            console.log(
                              `Mushroom applies poison to ${attackTarget.clazz}!`
                            );
                          } else {
                            existingPoison.stacks += 1;
                            existingPoison.remainingTurns = 10;
                            addDebuff(attackTarget, "poison", 1);
                            console.log(
                              `Mushroom poison stack -> ${existingPoison.stacks}`
                            );
                          }
                        } else if (e.name === "Dreadwing") {
                          // Dreadwing: Ataque doble a dos héroes aleatorios (puede repetir)
                          console.log("Dreadwing uses double strike!");

                          const aliveHeroes = heroes.filter((h) => h.hp > 0);
                          if (aliveHeroes.length > 0) {
                            // Segundo ataque a héroe aleatorio
                            const secondTarget =
                              aliveHeroes[
                                Math.floor(Math.random() * aliveHeroes.length)
                              ];

                            const secondTargetDef =
                              secondTarget.def +
                              secondTarget.buffs.reduce(
                                (sum, b) =>
                                  b.type === "protection"
                                    ? sum + b.defBonus
                                    : sum,
                                0
                              );

                            const secondCriticalResult =
                              calculateCritical(damage);
                            // Reducir daño del segundo golpe igual que el primero (ya que damage ajustado se basó en el primero)
                            let secondBase = 20 + Math.floor(Math.random() * 6); // 20-25 segundo golpe (sin cambios)
                            const secondCriticalResult2 =
                              calculateCritical(secondBase);
                            let secondEffectiveDamage = Math.max(
                              1,
                              secondCriticalResult2.damage - secondTargetDef
                            );

                            // Agony turn-based: mitigación ya incorporada en DEF.

                            secondTarget.hp = Math.max(
                              0,
                              secondTarget.hp - secondEffectiveDamage
                            );

                            showHitNumber(
                              secondTarget.posx,
                              secondTarget.posy - 20,
                              secondEffectiveDamage,
                              false,
                              secondCriticalResult2.isCritical
                            );

                            console.log(
                              `Dreadwing's second strike hits ${secondTarget.clazz} for ${secondEffectiveDamage} damage!`
                            );

                            checkGameOver();
                          }
                        } else if (e.name === "Fire Worm") {
                          // Fire Worm: Ataque intermedio básico (ya aplicado en damage base)
                          console.log(
                            "Fire Worm uses basic intermediate attack!"
                          );
                          // No hay lógica adicional, solo el ataque básico intermedio
                        } else if (e.name === "Minotaur") {
                          applyChargeSpeedBonus(e, 1.05); // solo velocidad
                          console.log(`Minotaur charge speed buff (basic).`);
                        }

                        // Lógica de veneno para enemigos del Dark Swamp (Mushroom y Gorgon)
                        if (e.name === "Gorgon") {
                          const aliveHeroes = heroes.filter((h) => h.hp > 0);
                          if (aliveHeroes.length > 0) {
                            const randomIndex = Math.floor(
                              Math.random() * aliveHeroes.length
                            );
                            const poisonTarget = aliveHeroes[randomIndex];
                            const existingPoison = poisonTarget.buffs.find(
                              (b) => b.type === "poison"
                            );
                            if (!existingPoison) {
                              poisonTarget.buffs.push({
                                type: "poison",
                                remainingTurns: 10,
                                stacks: 1,
                              });
                              addDebuff(poisonTarget, "poison", 1);
                              console.log(
                                `${e.name} applies poison to ${poisonTarget.clazz}!`
                              );
                            } else {
                              existingPoison.stacks += 1;
                              existingPoison.remainingTurns = 10;
                              addDebuff(poisonTarget, "poison", 1);
                              console.log(
                                `${e.name} poison stack -> ${existingPoison.stacks} on ${poisonTarget.clazz}`
                              );
                            }
                          }
                        }

                        checkGameOver();
                      }
                    }
                  }, 100);
                }
              }
            }

            // Actualizar animaciones de enemigos - usando sprites dinámicos del nivel
            if (e.anim === "hurt") {
              const elapsed = currentTime - e.animStartTime;
              if (elapsed >= 0.3) {
                // Duración del efecto de daño
                e.anim = "idle";
                e.frame = 0; // Reiniciar frame
                e.animStartTime = currentTime;
              }
            } else if (e.anim === "attack") {
              const elapsed = currentTime - e.animStartTime;
              const frameDuration = 0.08; // Duración por frame para ataque (más fluido: 0.1 -> 0.08)
              e.frame = Math.floor(elapsed / frameDuration);

              // Determinar frames de ataque según el tipo
              let attackFrames = e.attackFrames || 4;
              if (e.name === "Gorgon" && e.isSpecialAttack) {
                attackFrames = e.specialAttackFrames || 16; // Usar frames de ataque especial
              }

              if (e.frame >= attackFrames) {
                e.anim = "idle"; // Volver a idle después del ataque
                e.frame = 0;
                e.animStartTime = currentTime;
                e.isSpecialAttack = false; // Limpiar flag de ataque especial
              }
            } else if (e.anim === "explode") {
              // Animación especial de explosión para Crab Bomb
              const elapsed = currentTime - e.animStartTime;
              const frameDuration = 0.08; // Duración por frame para explosión (más lenta para ser visible)
              e.frame = Math.floor(elapsed / frameDuration);

              const explodeFrames = e.explodeFrames || 23; // 23 frames de explosión
              if (e.frame >= explodeFrames) {
                // La animación de explosión ha terminado, aplicar daño ahora
                if (e.explosionDamagePending) {
                  const explosionDamage = 65 + Math.floor(Math.random() * 11); // 65-75 daño

                  console.log(
                    "Applying explosion damage as animation completes"
                  );

                  heroes.forEach((hero) => {
                    if (hero.hp > 0) {
                      const currentDef =
                        hero.def +
                        hero.buffs.reduce(
                          (sum, b) =>
                            b.type === "protection" ? sum + b.defBonus : sum,
                          0
                        );

                      let effectiveDamage = Math.max(
                        1,
                        explosionDamage - currentDef
                      );

                      // Agony turn-based: mitigación ya incorporada en DEF.

                      hero.hp = Math.max(0, hero.hp - effectiveDamage);
                      validateHP(hero);

                      showHitNumber(
                        hero.posx,
                        hero.posy - 20,
                        effectiveDamage,
                        false,
                        false
                      );
                      console.log(
                        `${hero.clazz} takes ${effectiveDamage} explosion damage!`
                      );
                    }
                  });

                  // Marcar que el daño ya se aplicó
                  e.explosionDamagePending = false;

                  checkGameOver();
                }

                // Terminar explosión y cambiar a muerte
                e.anim = "die";
                e.frame = 0;
                e.animStartTime = currentTime;
                e.hp = 0;
                e.isDying = true;
                console.log(
                  "Explosion animation completed, switching to death"
                );
              }
            } else if (e.anim === "idle" && e.hp > 0) {
              const elapsed = currentTime - e.animStartTime;
              const frameDuration = 0.18; // Duración por frame para idle (más fluido: 0.25 -> 0.18)
              const idleFrames = e.idleFrames || 4; // Usar frames dinámicos o fallback
              e.frame = Math.floor(elapsed / frameDuration) % idleFrames;
            }

            if (e.animTime > 0) e.animTime -= delta;
          });

          // Update hero charge over time
          heroes.forEach((h) => {
            if (h.hp > 0) {
              // Use the new charge speed rating system
              const chargeSpeed = getChargeSpeedFromRating(
                h.chargeSpeedRating || 5
              );
              h.charge = Math.min(h.maxcharge, h.charge + delta * chargeSpeed);
              if (h.charge >= 100 && !turnQueue.includes(h)) {
                turnQueue.push(h);
              }
            }
          });

          // Verificar si el héroe seleccionado ha muerto durante la selección de objetivo
          checkAndCancelDeadHeroAction();

          // Progresar aparición suave de nuevos enemigos
          enemies.forEach((e) => {
            if (e.spawnFadeProgress !== undefined && e.spawnFadeProgress < 1) {
              e.spawnFadeProgress = Math.min(
                1,
                e.spawnFadeProgress + delta * 2
              ); // 0.5s aprox
            }
          });
          // Liberar acción activa cuando termina animación y no hay delay
          if (
            activeAction &&
            activeAction.anim !== "attack" &&
            actionDelayTimer === 0
          ) {
            activeAction = null;
          }
        } // Fin del bloque condicional del juego

        draw();
        requestAnimationFrame(loop);
      }

      function draw() {
        ctx.clearRect(0, 0, designWidth, designHeight);

        // Configurar interpolación de alta calidad para todos los sprites
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";

        // Si estamos en el menú principal, renderizar la pantalla de inicio
        if (state === "main_menu") {
          drawMainMenu();
          return;
        }

        // Si estamos en la pantalla de información de nivel
        if (state === "level_info") {
          drawLevelInfo();
          return;
        }

        // Si estamos en la pantalla del libro de monstruos
        if (state === "book") {
          drawMonsterBook();
          return;
        }

        // Si estamos en la pantalla de guía
        if (state === "guide") {
          drawGuide();
          return;
        }

        // Eliminado: pantalla de finalización gestionada externamente (SDK)
        if (state === "level_completion") {
          // Dibujar modal de fin de nivel
          const modalW = 300;
          const modalH = 200;
          const modalX = (designWidth - modalW) / 2;
          const modalY = (designHeight - modalH) / 2 - 40;
          ctx.fillStyle = "rgba(0,0,0,0.75)"; // Fondo más oscuro detrás del modal
          ctx.fillRect(0, 0, designWidth, designHeight);
          ctx.fillStyle = "#1C140A"; // Panel más oscuro
          ctx.strokeStyle = "#D3BF8F";
          ctx.lineWidth = 3;
          ctx.fillRect(modalX, modalY, modalW, modalH);
          ctx.strokeRect(modalX, modalY, modalW, modalH);

          ctx.fillStyle = "#D3BF8F";
          ctx.font = "bold 26px 'Jersey 10'";
          const title = `Level ${levelCompletionModal.level} Cleared!`;
          ctx.textAlign = "center";
          ctx.fillText(title, designWidth / 2, modalY + 48);
          ctx.font = "16px 'Jacquard 24'";
          ctx.fillStyle = "#FFFFFF";
          const bossLine = levelCompletionModal.boss
            ? `Boss: ${levelCompletionModal.boss}`
            : "";
          ctx.fillText(bossLine, designWidth / 2, modalY + 80);

          // Botones
          const btnW = 120;
          const btnH = 36;
          const btnY = modalY + modalH - 70;
          const continueX = designWidth / 2 - btnW - 10;
          const surrenderX = designWidth / 2 + 10;

          // Continuar
          ctx.drawImage(buttonLongBeigeImg, continueX, btnY, btnW, btnH);
          ctx.fillStyle = "#3D2914";
          ctx.font = "bold 18px 'Jersey 10'";
          ctx.fillText("Continue", continueX + btnW / 2, btnY + 24);
          // Surrender
          ctx.drawImage(buttonLongBrownImg, surrenderX, btnY, btnW, btnH);
          ctx.fillStyle = "#3D2914"; // Mismo color que Continue
          ctx.fillText("Surrender", surrenderX + btnW / 2, btnY + 24);
          return;
        }

        // Draw background
        ctx.drawImage(currentBackgroundImg, 0, 0, designWidth, designHeight);

        // IMPORTANTE: Limitar el área de renderizado del juego para que no interfiera con header/footer
        ctx.save();
        ctx.beginPath();
        ctx.rect(0, GAME_AREA_Y, designWidth, GAME_AREA_HEIGHT);
        ctx.clip();

        heroes.forEach((h) => {
          const animData = h.animations[h.anim];
          // El frameOffset ya no es necesario para conflagration ya que usa su propia fila
          let frameOffset = 0;
          const sx = (h.frame + frameOffset) * h.frameW;
          const sy = animData.row * h.frameH;
          const size = h.size || 80;

          // Aplicar efecto de sombra/transparencia si está muerto
          if (h.hp <= 0) {
            ctx.save();
            ctx.globalAlpha = 0.6; // Menos transparente (era 0.4)
            ctx.filter = "brightness(0.3) contrast(0.8)"; // Más oscuro
          }

          ctx.drawImage(
            h.img,
            sx,
            sy,
            h.frameW,
            h.frameH,
            h.posx - size / 2,
            h.posy - size / 2,
            size,
            size
          );

          if (h.hp <= 0) {
            ctx.restore(); // Restaurar efectos
          }

          // HP bar background
          ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
          ctx.fillRect(h.posx - 40, h.posy + 55, 80, 12);

          // HP bar red
          ctx.fillStyle = "red";
          const hpWidth = 80 * (h.hp / h.maxhp);
          ctx.fillRect(h.posx - 40, h.posy + 55, hpWidth, 12); // HP bar

          // Texto de HP centrado perfectamente en la barra
          ctx.fillStyle = "white";
          ctx.font = "8px 'Press Start 2P'";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          if (h.hp <= 0) {
            ctx.fillText("DEAD", h.posx, h.posy + 55 + 6); // Centrado en Y
          } else {
            ctx.fillText(`${h.hp}`, h.posx, h.posy + 55 + 6); // Centrado en Y
          }
          ctx.textAlign = "left"; // Resetear alineación
          ctx.textBaseline = "alphabetic"; // Resetear baseline

          // Charge bar background - una sola barra continua (solo si está vivo)
          if (h.hp > 0) {
            // Pegar barra de energía justo debajo de HP (sin espacio)
            ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
            ctx.fillRect(h.posx - 40, h.posy + 67, 80, 8);

            // Charge bar yellow - barra continua hasta el 100%
            ctx.fillStyle = "#FFD700";
            const chargeWidth = 80 * (h.charge / 100);
            if (h.charge > 0) {
              ctx.fillRect(h.posx - 40, h.posy + 67, chargeWidth, 8);
            }

            // Borde de la barra de carga
            ctx.strokeStyle = "black";
            ctx.lineWidth = 1;
            ctx.strokeRect(h.posx - 40, h.posy + 67, 80, 8);

            // Número de orden de turno (solo si está en la cola)
            const heroOrderIndex = turnQueue.indexOf(h);
            if (heroOrderIndex !== -1) {
              ctx.save();
              const orderText = (heroOrderIndex + 1).toString();
              ctx.font = "bold 8px 'Press Start 2P'";
              ctx.textAlign = "right";
              ctx.textBaseline = "middle";
              ctx.strokeStyle = "#000";
              ctx.lineWidth = 3;
              ctx.fillStyle = heroOrderIndex === 0 ? "#FFD700" : "#FFFFFF";
              const tx = h.posx - 46; // ligera separación extra
              const ty = h.posy + 71; // centrado vertical nueva barra (67 + 4)
              ctx.strokeText(orderText, tx, ty);
              ctx.fillText(orderText, tx, ty);
              ctx.restore();
            }
          }

          // Borde de la barra de HP
          ctx.strokeStyle = "black";
          ctx.lineWidth = 1;
          ctx.strokeRect(h.posx - 40, h.posy + 55, 80, 12);

          // Renderizar debuffs debajo de la barra de energía
          if (h.hp > 0) {
            // Solo si está vivo
            renderDebuffs(h, h.posx, h.posy + 77);
          }
        });

        enemies.forEach((e) => {
          if (e.hp <= 0 && e.deathAnimComplete) return; // No dibujar si completó animación de muerte

          const size = e.size || 80;

          // Usar los sprites específicos del enemigo según el nivel
          ctx.save();

          // Activar interpolación suave para mejor calidad
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = "high";

          // Seleccionar sprite y calcular posición según animación
          if (e.spawnFadeProgress !== undefined && e.spawnFadeProgress < 1) {
            ctx.globalAlpha *= Math.max(0.05, e.spawnFadeProgress); // proteger de alpha 0 absoluto
          }
          let spriteImg, sx, sy;

          // Verificar si es Minotaur (usa sprite sheet completo)
          if (e.name === "Minotaur") {
            spriteImg = minotaurAllStatesImg;

            if (e.anim === "die") {
              // Fila 1 (attack) como "death" visual: 16 frames
              sx = e.frame * e.frameWidth;
              sy = 1 * e.frameHeight;
              // Efecto de desvanecimiento gradual al morir
              const deathProgress = e.frame / ((e.deathFrames || 16) - 1);
              ctx.globalAlpha = 1 - deathProgress * 0.7;
              ctx.filter = "grayscale(50%) brightness(0.5)";
            } else if (e.anim === "hurt") {
              // Para hurt, usar idle (fila 0) pero con efectos visuales
              sx = e.frame * e.frameWidth;
              sy = 0 * e.frameHeight;
              ctx.filter = "hue-rotate(0deg) contrast(1.5) brightness(1.2)";
              ctx.globalAlpha = 0.8 + 0.2 * Math.sin(currentTime * 20);
            } else if (e.anim === "attack") {
              // Fila 1 (attack): 16 frames
              sx = e.frame * e.frameWidth;
              sy = 1 * e.frameHeight;
            } else {
              // Fila 0 (idle): 16 frames
              sx = e.frame * e.frameWidth;
              sy = 0 * e.frameHeight;
            }
          } else if (e.name === "Gorgon") {
            // Usar diferentes sprites según la animación
            if (e.anim === "die") {
              spriteImg = swampGorgonDeathImg;
              sx = e.frame * e.frameWidth;
              sy = 0; // Solo una fila en el sprite de muerte
              // Efecto de desvanecimiento gradual al morir
              const deathProgress = e.frame / ((e.deathFrames || 3) - 1);
              ctx.globalAlpha = 1 - deathProgress * 0.7;
              ctx.filter = "grayscale(50%) brightness(0.5)";
            } else if (e.anim === "hurt") {
              spriteImg = swampGorgonIdleImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
              ctx.filter = "hue-rotate(0deg) contrast(1.5) brightness(1.2)";
              ctx.globalAlpha = 0.8 + 0.2 * Math.sin(currentTime * 20);
            } else if (e.anim === "attack") {
              // Verificar si es ataque especial
              if (e.isSpecialAttack) {
                spriteImg = swampGorgonSpecialAttackImg;
              } else {
                spriteImg = swampGorgonAttackImg;
              }
              sx = e.frame * e.frameWidth;
              sy = 0; // Solo una fila en cada sprite de ataque
            } else {
              // Idle animation
              spriteImg = swampGorgonIdleImg;
              sx = e.frame * e.frameWidth;
              sy = 0; // Solo una fila en el sprite idle
            }

            // Mejorar calidad de renderizado para Gorgon
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = "high";
          } else if (e.name === "Crab Bomb") {
            // Usar diferentes sprites según la animación para Crab Bomb
            if (e.anim === "die") {
              spriteImg = crabBombDeathImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
              // Efecto de desvanecimiento gradual al morir
              const deathProgress = e.frame / ((e.deathFrames || 6) - 1);
              ctx.globalAlpha = 1 - deathProgress * 0.7;
              ctx.filter = "grayscale(50%) brightness(0.5)";
            } else if (e.anim === "explode") {
              spriteImg = crabBombExplodeImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
              // Efecto muy brillante y llamativo para la explosión
              ctx.filter = "brightness(1.8) contrast(1.5) saturate(1.3)";
              ctx.globalAlpha = 1.0; // Asegurar que sea completamente visible

              // Agregar un resplandor adicional
              ctx.shadowColor = "orange";
              ctx.shadowBlur = 15;
              ctx.shadowOffsetX = 0;
              ctx.shadowOffsetY = 0;
            } else if (e.anim === "hurt") {
              spriteImg = crabBombIdleImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
              ctx.filter = "hue-rotate(0deg) contrast(1.5) brightness(1.2)";
              ctx.globalAlpha = 0.8 + 0.2 * Math.sin(currentTime * 20);
            } else {
              // idle
              spriteImg = crabBombIdleImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
            }
          } else {
            // Lógica original para otros enemigos (Demon Bat, Worm)
            if (e.anim === "die") {
              spriteImg = e.sprites ? e.sprites.death : goblinDieImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
              // Efecto de desvanecimiento gradual al morir
              const deathProgress = e.frame / ((e.deathFrames || 6) - 1);
              ctx.globalAlpha = 1 - deathProgress * 0.7;
              ctx.filter = "grayscale(50%) brightness(0.5)";
            } else if (e.anim === "hurt") {
              // Para hurt, usar idle pero con efectos visuales
              spriteImg = e.sprites ? e.sprites.idle : goblinIdleImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
              // Efecto de flash rojo cuando recibe daño
              ctx.filter = "hue-rotate(0deg) contrast(1.5) brightness(1.2)";
              ctx.globalAlpha = 0.8 + 0.2 * Math.sin(currentTime * 20); // Parpadeo
            } else if (e.anim === "attack") {
              // Animación de ataque
              spriteImg = e.sprites ? e.sprites.attack : goblinIdleImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
            } else {
              // idle
              spriteImg = e.sprites ? e.sprites.idle : goblinIdleImg;
              sx = e.frame * e.frameWidth;
              sy = 0;
            }
          }

          // Dibujar el sprite del enemigo
          // Para Demon Slime, mantener las proporciones originales del sprite
          let drawWidth = size;
          let drawHeight = size;

          if (e.name === "Minotaur") {
            // Mantener proporciones originales del sprite (288x160)
            const aspectRatio = e.frameWidth / e.frameHeight; // 288/160 = 1.8
            drawWidth = size;
            drawHeight = size / aspectRatio; // Ajustar altura para mantener proporción
          } else if (e.name === "Gorgon") {
            // Mantener proporciones originales del sprite (128x128)
            const aspectRatio = e.frameWidth / e.frameHeight; // 128/128 = 1.0
            drawWidth = size;
            drawHeight = size / aspectRatio; // Ajustar altura para mantener proporción (es cuadrado)
          }

          ctx.drawImage(
            spriteImg,
            sx,
            sy,
            e.frameWidth,
            e.frameHeight,
            e.posx - drawWidth / 2,
            e.posy - drawHeight / 2,
            drawWidth,
            drawHeight
          );

          // Reset de efectos visuales para no afectar otros elementos
          ctx.filter = "none";
          ctx.shadowColor = "transparent";
          ctx.shadowBlur = 0;
          ctx.globalAlpha = 1.0;

          ctx.restore();

          // Solo mostrar HUD si no está muerto o aún no completó la animación
          if (e.hp > 0 || !e.deathAnimComplete) {
            // Calcular offset vertical para la barra de HP según el tipo de enemigo
            let hpBarOffset = size / 2 + 25;
            if (e.name === "Minotaur") {
              // Usar la altura real del sprite renderizado
              const aspectRatio = e.frameWidth / e.frameHeight;
              const actualHeight = size / aspectRatio;
              hpBarOffset = actualHeight / 2 + 25;
            } else if (e.name === "Gorgon") {
              // Para Gorgon, reducir distancia del HUD
              hpBarOffset = size / 2 + 15; // Reducido de +25 a +15 para estar más cerca
            }

            // Título del enemigo - encima de la barra de HP, pegado a la izquierda
            ctx.fillStyle = "#FFFFFF"; // Blanco
            ctx.strokeStyle = "#2A1F0F"; // Borde marrón oscuro
            ctx.lineWidth = 2;
            ctx.font = "bold 9px 'Press Start 2P'"; // Aumentado de 7px a 9px
            ctx.textAlign = "left";
            ctx.textBaseline = "alphabetic";

            const titleX = e.posx - 40; // Pegado a la izquierda del HUD
            const titleY = e.posy - hpBarOffset - 8; // Encima de la barra de HP

            // Dibujar borde del título
            ctx.strokeText(e.name, titleX, titleY);
            // Dibujar texto del título
            ctx.fillText(e.name, titleX, titleY);

            // Restaurar alpha previo al HUD (el HUD debe ser siempre 100% visible)
            if (e.spawnFadeProgress !== undefined && e.spawnFadeProgress < 1) {
              ctx.globalAlpha = 1;
            }

            // HP bar background - ahora encima del enemigo
            ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
            ctx.fillRect(e.posx - 40, e.posy - hpBarOffset, 80, 12);

            // HP bar red
            ctx.fillStyle = "red";
            // Validar que e.hp y e.maxhp sean números válidos para evitar NaN
            const validHP = isNaN(e.hp) ? 0 : e.hp;
            const validMaxHP = isNaN(e.maxhp) ? 1 : e.maxhp;
            const hpWidth = 80 * (validHP / validMaxHP);
            ctx.fillRect(e.posx - 40, e.posy - hpBarOffset, hpWidth, 12);

            // Texto de HP centrado perfectamente en la barra
            ctx.fillStyle = "white";
            ctx.font = "8px 'Press Start 2P'";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            // Mostrar HP válido, si es NaN mostrar 0
            ctx.fillText(
              `${isNaN(e.hp) ? 0 : Math.floor(e.hp)}`,
              e.posx,
              e.posy - hpBarOffset + 6
            );
            ctx.textAlign = "left"; // Resetear alineación
            ctx.textBaseline = "alphabetic"; // Resetear baseline

            // Charge bar background (solo si está vivo) - directamente debajo de la HP bar
            if (e.hp > 0) {
              ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
              ctx.fillRect(e.posx - 40, e.posy - hpBarOffset + 12, 80, 8);

              // Charge bar orange - barra continua sin divisiones
              ctx.fillStyle = "#FFA500";
              const chargeWidth = 80 * (e.charge / e.maxcharge);
              ctx.fillRect(
                e.posx - 40,
                e.posy - hpBarOffset + 12,
                chargeWidth,
                8
              );

              // Borde de charge bar
              ctx.strokeStyle = "black";
              ctx.lineWidth = 1;
              ctx.strokeRect(e.posx - 40, e.posy - hpBarOffset + 12, 80, 8);

              // Número de orden de turno para enemigo (si está en turnQueue)
              const enemyOrderIndex = turnQueue.indexOf(e);
              if (enemyOrderIndex !== -1) {
                ctx.save();
                const orderText = (enemyOrderIndex + 1).toString();
                ctx.font = "bold 8px 'Press Start 2P'";
                // Alinear a la derecha para posicionarlo similar a héroes (consistencia visual)
                ctx.textAlign = "right";
                ctx.textBaseline = "middle";
                ctx.strokeStyle = "#000";
                ctx.lineWidth = 3;
                ctx.fillStyle = enemyOrderIndex === 0 ? "#FFD700" : "#FFFFFF";
                // Separar un poco más: mover 6 píxeles extra hacia la izquierda (-46 como en héroes)
                const tx = e.posx - 46;
                const ty = e.posy - hpBarOffset + 16; // centrado vertical con la barra
                ctx.strokeText(orderText, tx, ty);
                ctx.fillText(orderText, tx, ty);
                ctx.restore();
              }

              // Mostrar contador de ataque especial dentro de esfera en el lado derecho del HUD
              if (
                (e.type === "boss" &&
                  e.attacksUntilSpecial !== null &&
                  e.attacksUntilSpecial <= 3) ||
                (e.name === "Crab Bomb" && e.maxSphereCharges)
              ) {
                let counterValue;
                if (e.name === "Crab Bomb") {
                  // Para Crab Bomb, cuenta regresiva: 5,4,3,2,1
                  counterValue = e.maxSphereCharges - (e.sphereCharges || 0);
                } else {
                  // Para bosses, mostrar ataques restantes: 3,2,1
                  counterValue = e.attacksUntilSpecial;
                }
                // Posicionar esfera en el extremo derecho del HUD enemigo (al final de la barra de carga)
                const radius = 12;
                // Barra de carga termina en x = e.posx - 40 + 80 = e.posx + 40
                // Colocamos la esfera con un pequeño margen (6px)
                let circleX = e.posx + 40 + radius + 6;
                const circleY = e.posy - hpBarOffset + 6 + radius; // centrada verticalmente respecto a la HP bar + charge

                // Si se sale del diseño (designWidth), reposicionar justo antes del borde
                if (circleX + radius > designWidth - 4) {
                  circleX = designWidth - 4 - radius;
                }

                ctx.save();
                // Esfera con color sólido solicitado
                ctx.beginPath();
                ctx.fillStyle = "#D3BF8F";
                ctx.arc(circleX, circleY, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.lineWidth = 2;
                ctx.strokeStyle = "#000";
                ctx.stroke();

                // Número centrado
                ctx.font = "bold 10px 'Press Start 2P'";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.lineWidth = 3;
                ctx.strokeStyle = "#000";
                ctx.fillStyle = "#FFF";
                ctx.strokeText(counterValue.toString(), circleX, circleY + 1);
                ctx.fillText(counterValue.toString(), circleX, circleY + 1);
                ctx.restore();
              }
            }

            // Borde de HP bar
            ctx.strokeStyle = "black";
            ctx.lineWidth = 1;
            ctx.strokeRect(e.posx - 40, e.posy - hpBarOffset, 80, 12);

            // Renderizar debuffs debajo de la barra de carga (solo si está vivo)
            renderDebuffs(e, e.posx, e.posy - hpBarOffset + 22);
          }
        });

        // Renderizar efectos visuales especiales
        renderVisualEffects();

        // Renderizar números de golpe flotantes
        renderHitNumbers();

        // Restaurar el contexto para poder renderizar UI sin restricciones
        ctx.restore();
        // Overlay de transición (después de render principal) si activo
        if (waveTransition.active) {
          const t = Math.max(0, waveTransition.timer / waveTransition.delay);
          const alpha = 0.25 * t; // leve y decreciente
          ctx.save();
          ctx.fillStyle = `rgba(0,0,0,${alpha.toFixed(3)})`;
          ctx.fillRect(0, 0, designWidth, designHeight);
          ctx.restore();
          if (waveTransition.timer <= 0) {
            waveTransition.active = false;
            if (pendingLevelInfo) {
              console.log(
                "Wave transition finished -> showing next level info screen"
              );
              pendingLevelInfo = false;
              state = "level_info";
            } else {
              console.log("Wave transition finished -> starting next wave...");
              startWave();
            }
          }
        }

        // Mostrar indicador de selección de objetivo con ventana modal
        if (state === "select_target_enemy") {
          // Modal que ocupa todo el ancho, centrado verticalmente
          const modalWidth = designWidth;
          const modalHeight = 40; // Aumentado para el texto más grande
          const modalX = 0;
          const modalY = (designHeight - modalHeight) / 2 - 50; // Movido 50px hacia arriba

          ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
          ctx.fillRect(modalX, modalY, modalWidth, modalHeight);

          // Texto principal - más grande y visible
          ctx.fillStyle = "#E0E0E0";
          ctx.font = "8px 'Press Start 2P'"; // Reducido de 10px a 8px
          ctx.textAlign = "center";
          ctx.fillText(
            "Select enemy",
            designWidth / 2,
            modalY + modalHeight / 2 + 3
          );
        } else if (state === "select_target_ally") {
          // Modal que ocupa todo el ancho, centrado verticalmente
          const modalWidth = designWidth;
          const modalHeight = 40; // Aumentado para el texto más grande
          const modalX = 0;
          const modalY = (designHeight - modalHeight) / 2 - 50; // Movido 50px hacia arriba

          ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
          ctx.fillRect(modalX, modalY, modalWidth, modalHeight);

          // Texto principal - más grande y visible
          ctx.fillStyle = "#E0E0E0";
          ctx.font = "10px 'Press Start 2P'"; // Aumentado de 7px a 10px
          ctx.textAlign = "center";
          ctx.fillText(
            "Select ally",
            designWidth / 2,
            modalY + modalHeight / 2 + 3
          );
        }
        ctx.textAlign = "left"; // Resetear alineación

        // Indicador visual removido - ya no necesario sin sistema de turnos

        // RENDERIZAR HEADER Y FOOTER AL FINAL para garantizar que siempre estén visibles
        drawHeader();
        drawFooter();
      }

      // Función helper para dibujar rectángulos redondeados
      function drawRoundedRect(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(
          x + width,
          y + height,
          x + width - radius,
          y + height
        );
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.stroke();
      }

      function drawHeader() {
        // Limpiar completamente el área del header para evitar interferencias
        ctx.clearRect(0, 0, designWidth, HEADER_HEIGHT);

        // Fondo del header
        ctx.fillStyle = "#D3BF8F";
        ctx.fillRect(0, 0, designWidth, HEADER_HEIGHT);

        // Borde inferior del header
        ctx.strokeStyle = "#3D2914";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, HEADER_HEIGHT);
        ctx.lineTo(designWidth, HEADER_HEIGHT);
        ctx.stroke();

        // Línea divisora horizontal entre score y level/wave
        ctx.strokeStyle = "#3D2914";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(0, HEADER_HEIGHT / 2);
        ctx.lineTo(designWidth, HEADER_HEIGHT / 2);
        ctx.stroke();

        // Líneas divisoras verticales en la sección inferior
        ctx.strokeStyle = "#3D2914";
        ctx.lineWidth = 4;
        ctx.beginPath();
        // Primera línea divisora (1/3)
        ctx.moveTo(designWidth / 3, HEADER_HEIGHT / 2);
        ctx.lineTo(designWidth / 3, HEADER_HEIGHT);
        // Segunda línea divisora (2/3)
        ctx.moveTo((designWidth * 2) / 3, HEADER_HEIGHT / 2);
        ctx.lineTo((designWidth * 2) / 3, HEADER_HEIGHT);
        ctx.stroke();

        // Marco interno para Score (sección superior completa)
        const frameMargin = 4; // Padding aumentado para mayor separación
        const dividerThickness = 4; // Grosor de las líneas divisoras
        const cornerRadius = 3; // Radio para esquinas redondeadas

        const scoreFrameX = frameMargin;
        const scoreFrameY = frameMargin;
        const scoreFrameWidth = designWidth - frameMargin * 2;
        const scoreFrameHeight =
          HEADER_HEIGHT / 2 - frameMargin * 2 - dividerThickness / 2; // Respeta frameMargin arriba y abajo + línea divisora

        ctx.strokeStyle = "#AF9E75";
        ctx.lineWidth = 2;
        drawRoundedRect(
          ctx,
          scoreFrameX,
          scoreFrameY,
          scoreFrameWidth,
          scoreFrameHeight,
          cornerRadius
        );

        // Marco interno para Level (primera sección inferior)
        const levelFrameX = frameMargin;
        const levelFrameY =
          HEADER_HEIGHT / 2 + dividerThickness / 2 + frameMargin; // Respeta la línea divisora
        const levelFrameWidth =
          designWidth / 3 - dividerThickness / 2 - frameMargin * 2; // Respeta el margen izquierdo y la línea divisora
        const levelFrameHeight =
          HEADER_HEIGHT / 2 - dividerThickness / 2 - frameMargin * 2;

        ctx.strokeStyle = "#AF9E75";
        ctx.lineWidth = 2;
        drawRoundedRect(
          ctx,
          levelFrameX,
          levelFrameY,
          levelFrameWidth,
          levelFrameHeight,
          cornerRadius
        );

        // Marco interno para Título (sección central inferior)
        const titleFrameX =
          designWidth / 3 + dividerThickness / 2 + frameMargin;
        const titleFrameY =
          HEADER_HEIGHT / 2 + dividerThickness / 2 + frameMargin; // Respeta la línea divisora
        const titleFrameWidth =
          designWidth / 3 - dividerThickness - frameMargin * 2;
        const titleFrameHeight =
          HEADER_HEIGHT / 2 - dividerThickness / 2 - frameMargin * 2;

        ctx.strokeStyle = "#AF9E75";
        ctx.lineWidth = 2;
        drawRoundedRect(
          ctx,
          titleFrameX,
          titleFrameY,
          titleFrameWidth,
          titleFrameHeight,
          cornerRadius
        );

        // Marco interno para Wave (tercera sección inferior)
        const waveFrameX =
          (designWidth * 2) / 3 + dividerThickness / 2 + frameMargin;
        const waveFrameY =
          HEADER_HEIGHT / 2 + dividerThickness / 2 + frameMargin; // Respeta la línea divisora
        const waveFrameWidth =
          designWidth / 3 - dividerThickness / 2 - frameMargin * 2; // Respeta el borde derecho
        const waveFrameHeight =
          HEADER_HEIGHT / 2 - dividerThickness / 2 - frameMargin * 2;

        ctx.strokeStyle = "#AF9E75";
        ctx.lineWidth = 2;
        drawRoundedRect(
          ctx,
          waveFrameX,
          waveFrameY,
          waveFrameWidth,
          waveFrameHeight,
          cornerRadius
        );

        // Score centrado en su marco
        ctx.font = "bold 9px 'Press Start 2P'"; // Reducido de 10px a 9px
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        const pointsText = "Points";
        const scoreText = score.toString();
        const totalScoreText = scoreText + " " + pointsText;

        // Centrar verticalmente en el marco del score
        const scoreCenterY = scoreFrameY + scoreFrameHeight / 2;

        // Texto del score en marrón sin borde
        ctx.fillStyle = "#3D2914";
        ctx.fillText(totalScoreText, designWidth / 2, scoreCenterY);

        // Calcular nivel y wave
        const currentLevel = Math.floor((wave - 1) / 3) + 1;
        const currentWaveInLevel = ((wave - 1) % 3) + 1;

        // Obtener título de la dungeon desde la configuración de niveles
        const currentLevelConfig = levelConfig[currentLevel] || levelConfig[1];
        const dungeonTitle = currentLevelConfig
          ? currentLevelConfig.name
          : "Demon Cave";

        // Configurar fuente y alineación para la sección inferior
        ctx.font = "bold 8px 'Press Start 2P'"; // Reducido de 9px a 8px
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // Level centrado en su marco
        const levelCenterX = levelFrameX + levelFrameWidth / 2;
        const levelCenterY = levelFrameY + levelFrameHeight / 2;
        const levelText = "Level " + currentLevel.toString();

        ctx.fillStyle = "#3D2914";
        ctx.fillText(levelText, levelCenterX, levelCenterY);

        // Título de la dungeon centrado en su marco (en marrón sin borde)
        const titleCenterX = titleFrameX + titleFrameWidth / 2;
        const titleCenterY = titleFrameY + titleFrameHeight / 2;

        // Dibujar texto en marrón sin borde, igual que el resto
        ctx.fillStyle = "#3D2914"; // Marrón igual que el resto de textos
        ctx.fillText(dungeonTitle, titleCenterX, titleCenterY);

        // Wave centrado en su marco
        const waveCenterX = waveFrameX + waveFrameWidth / 2;
        const waveCenterY = waveFrameY + waveFrameHeight / 2;
        const waveText = "Wave " + currentWaveInLevel.toString() + "/3";

        ctx.fillStyle = "#3D2914";
        ctx.fillText(waveText, waveCenterX, waveCenterY);

        ctx.textAlign = "left"; // Resetear alineación
        ctx.textBaseline = "alphabetic"; // Resetear baseline
      }

      function drawFooter() {
        // Limpiar completamente el área del footer para evitar interferencias
        ctx.clearRect(0, FOOTER_Y, designWidth, FOOTER_HEIGHT);

        // Fondo del footer - más oscuro y más alto
        ctx.fillStyle = "rgba(30, 20, 10, 0.9)";
        ctx.fillRect(0, FOOTER_Y, designWidth, FOOTER_HEIGHT);

        // Dividir en 3 columnas
        const columnWidth = designWidth / 3;
        const heroOrder = ["mage", "warlock", "priest"];

        heroOrder.forEach((heroClass, heroIndex) => {
          const hero = heroes.find((h) => h.clazz === heroClass);
          if (!hero) return;
          // Nota: En sistema de turnos sólo el héroe que está en la primera posición de turnQueue puede usar habilidades (se refleja desactivando botones)

          const columnX = heroIndex * columnWidth;
          const centerX = columnX + columnWidth / 2;

          // Dibujar panel para cada héroe - usar beige para todos con menos espacio entre cards
          const panelWidth = columnWidth - 5;
          const panelHeight = 110; // Aumentado de 90 a 110
          const panelX = columnX + 2.5;
          const panelY = 525; // Ajustado de 545 a 525

          ctx.drawImage(panelBeigeImg, panelX, panelY, panelWidth, panelHeight);

          // Título del héroe - siempre mismo color sin importar si está muerto
          ctx.fillStyle = "#3D2914"; // Siempre marrón oscuro
          ctx.font = "bold 8px 'Press Start 2P'";
          ctx.textAlign = "center";
          ctx.fillText(hero.clazz.toUpperCase(), centerX, 543); // Movido de 541 a 543 (+2px)

          if (hero.hp <= 0) {
            // Mostrar "DEAD" en lugar de botones
            ctx.fillStyle = "red";
            ctx.font = "bold 10px 'Press Start 2P'";
            ctx.textAlign = "center";
            ctx.fillText("DEAD", centerX, 585); // Ajustado de 595 a 585
          } else {
            const actions = Object.keys(classActions[hero.clazz]);

            // Configuración de botones - altura aumentada
            const buttonWidth = panelWidth - 14;
            const buttonHeight = 25; // Aumentado de 23 a 25
            const buttonX = panelX + 7;
            const buttonSpacing = 2; // Aumentado de 1 a 2

            // Botón habilidad principal (1 carga - 33.33%)
            const primaryAction = actions[0];
            const primaryData = classActions[hero.clazz][primaryAction];
            const buttonY1 = 550; // Ajustado de 567 a 550
            const canUsePrimary = hero.charge >= primaryData.reqCharge;
            const canActTurn = turnQueue.length > 0 && turnQueue[0] === hero;
            const canUsePrimaryTurn = canUsePrimary && canActTurn;

            // Usar botón beige si está activo, botón marrón si está inactivo
            const primaryButtonImg = canUsePrimaryTurn
              ? buttonLongBeigeImg
              : buttonLongBrownImg;
            ctx.drawImage(
              primaryButtonImg,
              buttonX,
              buttonY1,
              buttonWidth,
              buttonHeight
            );

            // Texto del botón principal - siempre marrón
            ctx.fillStyle = "#3D2914"; // Siempre marrón oscuro
            ctx.font = "bold 7px 'Press Start 2P'"; // Aumentado de 6px a 7px
            ctx.textAlign = "center";
            const primaryText =
              primaryData.name.charAt(0).toUpperCase() +
              primaryData.name.slice(1).toLowerCase();
            ctx.fillText(primaryText, centerX, buttonY1 + 16); // Ajustado para centrar mejor con altura 25

            // Botón habilidad secundaria (2 cargas - 66.66%)
            const secondaryAction = actions[1];
            const secondaryData = classActions[hero.clazz][secondaryAction];
            const buttonY2 = buttonY1 + buttonHeight + buttonSpacing;
            const canUseSecondary = hero.charge >= secondaryData.reqCharge;
            const canUseSecondaryTurn = canUseSecondary && canActTurn;

            const secondaryButtonImg = canUseSecondaryTurn
              ? buttonLongBeigeImg
              : buttonLongBrownImg;
            ctx.drawImage(
              secondaryButtonImg,
              buttonX,
              buttonY2,
              buttonWidth,
              buttonHeight
            );

            // Texto del botón secundario - siempre marrón
            ctx.fillStyle = "#3D2914"; // Siempre marrón oscuro
            ctx.font = "bold 7px 'Press Start 2P'"; // Aumentado de 6px a 7px
            ctx.textAlign = "center";
            const secondaryText =
              secondaryData.name.charAt(0).toUpperCase() +
              secondaryData.name.slice(1).toLowerCase();
            ctx.fillText(secondaryText, centerX, buttonY2 + 16); // Ajustado para centrar mejor con altura 25

            // Botón habilidad terciaria (3 cargas - 100%)
            const tertiaryAction = actions[2];
            const tertiaryData = classActions[hero.clazz][tertiaryAction];
            const buttonY3 = buttonY2 + buttonHeight + buttonSpacing;
            const canUseTertiary = hero.charge >= tertiaryData.reqCharge;
            const canUseTertiaryTurn = canUseTertiary && canActTurn;

            const tertiaryButtonImg = canUseTertiaryTurn
              ? buttonLongBeigeImg
              : buttonLongBrownImg;
            ctx.drawImage(
              tertiaryButtonImg,
              buttonX,
              buttonY3,
              buttonWidth,
              buttonHeight
            );

            // Texto del botón terciario - siempre marrón
            ctx.fillStyle = "#3D2914"; // Siempre marrón oscuro
            ctx.font = "bold 7px 'Press Start 2P'"; // Aumentado de 6px a 7px
            ctx.textAlign = "center";
            const tertiaryText =
              tertiaryData.name.charAt(0).toUpperCase() +
              tertiaryData.name.slice(1).toLowerCase();
            ctx.fillText(tertiaryText, centerX, buttonY3 + 16); // Ajustado para centrar mejor con altura 25
          }
        });

        ctx.textAlign = "left";
      }

      function drawMainMenu() {
        // Dibujar fondo de la pantalla de inicio sin compresión
        ctx.imageSmoothingEnabled = false; // Evitar suavizado/compresión
        ctx.drawImage(mainMenuImg, 0, 0, designWidth, designHeight);
        ctx.imageSmoothingEnabled = true; // Restaurar suavizado para otros elementos

        // Configuración de botones estilo habilidades
        const buttonWidth = 200;
        const buttonHeight = 40;
        const buttonSpacing = 20;
        const startY = 350;
        const buttonX = (designWidth - buttonWidth) / 2;

        // Botones: Start, Guide, Book
        const buttons = ["Start", "Guide", "Book"];

        buttons.forEach((buttonText, index) => {
          const buttonY = startY + index * (buttonHeight + buttonSpacing);

          // Usar estilo de botón similar a las habilidades
          ctx.drawImage(
            buttonLongBeigeImg,
            buttonX,
            buttonY,
            buttonWidth,
            buttonHeight
          );

          // Texto del botón con estilo similar a las habilidades
          ctx.fillStyle = "#3D2914"; // Marrón oscuro como los botones de habilidades
          ctx.font = "bold 19px 'Jersey 10'";
          ctx.textAlign = "center";
          ctx.fillText(buttonText, designWidth / 2, buttonY + 25);
        });

        ctx.textAlign = "left";
      }

      function drawLevelInfo() {
        const levelData = levelInfo[currentLevel];

        // Reproducir música del nivel correspondiente si no está sonando
        let targetMusic;
        if (currentLevel === 1) {
          targetMusic = level1Music;
        } else if (currentLevel === 2) {
          targetMusic = level2Music;
        } else if (currentLevel === 3) {
          targetMusic = level3Music;
        } else {
          targetMusic = level1Music; // Fallback
        }

        if (currentMusic !== targetMusic) {
          playMusic(targetMusic);
        }

        // Seleccionar el background correcto según el nivel
        let currentLevelBg;
        if (currentLevel === 1) {
          currentLevelBg = level1InfoBg;
        } else if (currentLevel === 2) {
          currentLevelBg = level2InfoBg;
        } else if (currentLevel === 3) {
          currentLevelBg = level3InfoBg;
        } else {
          currentLevelBg = level1InfoBg; // Fallback
        }

        // Dibujar fondo de imagen para las pantallas de nivel sin compresión
        ctx.imageSmoothingEnabled = false; // Evitar suavizado/compresión
        ctx.drawImage(currentLevelBg, 0, 0, designWidth, designHeight);
        ctx.imageSmoothingEnabled = true; // Restaurar suavizado para otros elementos

        // Oscurecer ligeramente el fondo
        ctx.fillStyle = "rgba(0, 0, 0, 0.15)";
        ctx.fillRect(0, 0, designWidth, designHeight);

        // Marco decorativo
        ctx.strokeStyle = "#D3BF8F";
        ctx.lineWidth = 2;
        ctx.strokeRect(20, 20, designWidth - 40, designHeight - 40);

        // Título del nivel
        ctx.fillStyle = "#D3BF8F";
        ctx.strokeStyle = "#000000"; // Borde negro para mejor contraste
        ctx.lineWidth = 3;
        ctx.font = "bold 36px 'Jersey 10'";
        ctx.letterSpacing = "0.1px";
        ctx.textAlign = "center";

        const levelTitle = `Level ${currentLevel}`;
        ctx.strokeText(levelTitle, designWidth / 2, 120);
        ctx.fillText(levelTitle, designWidth / 2, 120);

        // Nombre del nivel
        ctx.font = "bold 30px 'Jersey 10'";
        ctx.letterSpacing = "0.1px";
        ctx.strokeStyle = "#000000"; // Borde negro para mejor contraste
        ctx.strokeText(levelData.name, designWidth / 2, 160);
        ctx.fillText(levelData.name, designWidth / 2, 160);

        // Lore del nivel (texto envuelto) - usando Jacquard 24
        ctx.font = "18px 'Jacquard 24'";
        ctx.fillStyle = "#FFFFFF";
        ctx.strokeStyle = "#2A1F0F";
        ctx.lineWidth = 1;

        const loreLines = wrapText(levelData.lore, 280);
        const lineHeight = 32;
        const startY = 220;

        loreLines.forEach((line, index) => {
          const y = startY + index * lineHeight;
          ctx.strokeText(line, designWidth / 2, y);
          ctx.fillText(line, designWidth / 2, y);
        });

        // Botón "Explore" estilo habilidades
        const buttonY = 420;
        const buttonWidth = 200;
        const buttonHeight = 40;
        const buttonX = (designWidth - buttonWidth) / 2;

        // Usar estilo de botón similar a las habilidades
        ctx.drawImage(
          buttonLongBeigeImg,
          buttonX,
          buttonY,
          buttonWidth,
          buttonHeight
        );

        // Texto del botón con estilo similar a las habilidades
        ctx.fillStyle = "#3D2914"; // Marrón oscuro como los botones de habilidades
        ctx.font = "bold 19px 'Jersey 10'";
        ctx.textAlign = "center";
        ctx.fillText("Explore", designWidth / 2, buttonY + 25);

        ctx.textAlign = "left";
      }

      function drawLevelCompletion() {
        // Dibujar fondo del juego actual
        ctx.drawImage(currentBackgroundImg, 0, 0, designWidth, designHeight);

        // Overlay oscuro
        ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
        ctx.fillRect(0, 0, designWidth, designHeight);

        // Modal central
        const modalWidth = 300;
        const modalHeight = 290; // Aumentado para acomodar el botón Surrender
        const modalX = (designWidth - modalWidth) / 2;
        const modalY = (designHeight - modalHeight) / 2;

        // Fondo del modal
        ctx.fillStyle = "rgba(20, 20, 20, 0.95)";
        ctx.fillRect(modalX, modalY, modalWidth, modalHeight);

        // Marco del modal con el mismo estilo que las pantallas de nivel
        ctx.strokeStyle = "#D3BF8F";
        ctx.lineWidth = 2;
        ctx.strokeRect(modalX, modalY, modalWidth, modalHeight);

        // Título del modal con el mismo estilo que los títulos de nivel
        ctx.fillStyle = "#D3BF8F";
        ctx.strokeStyle = "#000000"; // Borde negro como los títulos de nivel
        ctx.lineWidth = 3;
        ctx.font = "bold 24px 'Jersey 10'";
        ctx.letterSpacing = "0.1px";
        ctx.textAlign = "center";

        let titleText;
        if (levelCompletionModal.gameCompleted) {
          titleText = "Victory!";
        } else {
          titleText = `${levelCompletionModal.boss} Defeated`;
        }

        ctx.strokeText(titleText, designWidth / 2, modalY + 50);
        ctx.fillText(titleText, designWidth / 2, modalY + 50);

        // Texto de preparación para siguiente nivel
        ctx.font = "18px 'Jacquard 24'";
        ctx.fillStyle = "#FFFFFF";
        ctx.strokeStyle = "#2A1F0F";
        ctx.lineWidth = 1;

        let readyText;
        if (levelCompletionModal.gameCompleted) {
          readyText = "You have conquered all dungeons!";
        } else {
          readyText = "Ready for the next level?";
        }

        const readyLines = wrapText(readyText, modalWidth - 40);
        readyLines.forEach((line, index) => {
          const y = modalY + 90 + index * 24;
          ctx.strokeText(line, designWidth / 2, y);
          ctx.fillText(line, designWidth / 2, y);
        });

        // Botón Continue estilo habilidades
        const continueButtonY = modalY + 150;
        const buttonWidth = 160;
        const buttonHeight = 40;
        const buttonX = (designWidth - buttonWidth) / 2;

        // Usar estilo de botón similar a las habilidades
        ctx.drawImage(
          buttonLongBeigeImg,
          buttonX,
          continueButtonY,
          buttonWidth,
          buttonHeight
        );

        // Texto del botón Continue
        ctx.fillStyle = "#3D2914"; // Marrón oscuro como los botones de habilidades
        ctx.font = "bold 17px 'Jersey 10'";
        ctx.textAlign = "center";

        let continueButtonText;
        if (levelCompletionModal.gameCompleted) {
          continueButtonText = "Main Menu";
        } else {
          continueButtonText = "Continue";
        }

        ctx.fillText(continueButtonText, designWidth / 2, continueButtonY + 25);

        // Botón Surrender (solo si no es el final del juego)
        if (!levelCompletionModal.gameCompleted) {
          const surrenderButtonY = continueButtonY + buttonHeight + 10;

          // Usar el mismo estilo de botón
          ctx.drawImage(
            buttonLongBeigeImg,
            buttonX,
            surrenderButtonY,
            buttonWidth,
            buttonHeight
          );

          // Texto del botón Surrender en rojo
          ctx.fillStyle = "#CC0000"; // Rojo para surrender
          ctx.font = "bold 17px 'Jersey 10'";
          ctx.textAlign = "center";
          ctx.fillText("Surrender", designWidth / 2, surrenderButtonY + 25);
        }

        ctx.textAlign = "left";
      }

      // Función para dibujar la pantalla del libro de monstruos
      function drawMonsterBook() {
        // Dibujar fondo del libro
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(bookBackgroundImg, 0, 0, designWidth, designHeight);

        // Datos de todos los monstruos organizados por nivel
        const monstersData = [
          // Level 1 - The Crypt
          {
            name: "Demon Bat",
            type: "Normal Enemy",
            level: "The Forgotten Crypt",
            hp: 80,
            abilities: ["Basic Attack: Low to medium damage to random hero"],
            description:
              "Swift flying creatures that inhabit dark crypts. Their speed makes them dangerous opponents.",
            sprite: demonBatIdleImg,
            frameWidth: 81,
            frameHeight: 71,
            idleFrames: 4,
          },
          {
            name: "Noctebane (BOSS)",
            type: "Boss",
            level: "The Forgotten Crypt",
            hp: 200,
            abilities: [
              "Blood Splat: Normal damage to random hero",
              "Blood Storm: Damages all heroes (after 3 basic attacks)",
              "Passive: Each attack increases its damage by 5% (stacks)",
            ],
            description:
              "The Shadow Bat Lord that rules over the forgotten crypt. Master of dark blood magic.",
            sprite: bossBatIdleImg,
            frameWidth: 81,
            frameHeight: 71,
            idleFrames: 4,
          },
          // Level 2 - Red Dunes
          {
            name: "Fire Worm",
            type: "Normal Enemy",
            level: "The Red Dunes",
            hp: 80,
            abilities: ["Basic Attack: Medium damage to random hero"],
            description:
              "Desert predators that burrow beneath the crimson sands, emerging to ambush unwary travelers.",
            sprite: wormIdleImg,
            frameWidth: 90,
            frameHeight: 90,
            idleFrames: 9,
          },
          {
            name: "Crab Bomb",
            type: "Special Enemy",
            level: "The Red Dunes",
            hp: 150,
            abilities: ["Explode: High damage to all heroes (after 5 charges)"],
            description:
              "Volatile crustaceans that sacrifice themselves in devastating explosions. No basic attacks.",
            sprite: crabBombIdleImg,
            frameWidth: 80,
            frameHeight: 80,
            idleFrames: 13,
          },
          {
            name: "Minotaur (BOSS)",
            type: "Boss",
            level: "The Red Dunes",
            hp: 300,
            abilities: [
              "Smash: Heavy damage to random hero",
              "Life Steal: Damages hero and heals self (after 3 attacks)",
              "Passive: Gains +5% charge speed after every attack (stacks)",
            ],
            description:
              "The mighty guardian of the Red Dunes. This beast grows stronger as the battle progresses.",
            sprite: minotaurAllStatesImg,
            frameWidth: 288,
            frameHeight: 160,
            idleFrames: 16,
          },
          // Level 3 - Dark Swamp
          {
            name: "Mushroom",
            type: "Normal Enemy",
            level: "The Dark Swamp",
            hp: 100,
            abilities: ["Poison Attack: Damages and poisons target hero"],
            description:
              "Toxic fungi that release deadly spores. Their poison can weaken heroes over time.",
            sprite: mushroomIdleImg,
            frameWidth: 80,
            frameHeight: 64,
            idleFrames: 7,
          },
          {
            name: "Dreadwing",
            type: "Flying Enemy",
            level: "The Dark Swamp",
            hp: 90,
            abilities: ["Double Strike: Attacks twice in succession"],
            description:
              "Sinister flying creatures that patrol the marshlands. Their speed allows for devastating combos.",
            sprite: dreadwingIdleImg,
            frameWidth: 64,
            frameHeight: 64,
            idleFrames: 8,
          },
          {
            name: "Gorgon (BOSS)",
            type: "Boss",
            level: "The Dark Swamp",
            hp: 400,
            abilities: [
              "Basic Attack: Poison attack (identical to Mushroom)",
              "Toxic Horror: Massive poison damage to all heroes (after 3 attacks)",
            ],
            description:
              "The ancient master of the Dark Swamp. Her toxic presence corrupts everything around her.",
            sprite: swampGorgonIdleImg,
            frameWidth: 128,
            frameHeight: 128,
            idleFrames: 7,
          },
        ];

        // Configuración de las cartas
        const cardWidth = 320;
        const cardHeight = 310; // Aumentado (antes 280) para acomodar pasivas adicionales
        const cardsPerRow = 1; // Una carta por fila para mejor legibilidad
        const cardSpacing = 15;
        const startX = (designWidth - cardWidth) / 2;
        const startY = 60;

        // Título principal (más grande para móviles)
        ctx.fillStyle = "#4A3728";
        ctx.font = "bold 32px 'Jacquard 24'"; // Aumentado de 28px a 32px
        ctx.textAlign = "center";
        ctx.fillText("Monster Codex", designWidth / 2, 35);

        // Calcular altura total real (incluye desplazamiento inicial y elimina el spacing final sobrante)
        const totalHeight =
          startY +
          monstersData.length * (cardHeight + cardSpacing) -
          cardSpacing;
        const headerHeight = 50;
        const footerHeight = 60;
        const contentAreaHeight = designHeight - headerHeight - footerHeight;
        const maxScrollY = Math.max(0, totalHeight - contentAreaHeight);

        // Limitar scroll
        bookScrollY = Math.max(0, Math.min(bookScrollY, maxScrollY));

        // Área de contenido con scroll - entre header y footer
        ctx.save();
        ctx.beginPath();
        ctx.rect(0, headerHeight, designWidth, contentAreaHeight);
        ctx.clip();

        monstersData.forEach((monster, index) => {
          const cardY =
            startY + index * (cardHeight + cardSpacing) - bookScrollY;

          // Solo dibujar cartas visibles
          if (cardY > -cardHeight - 50 && cardY < designHeight + 50) {
            drawMonsterCard(monster, startX, cardY, cardWidth, cardHeight);
          }
        });

        ctx.restore();

        // FOOTER FIJO
        const footerY = designHeight - footerHeight;

        // Fondo del footer - usar la misma textura que el background
        ctx.drawImage(
          bookBackgroundImg,
          0,
          footerY,
          designWidth,
          footerHeight,
          0,
          footerY,
          designWidth,
          footerHeight
        );

        // Botón Back centrado en el footer
        const backButtonWidth = 120;
        const backButtonHeight = 40;
        const backButtonX = (designWidth - backButtonWidth) / 2;
        const backButtonY = footerY + 10;

        ctx.drawImage(
          buttonLongBeigeImg,
          backButtonX,
          backButtonY,
          backButtonWidth,
          backButtonHeight
        );

        ctx.fillStyle = "#4A3728";
        ctx.font = "bold 16px 'Jersey 10'";
        ctx.textAlign = "center";
        ctx.fillText(
          "Back",
          backButtonX + backButtonWidth / 2,
          backButtonY + 25
        );

        // Indicador de scroll si es necesario (ajustado para el nuevo layout)
        if (maxScrollY > 0) {
          const scrollBarHeight = contentAreaHeight - 40;
          const scrollBarX = designWidth - 15;
          const scrollBarY = headerHeight + 20;
          const scrollPosition =
            (bookScrollY / maxScrollY) * (scrollBarHeight - 20);

          // Barra de scroll de fondo
          ctx.fillStyle = "rgba(74, 55, 40, 0.3)";
          ctx.fillRect(scrollBarX, scrollBarY, 8, scrollBarHeight);

          // Indicador de posición
          ctx.fillStyle = "#4A3728";
          ctx.fillRect(scrollBarX, scrollBarY + scrollPosition, 8, 20);
        }
      }

      function drawMonsterCard(monster, x, y, width, height) {
        // Border de la carta con esquinas redondeadas
        ctx.strokeStyle = "#4A3728"; // Marrón oscuro
        ctx.lineWidth = 3;

        // Crear path con esquinas redondeadas
        const radius = 10;
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(
          x + width,
          y + height,
          x + width - radius,
          y + height
        );
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.stroke();

        // PRIMERA FILA - 2 columnas
        const padding = 15;
        const firstRowHeight = 120; // Aumentado para más espacio

        // Columna 1: Sprite del enemigo (tamaño especial para Minotaur)
        let spriteSize = 80;
        if (monster.name.includes("Minotaur")) {
          spriteSize = 100; // Más grande para el Minotaur
        }
        const spriteX = x + padding;
        const spriteY = y + padding;

        if (monster.sprite) {
          // Calcular frame para animación idle
          const frame = Math.floor((currentTime * 8) % monster.idleFrames);
          const sx = frame * monster.frameWidth;
          const sy = 0; // Row 0 para idle normalmente

          ctx.drawImage(
            monster.sprite,
            sx,
            sy,
            monster.frameWidth,
            monster.frameHeight,
            spriteX,
            spriteY,
            spriteSize,
            spriteSize
          );
        }

        // Columna 2: Nombre y HP
        const textStartX = spriteX + spriteSize + 20;
        let currentY = y + padding + 15;

        // Nombre (en marrón oscuro, más grande)
        ctx.fillStyle = "#4A3728";
        ctx.font = "bold 22px 'Jersey 10'"; // Aumentado de 18px a 22px
        ctx.textAlign = "left";
        ctx.fillText(monster.name, textStartX, currentY);
        currentY += 35;

        // HP (más grande)
        ctx.fillStyle = "#B22222";
        ctx.font = "bold 18px 'Jersey 10'"; // Aumentado de 16px a 18px
        ctx.fillText(`HP: ${monster.hp}`, textStartX, currentY);
        currentY += 25;

        // Nivel donde aparece (nuevo)
        ctx.fillStyle = "#654321";
        ctx.font = "16px 'Jersey 10'";
        ctx.fillText(`Level: ${monster.level}`, textStartX, currentY);

        // SEGUNDA FILA - 1 columna completa
        const secondRowY = y + firstRowHeight + padding;
        const fullWidth = width - padding * 2;
        currentY = secondRowY;

        // Título "Abilities" (añadido de vuelta)
        ctx.fillStyle = "#4A3728";
        ctx.font = "bold 18px 'Jersey 10'"; // Más grande que antes
        ctx.fillText("Abilities:", x + padding, currentY);
        currentY += 25;

        // Habilidades (más grandes)
        ctx.fillStyle = "#4A3728";
        ctx.font = "16px 'Jersey 10'"; // Aumentado de 14px a 16px

        monster.abilities.forEach((ability) => {
          const abilityLines = wrapTextForCard(ability, fullWidth);
          abilityLines.forEach((line) => {
            ctx.fillText(`• ${line}`, x + padding, currentY);
            currentY += 18; // Aumentado el spacing
          });
        });

        // Espacio entre habilidades y lore
        currentY += 15;

        // Lore/Descripción (más grande)
        ctx.fillStyle = "#654321";
        ctx.font = "15px 'Jersey 10'"; // Aumentado de 13px a 15px
        const descLines = wrapTextForCard(monster.description, fullWidth);
        descLines.forEach((line) => {
          ctx.fillText(line, x + padding, currentY);
          currentY += 17; // Aumentado el spacing
        });
      }

      function wrapTextForCard(text, maxWidth) {
        const words = text.split(" ");
        const lines = [];
        let currentLine = "";

        for (let word of words) {
          const testLine = currentLine + (currentLine ? " " : "") + word;
          const metrics = ctx.measureText(testLine);

          if (metrics.width > maxWidth && currentLine) {
            lines.push(currentLine);
            currentLine = word;
          } else {
            currentLine = testLine;
          }
        }

        if (currentLine) {
          lines.push(currentLine);
        }

        return lines;
      }

      // Función auxiliar para envolver texto
      function wrapText(text, maxWidth) {
        const words = text.split(" ");
        const lines = [];
        let currentLine = "";

        for (let word of words) {
          const testLine = currentLine + (currentLine ? " " : "") + word;
          const metrics = ctx.measureText(testLine);

          if (metrics.width > maxWidth && currentLine) {
            lines.push(currentLine);
            currentLine = word;
          } else {
            currentLine = testLine;
          }
        }

        if (currentLine) {
          lines.push(currentLine);
        }

        return lines;
      }

      // Función para dibujar la pantalla de guía
      function drawGuide() {
        // Dibujar fondo usando la misma textura que el book
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(bookBackgroundImg, 0, 0, designWidth, designHeight);

        // Configuración de layout
        const headerHeight = 50;
        const footerHeight = 60;
        const contentAreaHeight = designHeight - headerHeight - footerHeight;

        // Título principal (más grande para móviles)
        ctx.fillStyle = "#4A3728";
        ctx.font = "bold 32px 'Jacquard 24'"; // Misma fuente que Monster Codex
        ctx.textAlign = "center";
        ctx.fillText("Game Guide", designWidth / 2, 35);

        // Contenido de la guía
        const guideContent = [
          {
            title: "🌀 Turn & Charge System",
            content:
              "Combat is turn-based through a shared charge queue. When a hero's bar fills, they may use ANY of their abilities (no individual energy costs). After using one, their bar resets. Enemies act the same way, one at a time.",
          },
          {
            title: "⏳ Status Durations",
            content:
              "Effects advance only on turn starts. Shadows: deals damage each turn and gains +1 damage per extra stack. Poison: deals 2 base +1 per extra stack each turn. Regrowth: heals all allies 4–5 HP per turn for 5 turns. Agony: party defense buff for 10 turns.",
          },
          {
            title: "🏹 Enemy Attacks",
            content:
              "Enemies act when their charge bar fills. Bosses often prepare powerful specials after a set number of basic attacks—watch their patterns.",
          },
          {
            title: "💀 Special Abilities",
            content:
              "Some enemies prepare specials after a fixed number of actions (e.g., 3 attacks). Others (like bombs) charge only to unleash a large effect. Plan around these timers.",
          },
          {
            title: "📈 Difficulty Progression",
            content:
              "Each level increases in difficulty with stronger enemies and more challenging encounters.",
          },
          {
            title: "🧠 Strategic Combat",
            content:
              "Use abilities at the right moment: finish low HP targets, stack Shadows/Poison efficiently, and time heals before enemy bursts.",
          },
          {
            title: "⚔️ Hero Abilities",
            content: "",
          },
        ];

        // Hero abilities detailed info
        const heroAbilities = [
          {
            hero: "Mage",
            abilities: [
              "Fireblast: High single-target damage (never hits allies)",
              "Combustion: Increases critical chance for the NEXT damage ability only, then the buff is consumed",
              "Inferno: Lower single-target damage than Fireblast but hits ALL enemies (never allies)",
            ],
          },
          {
            hero: "Warlock",
            abilities: [
              "Dark Slash: Damage + applies 'Shadows' (damage every turn, +1 damage per extra stack)",
              "Agony: Grants party defense for 10 turns (no damage reflection)",
              "Immolation: Massive damage to all enemies but removes 60% of Warlock HP",
            ],
          },
          {
            hero: "Priest",
            abilities: [
              "Holy Wave: Strong single-target heal",
              "Smite: Moderate damage to one enemy",
              "Regrowth: Heals all allies 4–5 HP each turn for 5 turns",
            ],
          },
        ];

        // Calcular altura total del contenido
        const sectionSpacing = 25;
        const lineHeight = 20;
        const titleHeight = 30;
        let totalContentHeight = 0;

        // Simular el renderizado para calcular altura real
        ctx.font = "16px 'Jersey 10'"; // Establecer fuente para medición

        guideContent.forEach((section) => {
          totalContentHeight += titleHeight + 10; // Título + spacing
          if (section.content) {
            const lines = wrapGuideText(section.content, 280);
            totalContentHeight += lines.length * lineHeight + sectionSpacing;
          }
        });

        // Añadir altura para las habilidades de héroes (cálculo más preciso)
        heroAbilities.forEach((hero) => {
          totalContentHeight += titleHeight + 10; // Título del héroe
          hero.abilities.forEach((ability) => {
            const lines = wrapGuideText(`• ${ability}`, 260);
            totalContentHeight += lines.length * lineHeight + 5;
          });
          totalContentHeight += sectionSpacing;
        });

        // Añadir padding extra al final para asegurar que se pueda hacer scroll hasta el final
        totalContentHeight += 40;

        const maxScrollY = Math.max(0, totalContentHeight - contentAreaHeight);
        guideScrollY = Math.max(0, Math.min(guideScrollY, maxScrollY));

        // Área de contenido con scroll
        ctx.save();
        ctx.beginPath();
        ctx.rect(0, headerHeight, designWidth, contentAreaHeight);
        ctx.clip();

        let currentY = headerHeight + 20 - guideScrollY;
        const contentX = 20;

        // Renderizar contenido de la guía
        guideContent.forEach((section) => {
          // Título de la sección
          ctx.fillStyle = "#4A3728";
          ctx.font = "bold 22px 'Jersey 10'"; // Misma fuente que nombres de monstruos
          ctx.textAlign = "left";
          ctx.fillText(section.title, contentX, currentY);
          currentY += titleHeight + 10;

          // Contenido de la sección
          if (section.content) {
            ctx.fillStyle = "#654321"; // Mismo color que el lore en las cartas
            ctx.font = "16px 'Jersey 10'"; // Misma fuente que el texto de habilidades
            const lines = wrapGuideText(section.content, 280);
            lines.forEach((line) => {
              ctx.fillText(line, contentX + 15, currentY);
              currentY += lineHeight;
            });
            currentY += sectionSpacing;
          }
        });

        // Renderizar habilidades de héroes
        heroAbilities.forEach((hero) => {
          ctx.fillStyle = "#4A3728";
          ctx.font = "bold 22px 'Jersey 10'"; // Mismo estilo que títulos de sección
          ctx.fillText(`${hero.hero}:`, contentX + 15, currentY);
          currentY += titleHeight;

          hero.abilities.forEach((ability) => {
            ctx.fillStyle = "#654321"; // Mismo color que el contenido
            ctx.font = "16px 'Jersey 10'"; // Misma fuente
            const lines = wrapGuideText(`• ${ability}`, 260);
            lines.forEach((line) => {
              ctx.fillText(line, contentX + 30, currentY);
              currentY += lineHeight;
            });
            currentY += 5;
          });
          currentY += sectionSpacing;
        });

        ctx.restore();

        // FOOTER con el mismo estilo que el Book
        const footerY = designHeight - footerHeight;

        // Fondo del footer usando la misma textura
        ctx.drawImage(
          bookBackgroundImg,
          0,
          footerY,
          designWidth,
          footerHeight,
          0,
          footerY,
          designWidth,
          footerHeight
        );

        // Botón Back centrado en el footer
        const backButtonWidth = 120;
        const backButtonHeight = 40;
        const backButtonX = (designWidth - backButtonWidth) / 2;
        const backButtonY = footerY + 10;

        ctx.drawImage(
          buttonLongBeigeImg,
          backButtonX,
          backButtonY,
          backButtonWidth,
          backButtonHeight
        );

        ctx.fillStyle = "#4A3728";
        ctx.font = "bold 16px 'Jersey 10'";
        ctx.textAlign = "center";
        ctx.fillText(
          "Back",
          backButtonX + backButtonWidth / 2,
          backButtonY + 25
        );

        // Indicador de scroll si es necesario
        if (maxScrollY > 0) {
          const scrollBarHeight = contentAreaHeight - 40;
          const scrollBarX = designWidth - 15;
          const scrollBarY = headerHeight + 20;
          const scrollPosition =
            (guideScrollY / maxScrollY) * (scrollBarHeight - 20);

          // Barra de scroll de fondo
          ctx.fillStyle = "rgba(74, 55, 40, 0.3)";
          ctx.fillRect(scrollBarX, scrollBarY, 8, scrollBarHeight);

          // Indicador de posición
          ctx.fillStyle = "#4A3728";
          ctx.fillRect(scrollBarX, scrollBarY + scrollPosition, 8, 20);
        }
      }

      // Función auxiliar para envolver texto en la guía
      function wrapGuideText(text, maxWidth) {
        const words = text.split(" ");
        const lines = [];
        let currentLine = "";

        for (let word of words) {
          const testLine = currentLine + (currentLine ? " " : "") + word;
          const metrics = ctx.measureText(testLine);

          if (metrics.width > maxWidth && currentLine) {
            lines.push(currentLine);
            currentLine = word;
          } else {
            currentLine = testLine;
          }
        }

        if (currentLine) {
          lines.push(currentLine);
        }

        return lines;
      }

      canvas.addEventListener("touchstart", handleInput);
      canvas.addEventListener("touchmove", handleTouchMove);
      canvas.addEventListener("touchend", handleTouchEnd);
      canvas.addEventListener("click", handleInput);
      canvas.addEventListener("wheel", handleWheel);

      function handleTouchMove(e) {
        e.preventDefault();
        if (state === "book" && isDragging) {
          const rect = canvas.getBoundingClientRect();
          const touchY =
            (e.touches[0].clientY - rect.top) * (designHeight / rect.height);

          const deltaY = lastTouchY - touchY;
          const monstersCount = 8;
          const cardHeight = 280;
          const cardSpacing = 15;
          const totalHeight = monstersCount * (cardHeight + cardSpacing);
          const headerHeight = 50;
          const footerHeight = 60;
          const contentAreaHeight = designHeight - headerHeight - footerHeight;
          const maxScrollY = Math.max(0, totalHeight - contentAreaHeight);

          bookScrollY = Math.max(0, Math.min(maxScrollY, bookScrollY + deltaY));
          lastTouchY = touchY;
        }

        if (state === "guide" && isDragging) {
          const rect = canvas.getBoundingClientRect();
          const touchY =
            (e.touches[0].clientY - rect.top) * (designHeight / rect.height);

          const deltaY = lastTouchY - touchY;

          // Calcular altura del contenido de la guía de forma más precisa
          const sectionSpacing = 25;
          const lineHeight = 20;
          const titleHeight = 30;

          // Simular altura de contenido general
          const sectionsCount = 7;
          const avgLinesPerSection = 4; // Promedio de líneas por sección
          const sectionsHeight =
            sectionsCount *
            (titleHeight +
              10 +
              avgLinesPerSection * lineHeight +
              sectionSpacing);

          // Simular altura de habilidades de héroes
          const heroesCount = 3;
          const avgAbilitiesPerHero = 3;
          const avgLinesPerAbility = 2; // Promedio de líneas por habilidad
          const heroAbilitiesHeight =
            heroesCount *
            (titleHeight +
              10 +
              avgAbilitiesPerHero * avgLinesPerAbility * lineHeight +
              sectionSpacing);

          const totalContentHeight = sectionsHeight + heroAbilitiesHeight + 40; // 40 padding extra

          const headerHeight = 50;
          const footerHeight = 60;
          const contentAreaHeight = designHeight - headerHeight - footerHeight;
          const maxScrollY = Math.max(
            0,
            totalContentHeight - contentAreaHeight
          );

          guideScrollY = Math.max(
            0,
            Math.min(maxScrollY, guideScrollY + deltaY)
          );
          lastTouchY = touchY;
        }
      }

      function handleTouchEnd(e) {
        e.preventDefault();
        isDragging = false;
      }

      function handleWheel(e) {
        e.preventDefault();
        if (state === "book") {
          const monstersCount = 8; // Total de monstruos (mantener sincronizado con monstersData)
          const startY = 60; // Mismo offset usado en drawMonsterBook
          const cardHeight = 310; // Altura actualizada de la carta
          const cardSpacing = 15; // Espaciado entre cartas
          // Altura total real incluyendo offset inicial y sin sumar spacing al final
          const totalHeight =
            startY + monstersCount * (cardHeight + cardSpacing) - cardSpacing;
          const headerHeight = 50;
          const footerHeight = 60;
          const contentAreaHeight = designHeight - headerHeight - footerHeight;
          const maxScrollY = Math.max(0, totalHeight - contentAreaHeight);

          if (e.deltaY > 0) {
            // Scroll hacia abajo
            bookScrollY = Math.min(maxScrollY, bookScrollY + bookScrollSpeed);
          } else {
            // Scroll hacia arriba
            bookScrollY = Math.max(0, bookScrollY - bookScrollSpeed);
          }
        }

        if (state === "guide") {
          // Calcular altura del contenido de la guía de forma más precisa
          const sectionSpacing = 25;
          const lineHeight = 20;
          const titleHeight = 30;

          // Simular altura de contenido general
          const sectionsCount = 7;
          const avgLinesPerSection = 4; // Promedio de líneas por sección
          const sectionsHeight =
            sectionsCount *
            (titleHeight +
              10 +
              avgLinesPerSection * lineHeight +
              sectionSpacing);

          // Simular altura de habilidades de héroes
          const heroesCount = 3;
          const avgAbilitiesPerHero = 3;
          const avgLinesPerAbility = 2; // Promedio de líneas por habilidad
          const heroAbilitiesHeight =
            heroesCount *
            (titleHeight +
              10 +
              avgAbilitiesPerHero * avgLinesPerAbility * lineHeight +
              sectionSpacing);

          const totalContentHeight = sectionsHeight + heroAbilitiesHeight + 40; // 40 padding extra

          const headerHeight = 50;
          const footerHeight = 60;
          const contentAreaHeight = designHeight - headerHeight - footerHeight;
          const maxScrollY = Math.max(
            0,
            totalContentHeight - contentAreaHeight
          );

          if (e.deltaY > 0) {
            // Scroll hacia abajo
            guideScrollY = Math.min(maxScrollY, guideScrollY + bookScrollSpeed);
          } else {
            // Scroll hacia arriba
            guideScrollY = Math.max(0, guideScrollY - bookScrollSpeed);
          }
        }
      }

      function handleInput(e) {
        e.preventDefault();

        // Inicializar audio en el primer clic del usuario
        initializeAudio();

        const rect = canvas.getBoundingClientRect();
        let clientX, clientY;

        if (e.type === "touchstart") {
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
        } else {
          clientX = e.clientX;
          clientY = e.clientY;
        }

        const touchX = (clientX - rect.left) * (designWidth / rect.width);
        const touchY = (clientY - rect.top) * (designHeight / rect.height);

        // Manejar clics en el menú principal
        if (state === "main_menu") {
          // NO reproducir música en el menú principal

          // Coordenadas de los nuevos botones estilo habilidades
          const buttonWidth = 200;
          const buttonHeight = 40;
          const buttonSpacing = 20;
          const startY = 350;
          const buttonX = (designWidth - buttonWidth) / 2;

          // Verificar clic en botón Start
          const startButtonY = startY;
          if (
            touchX >= buttonX &&
            touchX <= buttonX + buttonWidth &&
            touchY >= startButtonY &&
            touchY <= startButtonY + buttonHeight
          ) {
            console.log("Start button clicked");
            startGame();
            return;
          }

          // Verificar clic en botón Guide
          const guideButtonY = startY + buttonHeight + buttonSpacing;
          if (
            touchX >= buttonX &&
            touchX <= buttonX + buttonWidth &&
            touchY >= guideButtonY &&
            touchY <= guideButtonY + buttonHeight
          ) {
            console.log("Guide button clicked");
            state = "guide";
            guideScrollY = 0; // Reset scroll al abrir la guía
            // Mantener música del menú para Guide
            return;
          }

          // Verificar clic en botón Book
          const bookButtonY = startY + 2 * (buttonHeight + buttonSpacing);
          if (
            touchX >= buttonX &&
            touchX <= buttonX + buttonWidth &&
            touchY >= bookButtonY &&
            touchY <= bookButtonY + buttonHeight
          ) {
            console.log("Book button clicked");
            state = "book";
            bookScrollY = 0; // Resetear scroll al abrir el libro
            // Mantener música del menú para Book
            return;
          }
        }

        // Manejar clics en la pantalla de información de nivel
        if (state === "level_info") {
          const buttonY = 420;
          const buttonWidth = 200;
          const buttonHeight = 40;
          const buttonX = (designWidth - buttonWidth) / 2;

          // Verificar clic en botón "Enter the Dungeon"
          if (
            touchX >= buttonX &&
            touchX <= buttonX + buttonWidth &&
            touchY >= buttonY &&
            touchY <= buttonY + buttonHeight
          ) {
            console.log("Enter the Dungeon button clicked");
            state = "select_hero";
            startWave(); // Empezar la primera wave del nivel
            return;
          }
        }

        // Manejar clics en modal de fin de nivel
        if (state === "level_completion" && levelCompletionModal.show) {
          const modalW = 300;
          const modalH = 200;
          const modalX = (designWidth - modalW) / 2;
          const modalY = (designHeight - modalH) / 2 - 40;
          const btnW = 120;
          const btnH = 36;
          const btnY = modalY + modalH - 70;
          const continueX = designWidth / 2 - btnW - 10;
          const surrenderX = designWidth / 2 + 10;

          // Click en Continue
          if (
            touchX >= continueX &&
            touchX <= continueX + btnW &&
            touchY >= btnY &&
            touchY <= btnY + btnH
          ) {
            console.log("Continue clicked -> next level info");
            // Preparar pantalla de información del siguiente nivel
            currentLevel = levelCompletionModal.level + 1;
            state = "level_info";
            levelCompletionModal.show = false;
            pendingLevelInfo = false; // Ya vamos directamente a la pantalla
            return;
          }

          // Click en Surrender
          if (
            touchX >= surrenderX &&
            touchX <= surrenderX + btnW &&
            touchY >= btnY &&
            touchY <= btnY + btnH
          ) {
            console.log("Surrender clicked -> game over");
            handleGameOver();
            return;
          }
        }

        // Manejar clics en la pantalla del libro de monstruos
        if (state === "book") {
          // NO reproducir música en book

          // Inicializar drag para scroll táctil
          if (e.type === "touchstart") {
            isDragging = true;
            lastTouchY = touchY;
          }

          // Botón de volver (centrado en el footer)
          const backButtonWidth = 120;
          const backButtonHeight = 40;
          const footerHeight = 60;
          const backButtonX = (designWidth - backButtonWidth) / 2;
          const backButtonY = designHeight - footerHeight + 10;

          if (
            touchX >= backButtonX &&
            touchX <= backButtonX + backButtonWidth &&
            touchY >= backButtonY &&
            touchY <= backButtonY + backButtonHeight
          ) {
            console.log("Back button clicked");
            state = "main_menu";
            isDragging = false; // Cancelar drag al hacer clic en botón
            return;
          }

          return;
        }

        // Manejar clics en la pantalla de guía
        if (state === "guide") {
          // NO reproducir música en guide

          // Inicializar drag para scroll táctil
          if (e.type === "touchstart") {
            isDragging = true;
            lastTouchY = touchY;
          }

          // Botón de volver (centrado en el footer)
          const backButtonWidth = 120;
          const backButtonHeight = 40;
          const footerHeight = 60;
          const backButtonX = (designWidth - backButtonWidth) / 2;
          const backButtonY = designHeight - footerHeight + 10;

          if (
            touchX >= backButtonX &&
            touchX <= backButtonX + backButtonWidth &&
            touchY >= backButtonY &&
            touchY <= backButtonY + backButtonHeight
          ) {
            console.log("Guide Back button clicked");
            state = "main_menu";
            isDragging = false; // Cancelar drag al hacer clic en botón
            return;
          }

          // Manejo de scroll vertical (tocar arriba o abajo de la pantalla)
          const scrollZoneHeight = 100;
          if (touchY < scrollZoneHeight) {
            // Scroll hacia arriba
            bookScrollY = Math.max(0, bookScrollY - bookScrollSpeed);
          } else if (touchY > designHeight - scrollZoneHeight) {
            // Scroll hacia abajo
            const monstersCount = 8; // Total de monstruos
            const cardHeight = 280; // Actualizado al nuevo tamaño
            const cardSpacing = 15; // Actualizado al nuevo spacing
            const totalHeight = monstersCount * (cardHeight + cardSpacing);
            const headerHeight = 50;
            const footerHeight = 60;
            const contentAreaHeight =
              designHeight - headerHeight - footerHeight;
            const maxScrollY = Math.max(0, totalHeight - contentAreaHeight);
            bookScrollY = Math.min(maxScrollY, bookScrollY + bookScrollSpeed);
          }
          return;
        }

        // Interacciones de modal de fin de nivel deshabilitadas (SDK)
        if (state === "level_completion" && levelCompletionModal.show) return;

        // Footer buttons
        if (touchY >= 520 && state === "select_hero") {
          // Actualizado de 540 a 520
          const columnWidth = designWidth / 3;
          const heroOrder = ["mage", "warlock", "priest"];

          heroOrder.forEach((heroClass, heroIndex) => {
            const hero = heroes.find((h) => h.clazz === heroClass);
            if (!hero || hero.hp <= 0) return;

            const actions = Object.keys(classActions[hero.clazz]);
            const columnX = heroIndex * columnWidth;

            // Configuración de botones para coincidir con drawFooter
            const panelWidth = columnWidth - 5; // Actualizado
            const panelX = columnX + 2.5; // Actualizado
            const buttonWidth = panelWidth - 14;
            const buttonHeight = 25; // Actualizado de 23 a 25
            const buttonX = panelX + 7;
            const buttonSpacing = 2; // Actualizado de 1 a 2

            // Botón habilidad principal (1 carga)
            const primaryY = 550; // Actualizado de 567 a 550
            if (
              touchX >= buttonX &&
              touchX <= buttonX + buttonWidth &&
              touchY >= primaryY &&
              touchY <= primaryY + buttonHeight
            ) {
              const action = actions[0];
              const actionData = classActions[hero.clazz][action];
              const canUse =
                hero.charge >= actionData.reqCharge &&
                hero.hp > 0 &&
                turnQueue.length > 0 &&
                turnQueue[0] === hero;

              if (canUse) {
                selectedHero = hero;
                selectedAction = action;

                const actionType = actionData.type;
                if (actionType === "single_enemy") {
                  state = "select_target_enemy";
                } else if (actionType === "single_ally") {
                  state = "select_target_ally";
                } else if (actionType === "all_enemy") {
                  if (
                    executeAction(
                      selectedHero,
                      action,
                      enemies.filter((e) => e.hp > 0)
                    )
                  ) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                } else if (actionType === "all_ally") {
                  if (
                    executeAction(
                      selectedHero,
                      action,
                      heroes.filter((h) => h.hp > 0)
                    )
                  ) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                } else if (actionType === "self") {
                  if (executeAction(selectedHero, action, selectedHero)) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                }
              }
            }

            // Botón habilidad secundaria (2 cargas)
            const secondaryY = primaryY + buttonHeight + buttonSpacing;
            if (
              touchX >= buttonX &&
              touchX <= buttonX + buttonWidth &&
              touchY >= secondaryY &&
              touchY <= secondaryY + buttonHeight
            ) {
              const action = actions[1];
              const actionData = classActions[hero.clazz][action];
              const canUse =
                hero.charge >= actionData.reqCharge &&
                hero.hp > 0 &&
                turnQueue.length > 0 &&
                turnQueue[0] === hero;

              if (canUse) {
                selectedHero = hero;
                selectedAction = action;

                const actionType = actionData.type;
                if (actionType === "single_enemy") {
                  state = "select_target_enemy";
                } else if (actionType === "single_ally") {
                  state = "select_target_ally";
                } else if (actionType === "all_enemy") {
                  if (
                    executeAction(
                      selectedHero,
                      action,
                      enemies.filter((e) => e.hp > 0)
                    )
                  ) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                } else if (actionType === "all_ally") {
                  if (
                    executeAction(
                      selectedHero,
                      action,
                      heroes.filter((h) => h.hp > 0)
                    )
                  ) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                } else if (actionType === "self") {
                  if (executeAction(selectedHero, action, selectedHero)) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                }
              }
            }

            // Botón habilidad terciaria (3 cargas)
            const tertiaryY = secondaryY + buttonHeight + buttonSpacing;
            if (
              touchX >= buttonX &&
              touchX <= buttonX + buttonWidth &&
              touchY >= tertiaryY &&
              touchY <= tertiaryY + buttonHeight
            ) {
              const action = actions[2];
              const actionData = classActions[hero.clazz][action];
              const canUse =
                hero.charge >= actionData.reqCharge &&
                hero.hp > 0 &&
                turnQueue.length > 0 &&
                turnQueue[0] === hero;

              if (canUse) {
                selectedHero = hero;
                selectedAction = action;

                const actionType = actionData.type;
                if (actionType === "single_enemy") {
                  state = "select_target_enemy";
                } else if (actionType === "single_ally") {
                  state = "select_target_ally";
                } else if (actionType === "all_enemy") {
                  if (
                    executeAction(
                      selectedHero,
                      action,
                      enemies.filter((e) => e.hp > 0)
                    )
                  ) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                } else if (actionType === "all_ally") {
                  if (
                    executeAction(
                      selectedHero,
                      action,
                      heroes.filter((h) => h.hp > 0)
                    )
                  ) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                } else if (actionType === "self") {
                  if (executeAction(selectedHero, action, selectedHero)) {
                    selectedHero = null;
                    selectedAction = null;
                  }
                }
              }
            }
          });
          return;
        }

        if (state === "select_hero") {
          heroes.forEach((h) => {
            if (
              h.hp > 0 &&
              Math.abs(touchX - h.posx) < 40 &&
              Math.abs(touchY - h.posy) < 40
            ) {
              // No necesitamos cambiar el estado aquí, solo usamos los botones del footer
              console.log("Hero clicked:", h.clazz);
            }
          });
        } else if (state === "select_target_enemy") {
          let targetClicked = false;
          enemies.forEach((e) => {
            const size = e.size || 80;
            if (
              e.hp > 0 &&
              Math.abs(touchX - e.posx) < size / 2 &&
              Math.abs(touchY - e.posy) < size / 2
            ) {
              if (executeAction(selectedHero, selectedAction, e)) {
                // No resetear selectedHero aquí, se resetea en applyEffect
                // NO cambiar estado a "animate" para permitir clicks rápidos
                // state = "animate";
              }
              targetClicked = true;
            }
          });

          // Si no se hizo clic en ningún enemigo, cerrar el modal
          if (!targetClicked) {
            state = "select_hero";
            if (selectedHero) {
              selectedHero.anim = "idle";
              selectedHero.frame = 0;
              selectedHero.animTime = 0;
            }
            selectedHero = null;
            selectedAction = null;
          }
        } else if (state === "select_target_ally") {
          let targetClicked = false;
          heroes.forEach((h) => {
            if (
              Math.abs(touchX - h.posx) < 40 &&
              Math.abs(touchY - h.posy) < 40
            ) {
              if (executeAction(selectedHero, selectedAction, h)) {
                // No resetear selectedHero aquí, se resetea en applyEffect
                // NO cambiar estado a "animate" para permitir clicks rápidos
                // state = "animate";
              }
              targetClicked = true;
            }
          });

          // Si no se hizo clic en ningún aliado, cerrar el modal
          if (!targetClicked) {
            state = "select_hero";
            if (selectedHero) {
              selectedHero.anim = "idle";
              selectedHero.frame = 0;
              selectedHero.animTime = 0;
            }
            selectedHero = null;
            selectedAction = null;
          }
        }
      }

      function resetGame() {
        state = "main_menu";
        currentLevel = 1;
        wave = 0;
        score = 0;
        levelCompletionModal = { show: false, level: 0, boss: "", timer: 0 };
        selectedHero = null;
        selectedAction = null;
        heroes = [];
        enemies = [];
        hitNumbers = [];
        visualEffects = [];
        pendingSounds = []; // Limpiar sonidos pendientes
        // La música se maneja en handleInput cuando se cambia a main_menu
      }

      // ================================
      // FARCADE SDK HELPER FUNCTIONS
      // ================================

      function triggerHapticFeedback() {
        if (window.FarcadeSDK) {
          window.FarcadeSDK.singlePlayer.actions.hapticFeedback();
        }
      }

      // ================================
      // FARCADE SDK INTEGRATION
      // ================================

      // Manejar solicitudes de "play again" desde Farcade
      if (window.FarcadeSDK) {
        window.FarcadeSDK.on("play_again", () => {
          resetGame();
        });

        // Manejar mute/unmute desde Farcade
        window.FarcadeSDK.on("toggle_mute", (data) => {
          if (data.isMuted) {
            // Pausar toda la música
            [menuMusic, level1Music, level2Music, level3Music].forEach(
              (music) => {
                music.muted = true;
              }
            );
          } else {
            // Reanudar la música
            [menuMusic, level1Music, level2Music, level3Music].forEach(
              (music) => {
                music.muted = false;
              }
            );
          }
        });
      }

      Promise.all([
        new Promise((r) => (backgroundImg.onload = r)),
        new Promise((r) => (backgroundLevel2Img.onload = r)),
        new Promise((r) => (mageImg.onload = r)),
        new Promise((r) => (priestImg.onload = r)),
        new Promise((r) => (warlockImg.onload = r)),
        new Promise((r) => (demonBatIdleImg.onload = r)),
        new Promise((r) => (demonBatDeathImg.onload = r)),
        new Promise((r) => (demonBatAttackImg.onload = r)),
        new Promise((r) => (wormIdleImg.onload = r)),
        new Promise((r) => (wormDeathImg.onload = r)),
        new Promise((r) => (wormAttackImg.onload = r)),
        new Promise((r) => (bossBatIdleImg.onload = r)),
        new Promise((r) => (bossBatDeathImg.onload = r)),
        new Promise((r) => (bossBatAttackImg.onload = r)),
        new Promise((r) => (mushroomIdleImg.onload = r)),
        new Promise((r) => (mushroomDeathImg.onload = r)),
        new Promise((r) => (dreadwingIdleImg.onload = r)),
        new Promise((r) => (dreadwingDeathImg.onload = r)),
        new Promise((r) => (swampGorgonIdleImg.onload = r)),
        new Promise((r) => (swampGorgonAttackImg.onload = r)),
        new Promise((r) => (swampGorgonSpecialAttackImg.onload = r)),
        new Promise((r) => (swampGorgonDeathImg.onload = r)),
        new Promise((r) => (bloodSplatImg.onload = r)),
        new Promise((r) => (enemyImg.onload = r)),
        new Promise((r) => (goblinIdleImg.onload = r)),
        new Promise((r) => (goblinDieImg.onload = r)),
        new Promise((r) => (effectsImg.onload = r)),
        new Promise((r) => (purpleEffectsImg.onload = r)),
        new Promise((r) => (healingEffectsImg.onload = r)),
        new Promise((r) => (lightningEffectsImg.onload = r)),
        new Promise((r) => (darkBoltEffectsImg.onload = r)),
        new Promise((r) => (bloodSplatEffectsImg.onload = r)),
        new Promise((r) => (bloodStormEffectsImg.onload = r)),
        new Promise((r) => (priestSmiteEffectsImg.onload = r)),
        new Promise((r) => (priestHolyWaveEffectsImg.onload = r)),
        new Promise((r) => (priestRegrowthEffectsImg.onload = r)),
        new Promise((r) => (minotaurSmashEffectsImg.onload = r)),
        new Promise((r) => (minotaurLifeStealEffectsImg.onload = r)),
        new Promise((r) => (combustionEffectsImg.onload = r)),
        new Promise((r) => (cthuluMainEffectsImg.onload = r)),
        new Promise((r) => (cthuluSpecialEffectsImg.onload = r)),
        new Promise((r) => (healingDebuffImg.onload = r)),
        new Promise((r) => (protectionDebuffImg.onload = r)),
        new Promise((r) => (combustionDebuffImg.onload = r)),
        new Promise((r) => (bersekerDebuffImg.onload = r)),
        new Promise((r) => (poisonDebuffImg.onload = r)),
        new Promise((r) => (panelBrownImg.onload = r)),
        new Promise((r) => (panelBeigeImg.onload = r)),
        new Promise((r) => (buttonLongBeigeImg.onload = r)),
        new Promise((r) => (buttonLongBrownImg.onload = r)),
        new Promise((r) => (buttonRoundBeigeImg.onload = r)),
        new Promise((r) => (iconCrossBrownImg.onload = r)),
        new Promise((r) => (mainMenuImg.onload = r)),
        new Promise((r) => (bookBackgroundImg.onload = r)),
        new Promise((r) => (level1InfoBg.onload = r)),
        new Promise((r) => (level2InfoBg.onload = r)),
        new Promise((r) => (level3InfoBg.onload = r)),
      ]).then(() => {
        // Asegurar que empezamos en el menú principal
        state = "main_menu";
        // NO reproducir música al cargar - solo al pulsar START

        // Notificar al SDK de Farcade que el juego está listo
        if (window.FarcadeSDK) {
          window.FarcadeSDK.singlePlayer.actions.ready();
        }

        requestAnimationFrame(loop);
      });
    </script>
  </body>
</html>
